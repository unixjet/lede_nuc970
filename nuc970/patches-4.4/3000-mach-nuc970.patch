Index: linux-4.4.92/arch/arm/Kconfig
===================================================================
--- linux-4.4.92.orig/arch/arm/Kconfig
+++ linux-4.4.92/arch/arm/Kconfig
@@ -590,6 +590,18 @@ config ARCH_W90X900
 	  <http://www.nuvoton.com/hq/enu/ProductAndSales/ProductLines/
 		ConsumerElectronicsIC/ARMMicrocontroller/ARMMicrocontroller>
 
+config ARCH_NUC970
+	bool "Nuvoton NUC970 CPU"
+	select ARCH_REQUIRE_GPIOLIB
+	select CLKDEV_LOOKUP
+	select CLKSRC_MMIO
+	select CPU_ARM926T
+	select GENERIC_CLOCKEVENTS
+	select PINCTRL
+	select IRQ_DOMAIN
+	help
+	  Support for Nuvoton NUC970 Series MUCs.
+
 config ARCH_LPC32XX
 	bool "NXP LPC32XX"
 	select ARCH_REQUIRE_GPIOLIB
@@ -936,6 +948,8 @@ source "arch/arm/mach-vt8500/Kconfig"
 
 source "arch/arm/mach-w90x900/Kconfig"
 
+source "arch/arm/mach-nuc970/Kconfig"
+
 source "arch/arm/mach-zx/Kconfig"
 
 source "arch/arm/mach-zynq/Kconfig"
Index: linux-4.4.92/arch/arm/Makefile
===================================================================
--- linux-4.4.92.orig/arch/arm/Makefile
+++ linux-4.4.92/arch/arm/Makefile
@@ -224,6 +224,7 @@ machine-$(CONFIG_ARCH_VERSATILE)	+= vers
 machine-$(CONFIG_ARCH_VEXPRESS)		+= vexpress
 machine-$(CONFIG_ARCH_VT8500)		+= vt8500
 machine-$(CONFIG_ARCH_W90X900)		+= w90x900
+machine-$(CONFIG_ARCH_NUC970)           += nuc970
 machine-$(CONFIG_ARCH_ZX)		+= zx
 machine-$(CONFIG_ARCH_ZYNQ)		+= zynq
 machine-$(CONFIG_PLAT_SPEAR)		+= spear
Index: linux-4.4.92/arch/arm/configs/nuc972_defconfig
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/configs/nuc972_defconfig
@@ -0,0 +1,1468 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.10.101 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_NEED_MACH_GPIO_H=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_FHANDLE=y
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_ARCH_USES_GETTIMEOFFSET=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+
+#
+# Timers subsystem
+#
+CONFIG_HZ_PERIODIC=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+# CONFIG_TINY_PREEMPT_RCU is not set
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_FANOUT=32
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_RCU_NOCB_CPU is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_MEMCG is not set
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+# CONFIG_USER_NS is not set
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_UIDGID_CONVERTED=y
+# CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../rootfs"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_INITRAMFS_COMPRESSION_NONE is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZMA is not set
+# CONFIG_INITRAMFS_COMPRESSION_XZ is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_HOTPLUG=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+CONFIG_ARCH_NUC970=y
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_PLAT_SPEAR is not set
+CONFIG_CPU_NUC970=y
+
+#
+# NUC970 Machines
+#
+CONFIG_MACH_NUC970=y
+# CONFIG_BOARD_NUC977 is not set
+CONFIG_BOARD_NUC972=y
+# CONFIG_BOARD_TOMATO is not set
+# CONFIG_BOARD_ETH2UART is not set
+# CONFIG_NUC970_FIQ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_NEED_KUSER_HELPERS=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_NR_BANKS=8
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+# CONFIG_SCHED_HRTICK is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+# CONFIG_HW_PERF_EVENTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="root=/dev/ram0 console=ttyS0,115200n8 rdinit=/sbin/init mem=64M"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+# CONFIG_SUSPEND is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ARM_CPU_SUSPEND is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_NVT_EXT_WIFI is not set
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_CFG80211_DEBUGFS=y
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CMA is not set
+# CONFIG_FMI_NUC970 is not set
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_NUC970_GE2D is not set
+# CONFIG_NUC970_SC is not set
+# CONFIG_NUC970_ETIMER is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_NUC970_EBI is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+CONFIG_NET_VENDOR_NUVOTON=y
+CONFIG_NUC970_ETH0=y
+# CONFIG_NUC970_ETH1 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+CONFIG_ICPLUS_PHY=y
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+# CONFIG_NUC970_ADC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_NUC970=y
+# CONFIG_NUC970_UART1 is not set
+# CONFIG_NUC970_UART2 is not set
+# CONFIG_NUC970_UART3 is not set
+# CONFIG_NUC970_UART4 is not set
+# CONFIG_NUC970_UART5 is not set
+# CONFIG_NUC970_UART6 is not set
+# CONFIG_NUC970_UART7 is not set
+# CONFIG_NUC970_UART8 is not set
+# CONFIG_NUC970_UART9 is not set
+# CONFIG_NUC970_UART10 is not set
+CONFIG_SERIAL_NUC970_CONSOLE=y
+# CONFIG_SCUART_NUC970 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_NUC970_MEM is not set
+# CONFIG_NUC970_DMA_PROXY is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+
+#
+# Qualcomm MSM SSBI bus support
+#
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+CONFIG_PINCTRL_NUC970=y
+# CONFIG_PINCTRL_EXYNOS5440 is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers:
+#
+CONFIG_GPIO_NUC970=y
+# CONFIG_GPIO_NUC970_EINT_WKUP is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_TS5500 is not set
+
+#
+# I2C GPIO expanders:
+#
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+
+#
+# USB GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+# CONFIG_HID is not set
+
+#
+# USB HID support
+#
+# CONFIG_USB_HID is not set
+# CONFIG_HID_PID is not set
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEFAULT_PERSIST is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_NUC970_EHCI=y
+CONFIG_NUC970_USBH_PWR_PE=y
+# CONFIG_NUC970_USBH_PWR_PF is not set
+# CONFIG_NUC970_USBH_OC_ONLY is not set
+# CONFIG_NUC970_USBH_PWR_NONE is not set
+# CONFIG_USB_NUC970_PM_VBUS_OFF is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_NUC970_OHCI=y
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_CHIPIDEA is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_PHY is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_HAVE_MACH_CLKDEV=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+CONFIG_COMMON_CLK_DEBUG=y
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKSRC_MMIO=y
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+# CONFIG_EXFAT_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+CONFIG_ROMFS_FS=y
+CONFIG_ROMFS_BACKED_BY_BLOCK=y
+CONFIG_ROMFS_ON_BLOCK=y
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_FRAME_POINTER=y
+
+#
+# RCU Debugging
+#
+# CONFIG_SPARSE_RCU_POINTER is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_LKDTM is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_ARM is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_ARM is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_VIRTUALIZATION is not set
Index: linux-4.4.92/arch/arm/kernel/atags_parse.c
===================================================================
--- linux-4.4.92.orig/arch/arm/kernel/atags_parse.c
+++ linux-4.4.92/arch/arm/kernel/atags_parse.c
@@ -191,7 +191,11 @@ setup_machine_tags(phys_addr_t __atags_p
 	 * locate machine in the list of supported machines.
 	 */
 	for_each_machine_desc(p)
+#ifdef CONFIG_ARCH_NUC970
+		if (1) {// We only enable one machine type in kernel, so the first one must be what we're looking for 
+#else
 		if (machine_nr == p->nr) {
+#endif
 			pr_info("Machine: %s\n", p->name);
 			mdesc = p;
 			break;
Index: linux-4.4.92/arch/arm/kernel/fiqasm.S
===================================================================
--- linux-4.4.92.orig/arch/arm/kernel/fiqasm.S
+++ linux-4.4.92/arch/arm/kernel/fiqasm.S
@@ -25,6 +25,7 @@
 ENTRY(__set_fiq_regs)
 	mov	r2, #PSR_I_BIT | PSR_F_BIT | FIQ_MODE
 	mrs	r1, cpsr
+	and     r1, #~PSR_F_BIT   @enable F bit
 	msr	cpsr_c, r2	@ select FIQ mode
 	mov	r0, r0		@ avoid hazard prior to ARMv4
 	ldmia	r0!, {r8 - r12}
Index: linux-4.4.92/arch/arm/mach-nuc970/Kconfig
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/Kconfig
@@ -0,0 +1,74 @@
+if ARCH_NUC970
+
+config CPU_NUC970
+	bool
+	select HAVE_CLK_PREPARE
+	select HAVE_MACH_CLKDEV
+    select COMMON_CLK
+	default y
+	help
+	  Support for NUC970 of Nuvoton MCU
+
+menu "NUC970 Machines"
+
+config MACH_NUC970
+	bool "Nuvoton NUC970 Evaluation Board"
+	default y
+	select CPU_NUC970
+	help
+	   Say Y here if you are using the Nuvoton NUC970
+endmenu
+
+choice 
+    prompt "Nuvoton NUC970 Series Development Board"
+    
+config BOARD_NUC977
+	depends on !USE_OF
+    bool "NUC977 Development Board"
+
+config BOARD_NUC972
+	depends on !USE_OF
+    bool "NUC972 Development Board"
+    
+config BOARD_TOMATO
+	depends on !USE_OF
+    bool "NUC976 Tomato Board"
+
+config BOARD_ETH2UART
+	depends on !USE_OF
+    bool "NUC972 Ethernet To UART Board"
+
+config MACH_NUC972_EVB_DT
+	bool "Nuvoton NUC972 evaluation board using device tree"
+	depends on USE_OF
+	help
+	  Machine support for Nuvoton NUC972 machine with device tree enabled.
+	  Note: This is under development and not all peripherals can be supported
+	  with this machine file.
+
+endchoice
+
+config NUC970_FIQ
+    bool "Nuvoton NUC970 FIQ support"
+    select FIQ
+    ---help---
+	  Support FIQ in NUC970. For more information, please refer to NUC970 BSP user's manual.
+      
+endif
+
+choice 
+    prompt "Nuvoton NUC970 System Clock Selection"
+	help
+	  To support NO_HZ or HRTIMER, ETIMER must be used as system clock source.
+          NOTE: If ETIMER is selected, ETIMER0/1will be used as system clock souce and 
+          clock event and cannot used for capture or toggle out.
+    
+config NUC970_CLK_TIMER
+    bool "TIMER as system clock source"
+    select ARCH_USES_GETTIMEOFFSET
+
+config NUC970_CLK_ETIMER
+    bool "ETIMER as system clock source"
+
+endchoice
+
Index: linux-4.4.92/arch/arm/mach-nuc970/Makefile
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y				:= irq.o clk-ccf.o clk-apll.o clk-upll.o dev.o cpu.o mfp.o mach-nuc970.o pm.o suspend.o
+obj-$(CONFIG_NUC970_CLK_TIMER)	+= time.o
+obj-$(CONFIG_NUC970_CLK_ETIMER)	+= etime.o
+obj-$(CONFIG_NUC970_FIQ)	+= fiq.o
+obj-$(CONFIG_OF)		+= dt-nuc972-evb.o
+
Index: linux-4.4.92/arch/arm/mach-nuc970/Makefile.boot
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/Makefile.boot
@@ -0,0 +1,3 @@
+zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+
Index: linux-4.4.92/arch/arm/mach-nuc970/clk-apll.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/clk-apll.c
@@ -0,0 +1,185 @@
+/*
+ * linux/arch/arm/mach-nuc970/clk-apll.c
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+ 
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+
+#include "clk-ccf.h"
+
+/**
+ * apll 
+ *
+ * @clk_hw	clock source
+ * @parent	the parent clock name
+ * @base	base address of pll registers
+ *
+ */
+struct clk_apll {
+	struct clk_hw	hw;
+	void __iomem	*base;
+};
+
+#define to_clk_apll(clk) (container_of(clk, struct clk_apll, clk))
+
+static int clk_apll_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long parent_rate)
+{
+	struct clk_apll *pll = to_clk_apll(hw);
+	u32 reg;
+	
+	reg = readl(pll->base) & ~0x0FFFFFFF;
+
+	switch(rate)
+	{
+		case 96000000:			//usbh
+			reg |= 0x8027;
+			break;
+			
+		case 98400000:			//i2s
+			reg |= 0x8028;
+			break;
+		
+		case 169500000:			//i2s
+			reg |= 0x21f0;
+			break;
+		
+		case 264000000:			//system default, 264MHz
+			reg |= 0x15;
+			break;
+		
+		case 300000000:		
+			reg |= 0x18;
+			break;
+		
+		default:
+			reg |= 0x15;
+			break;
+	}
+	
+	writel(reg, pll->base);
+
+	return 0;
+}
+
+static unsigned long clk_apll_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	struct clk_apll *pll = to_clk_apll(hw);
+	long long ll;
+	u32 reg = readl(pll->base) & 0x0FFFFFFF;
+	
+	if(parent_rate != 12000000)
+		return 0;
+	
+	switch(reg)
+	{
+		case 0x15:
+			ll = 264000000;		//system default, 264MHz
+			break;
+		
+		case 0x18:
+			ll = 300000000;
+			break;
+				
+		case 0x8027:
+			ll = 96000000;		//usbh
+			break;
+			
+		case 0x8028:
+			ll = 98400000;		//i2s
+			break;
+		
+		case 0x21f0:
+			ll = 169500000;		//i2s
+			break;
+			
+		default:
+			ll = 264000000;
+			break;
+	}
+
+	return ll;
+}
+
+static long clk_apll_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *prate)
+{
+	return rate;
+}
+
+static int clk_apll_enable(struct clk_hw *hw)
+{
+	struct clk_apll *pll = to_clk_apll(hw);
+	u32 val;
+	
+	val = readl(pll->base);
+	val &= ~0x10000000;			// PD = 0, power down mode disable
+	val |= 0x40000000;			// RESETN = 1
+	writel(val, pll->base);
+	
+	return 0;
+}
+
+static void clk_apll_disable(struct clk_hw *hw)
+{
+	struct clk_apll *pll = to_clk_apll(hw);
+	u32 val;
+	
+	val = readl(pll->base);
+	val |= 0x10000000;			// PD = 1, power down mode enable
+	val &= ~0x40000000;			// RESETN = 1
+	writel(val, pll->base);
+}
+
+static struct clk_ops clk_apll_ops = {
+	.recalc_rate = clk_apll_recalc_rate,
+	.enable = clk_apll_enable,
+	.disable = clk_apll_disable,
+	.set_rate = clk_apll_set_rate,
+	.round_rate = clk_apll_round_rate,
+};
+
+struct clk *nuc970_clk_apll(const char *name, const char *parent,
+		void __iomem *base)
+{
+	struct clk_apll *pll;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	pll = kmalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+
+	pll->base = base;
+
+	init.name = name;
+	init.ops = &clk_apll_ops;
+	init.flags = 0;
+	init.parent_names = &parent;
+	init.num_parents = 1;
+
+	pll->hw.init = &init;
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk))
+		kfree(pll);
+
+	return clk;
+}
Index: linux-4.4.92/arch/arm/mach-nuc970/clk-ccf.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/clk-ccf.c
@@ -0,0 +1,679 @@
+/*
+ * linux/arch/arm/mach-nuc970/clk-ccf.c
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/clkdev.h>
+#include <linux/err.h>
+#include <mach/hardware.h>
+#include <mach/regs-clock.h>
+#include <linux/spinlock.h>
+
+#include "clk-ccf.h"
+
+DEFINE_SPINLOCK(nuc970_lock);
+
+static const char *sys_sel_clks[] = { "xin", "dummy", "apll", "upll", };
+static const char *lcd_sel_clks[] = { "xin", "dummy", "lcd_aplldiv", "lcd_uplldiv", };
+static const char *audio_sel_clks[] = { "xin", "dummy", "audio_aplldiv", "audio_uplldiv", };
+static const char *usb_sel_clks[] = { "xin", "dummy", "usb_aplldiv", "usb_uplldiv", };
+static const char *adc_sel_clks[] = { "xin", "dummy", "adc_aplldiv", "adc_uplldiv", };
+static const char *cap_sel_clks[] = { "xin", "dummy", "cap_aplldiv", "cap_uplldiv", };
+static const char *sdh_sel_clks[] = { "xin", "dummy", "sdh_aplldiv", "sdh_uplldiv", };
+static const char *emmc_sel_clks[] = { "xin", "dummy", "emmc_aplldiv", "emmc_uplldiv", };
+static const char *uart0_sel_clks[] = { "xin", "dummy", "uart0_aplldiv", "uart0_uplldiv", };
+static const char *uart1_sel_clks[] = { "xin", "dummy", "uart1_aplldiv", "uart1_uplldiv", };
+static const char *uart2_sel_clks[] = { "xin", "dummy", "uart2_aplldiv", "uart2_uplldiv", };
+static const char *uart3_sel_clks[] = { "xin", "dummy", "uart3_aplldiv", "uart3_uplldiv", };
+static const char *uart4_sel_clks[] = { "xin", "dummy", "uart4_aplldiv", "uart4_uplldiv", };
+static const char *uart5_sel_clks[] = { "xin", "dummy", "uart5_aplldiv", "uart5_uplldiv", };
+static const char *uart6_sel_clks[] = { "xin", "dummy", "uart6_aplldiv", "uart6_uplldiv", };
+static const char *uart7_sel_clks[] = { "xin", "dummy", "uart7_aplldiv", "uart7_uplldiv", };
+static const char *uart8_sel_clks[] = { "xin", "dummy", "uart8_aplldiv", "uart8_uplldiv", };
+static const char *uart9_sel_clks[] = { "xin", "dummy", "uart9_aplldiv", "uart9_uplldiv", };
+static const char *uart10_sel_clks[] = { "xin", "dummy", "uart10_aplldiv", "uart10_uplldiv", };
+static const char *system_sel_clks[] = { "xin", "dummy", "system_aplldiv", "system_uplldiv", };
+static const char *gpio_sel_clks[] = { "xin", "xin32k"};
+static const char *kpi_sel_clks[] = { "xin", "xin32k"};
+static const char *etimer_sel_clks[] = { "xin", "pclk_div", "pclk4096_div", "xin32k",};
+static const char *wwdt_sel_clks[] = { "xin", "xin128_div", "pclk4096_div", "xin32k",};
+
+enum nuc970_clks {
+	// source
+	xin, apll, upll, xin32k, xin128_div, 
+	
+	// eclk
+	usb_aplldiv, usb_uplldiv, usb_eclk_mux, usb_eclk_div, usb_eclk_gate,
+	sd_aplldiv, sd_uplldiv, sd_eclk_mux, sd_eclk_div, sd_eclk_gate,
+	lcd_aplldiv, lcd_uplldiv, lcd_eclk_mux, lcd_eclk_div, lcd_eclk_gate,
+	adc_aplldiv, adc_uplldiv, adc_eclk_mux, adc_eclk_div, adc_eclk_gate,
+	audio_aplldiv, audio_uplldiv, audio_eclk_mux, audio_eclk_div, audio_eclk_gate,
+	cap_aplldiv, cap_uplldiv, cap_eclk_mux, cap_eclk_div, cap_eclk_gate,
+	sdh_aplldiv, sdh_uplldiv, sdh_eclk_mux, sdh_eclk_div, sdh_eclk_gate,
+	emmc_aplldiv, emmc_uplldiv, emmc_eclk_mux, emmc_eclk_div, emmc_eclk_gate,
+	uart0_aplldiv, uart0_uplldiv, uart0_eclk_mux, uart0_eclk_div, uart0_eclk_gate,
+	uart1_aplldiv, uart1_uplldiv, uart1_eclk_mux, uart1_eclk_div, uart1_eclk_gate,
+	uart2_aplldiv, uart2_uplldiv, uart2_eclk_mux, uart2_eclk_div, uart2_eclk_gate,
+	uart3_aplldiv, uart3_uplldiv, uart3_eclk_mux, uart3_eclk_div, uart3_eclk_gate,
+	uart4_aplldiv, uart4_uplldiv, uart4_eclk_mux, uart4_eclk_div, uart4_eclk_gate,
+	uart5_aplldiv, uart5_uplldiv, uart5_eclk_mux, uart5_eclk_div, uart5_eclk_gate,
+	uart6_aplldiv, uart6_uplldiv, uart6_eclk_mux, uart6_eclk_div, uart6_eclk_gate,
+	uart7_aplldiv, uart7_uplldiv, uart7_eclk_mux, uart7_eclk_div, uart7_eclk_gate,
+	uart8_aplldiv, uart8_uplldiv, uart8_eclk_mux, uart8_eclk_div, uart8_eclk_gate,
+	uart9_aplldiv, uart9_uplldiv, uart9_eclk_mux, uart9_eclk_div, uart9_eclk_gate,
+	uart10_aplldiv, uart10_uplldiv, uart10_eclk_mux, uart10_eclk_div, uart10_eclk_gate,
+	system_aplldiv, system_uplldiv, system_eclk_mux, system_eclk_div, system_eclk_gate,	
+	gpio_eclk_mux, gpio_eclk_div, gpio_eclk_gate,
+	kpi_eclk_mux, kpi_eclk_div, kpi_eclk_gate,
+	etimer0_eclk_mux, etimer0_eclk_gate,
+	etimer1_eclk_mux, etimer1_eclk_gate,
+	etimer2_eclk_mux, etimer2_eclk_gate,
+	etimer3_eclk_mux, etimer3_eclk_gate,
+	wwdt_eclk_mux, wwdt_eclk_gate,
+	wdt_eclk_mux, wdt_eclk_gate,
+	smc0_eclk_div, smc0_eclk_gate, smc0_gate, 
+	smc1_eclk_div, smc1_eclk_gate, smc1_gate, 
+	
+	// sys
+	sys_mux, sys_div, cpu_div, cpu_gate, ddr_gate, 
+	
+	// hclk
+	hclk_gate, hclk1_div, gdma_gate, ebi_gate, tic_gate, sram_gate, 
+	hclkn_div, dram_gate, hclk234_div, 
+	usbh_gate, emac1_gate, emac1_eclk_div, emac1_eclk_gate, usbd_gate, fmi_gate, nand_gate, emmc_gate, crypto_gate, jpeg_gate, jpeg_eclk_div, jpeg_eclk_gate, ge2d_gate, ge2d_eclk_div, ge2d_eclk_gate,
+	emac0_gate, emac0_eclk_div, emac0_eclk_gate, sdh_gate, audio_gate, lcd_gate, cap_gate, sensor_gate,
+	
+	
+	// pclk
+	pclk_div, pclk4096_div, 
+	i2c0_gate, i2c1_gate,
+	spi0_gate, spi1_gate,
+	uart0_gate, uart1_gate, uart2_gate, uart3_gate, uart4_gate, uart5_gate, uart6_gate, uart7_gate, uart8_gate, uart9_gate, uart10_gate,
+	timer0_gate, timer1_gate, timer2_gate, timer3_gate, timer4_gate, 
+	wdt_gate,
+	rtc_gate,
+	wwdt_gate, 
+	gpio_gate,	
+	adc_gate, 
+	kpi_gate, 
+	mtpc_gate,
+	pwm_gate,
+	etimer0_gate, etimer1_gate, etimer2_gate, etimer3_gate,
+	can0_gate, can1_gate, 
+	
+	clk_max
+};
+
+static struct clk *clk[clk_max];
+
+int __init nuc970_init_clocks(void)
+{
+	int i;
+	
+	// source
+	clk[xin] 		= nuc970_clk_fixed("xin", 12000000);
+	clk[xin32k] 	= nuc970_clk_fixed("xin32k", 32768);
+	clk[apll] 		= nuc970_clk_apll("apll", "xin", REG_CLK_APLLCON);
+	clk[upll] 		= nuc970_clk_upll("upll", "xin", REG_CLK_UPLLCON);
+	
+	clk[xin128_div]  = nuc970_clk_fixed_factor("xin128_div", "xin", 1, 128);		//  xin/128
+	
+	clk[sys_mux] 	= nuc970_clk_mux("sys_mux", REG_CLK_DIV0, 3, 2, sys_sel_clks, ARRAY_SIZE(sys_sel_clks));
+	clk[sys_div]	= nuc970_clk_divider("sys_div", "sys_mux", REG_CLK_DIV0, 0, 2);
+	clk[ddr_gate] = nuc970_clk_gate("ddr_gate", "sys_div", REG_CLK_HCLKEN, 10);
+		
+	// CPU
+	clk[cpu_div]  = nuc970_clk_divider("cpu_div", "sys_div", REG_CLK_DIV0, 16, 1);
+	clk[cpu_gate] = nuc970_clk_gate("cpu_gate", "cpu_div", REG_CLK_HCLKEN, 0);
+	
+	// HCLK1 & PCLK
+	clk[hclk1_div]  = nuc970_clk_fixed_factor("hclk1_div", "cpu_div", 1, 2);	
+	clk[gdma_gate] = nuc970_clk_gate("gdma_hclk_gate", "hclk1_div", REG_CLK_HCLKEN, 12);
+	clk[ebi_gate] = nuc970_clk_gate("ebi_hclk_gate", "hclk1_div", REG_CLK_HCLKEN, 9);
+	clk[tic_gate] = nuc970_clk_gate("tic_hclk_gate", "hclk1_div", REG_CLK_HCLKEN, 7);
+	
+	// HCLK & HCLK234
+	clk[hclkn_div]  = nuc970_clk_fixed_factor("hclkn_div", "sys_div", 1, 2);			//  /2		
+	clk[dram_gate] = nuc970_clk_gate("dram_gate", "hclkn_div", REG_CLK_HCLKEN, 10);
+	clk[hclk_gate] = nuc970_clk_gate("hclk_gate", "hclkn_div", REG_CLK_HCLKEN, 1);
+	clk[sram_gate] = nuc970_clk_gate("sram_gate", "hclk_gate", REG_CLK_HCLKEN, 8);
+	clk[hclk234_div] = nuc970_clk_divider("hclk234_div", "hclkn_div", REG_CLK_DIV0, 20, 4);
+	
+	// HCLK3
+	clk[usbh_gate] = nuc970_clk_gate("usbh_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 18);	
+	clk[usbd_gate] = nuc970_clk_gate("usbd_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 19);
+	clk[fmi_gate] = nuc970_clk_gate("fmi_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 20);
+	clk[nand_gate] = nuc970_clk_gate("nand_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 21);
+	clk[emmc_gate] = nuc970_clk_gate("emmc_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 22);
+	clk[crypto_gate] = nuc970_clk_gate("crypto_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 23);
+	
+	clk[emac1_gate] = nuc970_clk_gate("emac1_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 17);
+	clk[emac1_eclk_div] = nuc970_clk_divider("emac1_eclk_div", "hclk234_div", REG_CLK_DIV8, 0, 8);
+	clk[emac1_eclk_gate] = nuc970_clk_gate("emac1_eclk_gate", "emac1_eclk_div", REG_CLK_HCLKEN, 17);
+	
+	clk[jpeg_gate] = nuc970_clk_gate("jpeg_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 29);
+	clk[jpeg_eclk_div] = nuc970_clk_divider("jpeg_eclk_div", "hclk234_div", REG_CLK_DIV3, 28, 3);
+	clk[jpeg_eclk_gate] = nuc970_clk_gate("jpeg_eclk_gate", "jpeg_eclk_div", REG_CLK_HCLKEN, 29);
+    
+    clk[ge2d_gate] = nuc970_clk_gate("ge2d_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 28);
+	clk[ge2d_eclk_div] = nuc970_clk_divider("ge2d_eclk_div", "hclk234_div", REG_CLK_DIV2, 28, 2);
+	clk[ge2d_eclk_gate] = nuc970_clk_gate("ge2d_eclk_gate", "ge2d_eclk_div", REG_CLK_HCLKEN, 28);
+	
+	// HCLK4
+	clk[sdh_gate] = nuc970_clk_gate("sdh_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 30);
+	clk[audio_gate] = nuc970_clk_gate("audio_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 24);
+	clk[lcd_gate] = nuc970_clk_gate("lcd_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 25);
+	clk[cap_gate] = nuc970_clk_gate("cap_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 26);
+	clk[sensor_gate] = nuc970_clk_gate("sensor_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 27);
+	
+	clk[emac0_gate] = nuc970_clk_gate("emac0_hclk_gate", "hclk234_div", REG_CLK_HCLKEN, 16);
+	clk[emac0_eclk_div] = nuc970_clk_divider("emac0_eclk_div", "hclk234_div", REG_CLK_DIV8, 0, 8);
+	clk[emac0_eclk_gate] = nuc970_clk_gate("emac0_eclk_gate", "emac0_eclk_div", REG_CLK_HCLKEN, 16);
+				
+	// ECLK
+	// -USB
+	clk[usb_aplldiv]	= nuc970_clk_divider("usb_aplldiv", "apll", REG_CLK_DIV2, 0, 3);
+	clk[usb_uplldiv]	= nuc970_clk_divider("usb_uplldiv", "upll", REG_CLK_DIV2, 0, 3);
+	clk[usb_eclk_mux]	= nuc970_clk_mux("usb_eclk_mux", REG_CLK_DIV2, 3, 2, usb_sel_clks, ARRAY_SIZE(usb_sel_clks));
+	clk[usb_eclk_div]	= nuc970_clk_divider("usb_eclk_div", "usb_eclk_mux", REG_CLK_DIV2, 8, 4);
+	clk[usb_eclk_gate]  = nuc970_clk_gate("usb_eclk_gate", "usb_eclk_div", REG_CLK_HCLKEN, 18);
+	
+	// -SDH
+	clk[sdh_aplldiv]	= nuc970_clk_divider("sdh_aplldiv", "apll", REG_CLK_DIV9, 0, 3);
+	clk[sdh_uplldiv]	= nuc970_clk_divider("sdh_uplldiv", "upll", REG_CLK_DIV9, 0, 3);
+	clk[sdh_eclk_mux]	= nuc970_clk_mux("sdh_eclk_mux", REG_CLK_DIV9, 3, 2, sdh_sel_clks, ARRAY_SIZE(sdh_sel_clks));
+	clk[sdh_eclk_div]	= nuc970_clk_divider("sdh_eclk_div", "sdh_eclk_mux", REG_CLK_DIV9, 8, 8);
+	clk[sdh_eclk_gate]  = nuc970_clk_gate("sdh_eclk_gate", "sdh_eclk_div", REG_CLK_HCLKEN, 30);
+	
+	// -EMMC
+	clk[emmc_aplldiv]	= nuc970_clk_divider("emmc_aplldiv", "apll", REG_CLK_DIV3, 0, 3);
+	clk[emmc_uplldiv]	= nuc970_clk_divider("emmc_uplldiv", "upll", REG_CLK_DIV3, 0, 3);
+	clk[emmc_eclk_mux]	= nuc970_clk_mux("emmc_eclk_mux", REG_CLK_DIV3, 3, 2, emmc_sel_clks, ARRAY_SIZE(emmc_sel_clks));
+	clk[emmc_eclk_div]	= nuc970_clk_divider("emmc_eclk_div", "emmc_eclk_mux", REG_CLK_DIV3, 8, 8);
+	clk[emmc_eclk_gate]  = nuc970_clk_gate("emmc_eclk_gate", "emmc_eclk_div", REG_CLK_HCLKEN, 22);
+	
+	// -ADC
+	clk[adc_aplldiv]	= nuc970_clk_divider("adc_aplldiv", "apll", REG_CLK_DIV7, 16, 3);
+	clk[adc_uplldiv]	= nuc970_clk_divider("adc_uplldiv", "upll", REG_CLK_DIV7, 16, 3);
+	clk[adc_eclk_mux]	= nuc970_clk_mux("adc_eclk_mux", REG_CLK_DIV7, 19, 2, adc_sel_clks, ARRAY_SIZE(adc_sel_clks));
+	clk[adc_eclk_div]	= nuc970_clk_divider("adc_eclk_div", "adc_eclk_mux", REG_CLK_DIV7, 24, 8);
+	clk[adc_eclk_gate]  = nuc970_clk_gate("adc_eclk_gate", "adc_eclk_div", REG_CLK_PCLKEN1, 24);
+	
+	// -LCD
+	clk[lcd_aplldiv]	= nuc970_clk_divider("lcd_aplldiv", "apll", REG_CLK_DIV1, 0, 3);
+	clk[lcd_uplldiv]	= nuc970_clk_divider("lcd_uplldiv", "upll", REG_CLK_DIV1, 0, 3);
+	clk[lcd_eclk_mux] 	= nuc970_clk_mux("lcd_eclk_mux", REG_CLK_DIV1, 3, 2, lcd_sel_clks, ARRAY_SIZE(lcd_sel_clks));
+	clk[lcd_eclk_div]	= nuc970_clk_divider("lcd_eclk_div", "lcd_eclk_mux", REG_CLK_DIV1, 8, 8);
+	clk[lcd_eclk_gate]  = nuc970_clk_gate("lcd_eclk_gate", "lcd_eclk_div", REG_CLK_HCLKEN, 25);
+
+	// -AUDIO
+	clk[audio_aplldiv]	= nuc970_clk_divider("audio_aplldiv", "apll", REG_CLK_DIV1, 16, 3);
+	clk[audio_uplldiv]	= nuc970_clk_divider("audio_uplldiv", "upll", REG_CLK_DIV1, 16, 3);
+	clk[audio_eclk_mux] = nuc970_clk_mux("audio_eclk_mux", REG_CLK_DIV1, 19, 2, audio_sel_clks, ARRAY_SIZE(audio_sel_clks));
+	clk[audio_eclk_div]	= nuc970_clk_divider("audio_eclk_div", "audio_eclk_mux", REG_CLK_DIV1, 24, 8);
+	clk[audio_eclk_gate]  = nuc970_clk_gate("audio_eclk_gate", "audio_eclk_div", REG_CLK_HCLKEN, 24);
+
+	// -CAP
+	clk[cap_aplldiv]	= nuc970_clk_divider("cap_aplldiv", "apll", REG_CLK_DIV3, 16, 3);
+	clk[cap_uplldiv]	= nuc970_clk_divider("cap_uplldiv", "upll", REG_CLK_DIV3, 16, 3);
+	clk[cap_eclk_mux]   = nuc970_clk_mux("cap_eclk_mux", REG_CLK_DIV3, 19, 2, cap_sel_clks, ARRAY_SIZE(cap_sel_clks));
+	clk[cap_eclk_div]	= nuc970_clk_divider("cap_eclk_div", "cap_eclk_mux", REG_CLK_DIV3, 24, 4);
+	clk[cap_eclk_gate]  = nuc970_clk_gate("cap_eclk_gate", "cap_eclk_div", REG_CLK_HCLKEN, 26);
+
+	// -UART0
+	clk[uart0_aplldiv]	= nuc970_clk_divider("uart0_aplldiv", "apll", REG_CLK_DIV4, 0, 3);
+	clk[uart0_uplldiv]	= nuc970_clk_divider("uart0_uplldiv", "upll", REG_CLK_DIV4, 0, 3);
+	clk[uart0_eclk_mux] = nuc970_clk_mux("uart0_eclk_mux", REG_CLK_DIV4, 3, 2, uart0_sel_clks, ARRAY_SIZE(uart0_sel_clks));
+	clk[uart0_eclk_div]	= nuc970_clk_divider("uart0_eclk_div", "uart0_eclk_mux", REG_CLK_DIV4, 5, 3);
+	clk[uart0_eclk_gate]  = nuc970_clk_gate("uart0_eclk_gate", "uart0_eclk_div", REG_CLK_PCLKEN0, 16);
+	
+	// -UART1
+	clk[uart1_aplldiv]	= nuc970_clk_divider("uart1_aplldiv", "apll", REG_CLK_DIV4, 8, 3);
+	clk[uart1_uplldiv]	= nuc970_clk_divider("uart1_uplldiv", "upll", REG_CLK_DIV4, 8, 3);
+	clk[uart1_eclk_mux] = nuc970_clk_mux("uart1_eclk_mux", REG_CLK_DIV4, 11, 2, uart1_sel_clks, ARRAY_SIZE(uart1_sel_clks));
+	clk[uart1_eclk_div]	= nuc970_clk_divider("uart1_eclk_div", "uart1_eclk_mux", REG_CLK_DIV4, 13, 3);
+	clk[uart1_eclk_gate]  = nuc970_clk_gate("uart1_eclk_gate", "uart1_eclk_div", REG_CLK_PCLKEN0, 17);
+	
+	// -UART2
+	clk[uart2_aplldiv]	= nuc970_clk_divider("uart2_aplldiv", "apll", REG_CLK_DIV4, 16, 3);
+	clk[uart2_uplldiv]	= nuc970_clk_divider("uart2_uplldiv", "upll", REG_CLK_DIV4, 16, 3);
+	clk[uart2_eclk_mux] = nuc970_clk_mux("uart2_eclk_mux", REG_CLK_DIV4, 19, 2, uart2_sel_clks, ARRAY_SIZE(uart2_sel_clks));
+	clk[uart2_eclk_div]	= nuc970_clk_divider("uart2_eclk_div", "uart2_eclk_mux", REG_CLK_DIV4, 21, 3);
+	clk[uart2_eclk_gate]  = nuc970_clk_gate("uart2_eclk_gate", "uart2_eclk_div", REG_CLK_PCLKEN0, 18);
+	
+	// -UART3
+	clk[uart3_aplldiv]	= nuc970_clk_divider("uart3_aplldiv", "apll", REG_CLK_DIV4, 24, 3);
+	clk[uart3_uplldiv]	= nuc970_clk_divider("uart3_uplldiv", "upll", REG_CLK_DIV4, 24, 3);
+	clk[uart3_eclk_mux] = nuc970_clk_mux("uart3_eclk_mux", REG_CLK_DIV4, 27, 2, uart3_sel_clks, ARRAY_SIZE(uart3_sel_clks));
+	clk[uart3_eclk_div]	= nuc970_clk_divider("uart3_eclk_div", "uart3_eclk_mux", REG_CLK_DIV4, 29, 3);
+	clk[uart3_eclk_gate]  = nuc970_clk_gate("uart3_eclk_gate", "uart3_eclk_div", REG_CLK_PCLKEN0, 19);
+	
+	// -UART4
+	clk[uart4_aplldiv]	= nuc970_clk_divider("uart4_aplldiv", "apll", REG_CLK_DIV5, 0, 3);
+	clk[uart4_uplldiv]	= nuc970_clk_divider("uart4_uplldiv", "upll", REG_CLK_DIV5, 0, 3);
+	clk[uart4_eclk_mux] = nuc970_clk_mux("uart4_eclk_mux", REG_CLK_DIV5, 3, 2, uart4_sel_clks, ARRAY_SIZE(uart4_sel_clks));
+	clk[uart4_eclk_div]	= nuc970_clk_divider("uart4_eclk_div", "uart4_eclk_mux", REG_CLK_DIV5, 5, 3);
+	clk[uart4_eclk_gate]  = nuc970_clk_gate("uart4_eclk_gate", "uart4_eclk_div", REG_CLK_PCLKEN0, 20);
+	
+	// -UART5
+	clk[uart5_aplldiv]	= nuc970_clk_divider("uart5_aplldiv", "apll", REG_CLK_DIV5, 8, 3);
+	clk[uart5_uplldiv]	= nuc970_clk_divider("uart5_uplldiv", "upll", REG_CLK_DIV5, 8, 3);
+	clk[uart5_eclk_mux] = nuc970_clk_mux("uart5_eclk_mux", REG_CLK_DIV5, 11, 2, uart5_sel_clks, ARRAY_SIZE(uart5_sel_clks));
+	clk[uart5_eclk_div]	= nuc970_clk_divider("uart5_eclk_div", "uart5_eclk_mux", REG_CLK_DIV5, 13, 3);
+	clk[uart5_eclk_gate]  = nuc970_clk_gate("uart5_eclk_gate", "uart5_eclk_div", REG_CLK_PCLKEN0, 21);
+	
+	// -UART6
+	clk[uart6_aplldiv]	= nuc970_clk_divider("uart6_aplldiv", "apll", REG_CLK_DIV5, 16, 3);
+	clk[uart6_uplldiv]	= nuc970_clk_divider("uart6_uplldiv", "upll", REG_CLK_DIV5, 16, 3);
+	clk[uart6_eclk_mux] = nuc970_clk_mux("uart6_eclk_mux", REG_CLK_DIV5, 19, 2, uart6_sel_clks, ARRAY_SIZE(uart6_sel_clks));
+	clk[uart6_eclk_div]	= nuc970_clk_divider("uart6_eclk_div", "uart6_eclk_mux", REG_CLK_DIV5, 21, 3);
+	clk[uart6_eclk_gate]  = nuc970_clk_gate("uart6_eclk_gate", "uart6_eclk_div", REG_CLK_PCLKEN0, 22);
+	
+	// -UART7
+	clk[uart7_aplldiv]	= nuc970_clk_divider("uart7_aplldiv", "apll", REG_CLK_DIV5, 24, 3);
+	clk[uart7_uplldiv]	= nuc970_clk_divider("uart7_uplldiv", "upll", REG_CLK_DIV5, 24, 3);
+	clk[uart7_eclk_mux] = nuc970_clk_mux("uart7_eclk_mux", REG_CLK_DIV5, 27, 2, uart7_sel_clks, ARRAY_SIZE(uart7_sel_clks));
+	clk[uart7_eclk_div]	= nuc970_clk_divider("uart7_eclk_div", "uart7_eclk_mux", REG_CLK_DIV5, 29, 3);
+	clk[uart7_eclk_gate]  = nuc970_clk_gate("uart7_eclk_gate", "uart7_eclk_div", REG_CLK_PCLKEN0, 23);
+	
+	// -UART8
+	clk[uart8_aplldiv]	= nuc970_clk_divider("uart8_aplldiv", "apll", REG_CLK_DIV6, 0, 3);
+	clk[uart8_uplldiv]	= nuc970_clk_divider("uart8_uplldiv", "upll", REG_CLK_DIV6, 0, 3);
+	clk[uart8_eclk_mux] = nuc970_clk_mux("uart8_eclk_mux", REG_CLK_DIV6, 3, 2, uart8_sel_clks, ARRAY_SIZE(uart8_sel_clks));
+	clk[uart8_eclk_div]	= nuc970_clk_divider("uart8_eclk_div", "uart8_eclk_mux", REG_CLK_DIV6, 5, 3);
+	clk[uart8_eclk_gate]  = nuc970_clk_gate("uart8_eclk_gate", "uart8_eclk_div", REG_CLK_PCLKEN0, 24);
+	
+	// -UART9
+	clk[uart9_aplldiv]	= nuc970_clk_divider("uart9_aplldiv", "apll", REG_CLK_DIV6, 8, 3);
+	clk[uart9_uplldiv]	= nuc970_clk_divider("uart9_uplldiv", "upll", REG_CLK_DIV6, 8, 3);
+	clk[uart9_eclk_mux] = nuc970_clk_mux("uart9_eclk_mux", REG_CLK_DIV6, 11, 2, uart9_sel_clks, ARRAY_SIZE(uart9_sel_clks));
+	clk[uart9_eclk_div]	= nuc970_clk_divider("uart9_eclk_div", "uart9_eclk_mux", REG_CLK_DIV6, 13, 3);
+	clk[uart9_eclk_gate]  = nuc970_clk_gate("uart9_eclk_gate", "uart9_eclk_div", REG_CLK_PCLKEN0, 25);
+	
+	// -UART10
+	clk[uart10_aplldiv]	 = nuc970_clk_divider("uart10_aplldiv", "apll", REG_CLK_DIV6, 16, 3);
+	clk[uart10_uplldiv]	 = nuc970_clk_divider("uart10_uplldiv", "upll", REG_CLK_DIV6, 16, 3);
+	clk[uart10_eclk_mux] = nuc970_clk_mux("uart10_eclk_mux", REG_CLK_DIV6, 19, 2, uart10_sel_clks, ARRAY_SIZE(uart10_sel_clks));
+	clk[uart10_eclk_div] = nuc970_clk_divider("uart10_eclk_div", "uart10_eclk_mux", REG_CLK_DIV6, 21, 3);
+	clk[uart10_eclk_gate]= nuc970_clk_gate("uart10_eclk_gate", "uart10_eclk_div", REG_CLK_PCLKEN0, 26);
+	
+	// -SYSTEM
+	clk[system_aplldiv]	 = nuc970_clk_divider("system_aplldiv", "apll", REG_CLK_DIV0, 0, 3);
+	clk[system_uplldiv]	 = nuc970_clk_divider("system_uplldiv", "upll", REG_CLK_DIV0, 0, 3);
+	clk[system_eclk_mux] = nuc970_clk_mux("system_eclk_mux", REG_CLK_DIV0, 3, 2, system_sel_clks, ARRAY_SIZE(system_sel_clks));
+	clk[system_eclk_div] = nuc970_clk_divider("system_eclk_div", "system_eclk_mux", REG_CLK_DIV0, 8, 4);
+	
+	// -GPIO
+	clk[gpio_eclk_mux]  = nuc970_clk_mux("gpio_eclk_mux", REG_CLK_DIV7, 7, 1, gpio_sel_clks, ARRAY_SIZE(gpio_sel_clks));
+	clk[gpio_eclk_div]  = nuc970_clk_divider("gpio_eclk_div", "gpio_eclk_mux", REG_CLK_DIV7, 0, 7);
+	clk[gpio_eclk_gate] = nuc970_clk_gate("gpio_eclk_gate", "gpio_eclk_div", REG_CLK_PCLKEN0, 3);
+	
+	// -KPI
+	clk[kpi_eclk_mux]  = nuc970_clk_mux("kpi_eclk_mux", REG_CLK_DIV7, 15, 1, kpi_sel_clks, ARRAY_SIZE(kpi_sel_clks));
+	clk[kpi_eclk_div]  = nuc970_clk_divider("kpi_eclk_div", "kpi_eclk_mux", REG_CLK_DIV7, 8, 7);
+	clk[kpi_eclk_gate] = nuc970_clk_gate("kpi_eclk_gate", "kpi_eclk_div", REG_CLK_PCLKEN1, 25);
+	
+	// -ETIMER0
+	clk[etimer0_eclk_mux] = nuc970_clk_mux("etimer0_eclk_mux", REG_CLK_DIV8, 16, 2, etimer_sel_clks, ARRAY_SIZE(etimer_sel_clks));
+	clk[etimer0_eclk_gate]  = nuc970_clk_gate("etimer0_eclk_gate", "etimer0_eclk_mux", REG_CLK_PCLKEN0, 4);
+	
+	// -ETIMER1
+	clk[etimer1_eclk_mux] = nuc970_clk_mux("etimer1_eclk_mux", REG_CLK_DIV8, 20, 2, etimer_sel_clks, ARRAY_SIZE(etimer_sel_clks));
+	clk[etimer1_eclk_gate]  = nuc970_clk_gate("etimer1_eclk_gate", "etimer1_eclk_mux", REG_CLK_PCLKEN0, 5);
+	
+	// -ETIMER2
+	clk[etimer2_eclk_mux] = nuc970_clk_mux("etimer2_eclk_mux", REG_CLK_DIV8, 24, 2, etimer_sel_clks, ARRAY_SIZE(etimer_sel_clks));
+	clk[etimer2_eclk_gate]  = nuc970_clk_gate("etimer2_eclk_gate", "etimer2_eclk_mux", REG_CLK_PCLKEN0, 6);
+	
+	// -ETIMER3
+	clk[etimer3_eclk_mux] = nuc970_clk_mux("etimer3_eclk_mux", REG_CLK_DIV8, 28, 2, etimer_sel_clks, ARRAY_SIZE(etimer_sel_clks));
+	clk[etimer3_eclk_gate]  = nuc970_clk_gate("etimer3_eclk_gate", "etimer3_eclk_mux", REG_CLK_PCLKEN0, 7);
+	
+	// -WWDT
+	clk[wwdt_eclk_mux] = nuc970_clk_mux("wwdt_eclk_mux", REG_CLK_DIV8, 10, 2, wwdt_sel_clks, ARRAY_SIZE(wwdt_sel_clks));
+	clk[wwdt_eclk_gate]  = nuc970_clk_gate("wwdt_eclk_gate", "wwdt_eclk_mux", REG_CLK_PCLKEN0, 1);
+	
+	// -WDT
+	clk[wdt_eclk_mux] = nuc970_clk_mux("wdt_eclk_mux", REG_CLK_DIV8, 8, 2, wwdt_sel_clks, ARRAY_SIZE(wwdt_sel_clks));
+	clk[wdt_eclk_gate]  = nuc970_clk_gate("wdt_eclk_gate", "wdt_eclk_mux", REG_CLK_PCLKEN0, 0);
+	
+	// -SMARTCARD
+	clk[smc0_eclk_div]  = nuc970_clk_divider("smc0_eclk_div", "xin", REG_CLK_DIV6, 24, 4);
+	clk[smc0_eclk_gate] = nuc970_clk_gate("smc0_eclk_gate", "smc0_eclk_div", REG_CLK_PCLKEN1, 12);
+		
+	clk[smc1_eclk_div]  = nuc970_clk_divider("smc1_eclk_div", "xin", REG_CLK_DIV6, 28, 4);
+	clk[smc1_eclk_gate] = nuc970_clk_gate("smc1_eclk_gate", "smc1_eclk_div", REG_CLK_PCLKEN1, 13);
+	
+	// PCLK
+	clk[pclk_div]	= nuc970_clk_divider("pclk_div", "hclk1_div", REG_CLK_DIV0, 24, 4);
+	clk[pclk4096_div]  = nuc970_clk_fixed_factor("pclk4096_div", "pclk_div", 1, 4096);		//  pclk/4096
+	clk[i2c0_gate]  = nuc970_clk_gate("i2c0_gate", "pclk_div", REG_CLK_PCLKEN1, 0);
+	clk[i2c1_gate]  = nuc970_clk_gate("i2c1_gate", "pclk_div", REG_CLK_PCLKEN1, 1);
+	
+	clk[spi0_gate]  = nuc970_clk_gate("spi0_gate", "pclk_div", REG_CLK_PCLKEN1, 4);
+	clk[spi1_gate]  = nuc970_clk_gate("spi1_gate", "pclk_div", REG_CLK_PCLKEN1, 5);
+	
+	clk[uart0_gate] = nuc970_clk_gate("uart0_gate", "pclk_div", REG_CLK_PCLKEN0, 16);
+	clk[uart1_gate] = nuc970_clk_gate("uart1_gate", "pclk_div", REG_CLK_PCLKEN0, 17);
+	clk[uart2_gate] = nuc970_clk_gate("uart2_gate", "pclk_div", REG_CLK_PCLKEN0, 18);
+	clk[uart3_gate] = nuc970_clk_gate("uart3_gate", "pclk_div", REG_CLK_PCLKEN0, 19);
+	clk[uart4_gate] = nuc970_clk_gate("uart4_gate", "pclk_div", REG_CLK_PCLKEN0, 20);
+	clk[uart5_gate] = nuc970_clk_gate("uart5_gate", "pclk_div", REG_CLK_PCLKEN0, 21);
+	clk[uart6_gate] = nuc970_clk_gate("uart6_gate", "pclk_div", REG_CLK_PCLKEN0, 22);
+	clk[uart7_gate] = nuc970_clk_gate("uart7_gate", "pclk_div", REG_CLK_PCLKEN0, 23);
+	clk[uart8_gate] = nuc970_clk_gate("uart8_gate", "pclk_div", REG_CLK_PCLKEN0, 24);
+	clk[uart9_gate] = nuc970_clk_gate("uart9_gate", "pclk_div", REG_CLK_PCLKEN0, 25);
+	clk[uart10_gate] = nuc970_clk_gate("uart10_gate", "pclk_div", REG_CLK_PCLKEN0, 26);
+	
+	clk[wdt_gate] = nuc970_clk_gate("wdt_gate", "pclk_div", REG_CLK_PCLKEN0, 0);
+	clk[wwdt_gate] = nuc970_clk_gate("wwdt_gate", "pclk_div", REG_CLK_PCLKEN0, 1);
+	
+	clk[rtc_gate] = nuc970_clk_gate("rtc_gate", "pclk_div", REG_CLK_PCLKEN0, 2);
+	
+	clk[gpio_gate] = nuc970_clk_gate("gpio_gate", "pclk_div", REG_CLK_PCLKEN0, 3);
+	
+	clk[adc_gate] = nuc970_clk_gate("adc_gate", "pclk_div", REG_CLK_PCLKEN1, 24);
+	
+	clk[kpi_gate] = nuc970_clk_gate("kpi_gate", "pclk_div", REG_CLK_PCLKEN1, 25);
+	
+	clk[mtpc_gate] = nuc970_clk_gate("mtpc_gate", "pclk_div", REG_CLK_PCLKEN1, 26);
+	
+	clk[pwm_gate] = nuc970_clk_gate("pwm_gate", "pclk_div", REG_CLK_PCLKEN1, 27);
+	
+	clk[etimer0_gate] = nuc970_clk_gate("etimer0_gate", "pclk_div", REG_CLK_PCLKEN0, 4);
+	clk[etimer1_gate] = nuc970_clk_gate("etimer1_gate", "pclk_div", REG_CLK_PCLKEN0, 5);
+	clk[etimer2_gate] = nuc970_clk_gate("etimer2_gate", "pclk_div", REG_CLK_PCLKEN0, 6);
+	clk[etimer3_gate] = nuc970_clk_gate("etimer3_gate", "pclk_div", REG_CLK_PCLKEN0, 7);
+	
+	clk[can0_gate] = nuc970_clk_gate("can0_gate", "pclk_div", REG_CLK_PCLKEN1, 8);
+	clk[can1_gate] = nuc970_clk_gate("can1_gate", "pclk_div", REG_CLK_PCLKEN1, 9);
+
+	clk[timer0_gate] = nuc970_clk_gate("timer0_gate", "xin", REG_CLK_PCLKEN0, 8);
+	clk[timer1_gate] = nuc970_clk_gate("timer1_gate", "xin", REG_CLK_PCLKEN0, 9);
+	clk[timer2_gate] = nuc970_clk_gate("timer2_gate", "xin", REG_CLK_PCLKEN0, 10);
+	clk[timer3_gate] = nuc970_clk_gate("timer3_gate", "xin", REG_CLK_PCLKEN0, 11);
+	clk[timer4_gate] = nuc970_clk_gate("timer4_gate", "xin", REG_CLK_PCLKEN0, 12);	
+	
+	clk[smc0_gate] = nuc970_clk_gate("smc0_gate", "pclk_div", REG_CLK_PCLKEN1, 12);
+	clk[smc1_gate] = nuc970_clk_gate("smc1_gate", "pclk_div", REG_CLK_PCLKEN1, 13);
+	
+	for (i = 0; i < ARRAY_SIZE(clk); i++)
+		if (IS_ERR(clk[i]))
+			pr_err("nuc970 clk %d: register failed with %ld\n",
+				i, PTR_ERR(clk[i]));
+	
+	
+	// register clock device	
+	clk_register_clkdev(clk[timer0_gate], "timer0", NULL);		// limitation of name size is xxxxxxxxxxxxxxxx
+	clk_register_clkdev(clk[timer1_gate], "timer1", NULL);	
+	
+	clk_register_clkdev(clk[pclk4096_div], "pclk4096_div", NULL);
+	
+	clk_register_clkdev(clk[xin], "xin", NULL);
+	clk_register_clkdev(clk[xin32k], "xin32k", NULL);
+	clk_register_clkdev(clk[apll], "apll", NULL);
+	clk_register_clkdev(clk[upll], "upll", NULL);
+	
+	clk_register_clkdev(clk[sys_mux], "sysmux", NULL);
+	clk_register_clkdev(clk[sys_div], "sysdiv", NULL);
+	
+	clk_register_clkdev(clk[xin128_div], "xin128div", NULL);
+	
+	// CPU
+	clk_register_clkdev(clk[cpu_div], "cpudiv", NULL);
+	clk_register_clkdev(clk[cpu_gate], "cpu", NULL);
+
+	// HCLK1
+	clk_register_clkdev(clk[hclk_gate], "hclk", NULL);
+	clk_register_clkdev(clk[sram_gate], "sram", NULL);
+	clk_register_clkdev(clk[hclk1_div], "hclk1div", NULL);
+	clk_register_clkdev(clk[ddr_gate], "ddr_hclk", NULL);
+	clk_register_clkdev(clk[gdma_gate], "gdma_hclk", NULL);
+	clk_register_clkdev(clk[ebi_gate], "ebi_hclk", NULL);
+	clk_register_clkdev(clk[tic_gate], "tic_hclk", NULL);
+	
+	// HCLK234
+	clk_register_clkdev(clk[hclkn_div], "hclkndiv", NULL);
+	clk_register_clkdev(clk[dram_gate], "dram", NULL);
+	clk_register_clkdev(clk[hclk234_div], "hclk234div", NULL);
+		
+	//HCLK3
+	clk_register_clkdev(clk[usbh_gate], "usbh_hclk", NULL);
+	clk_register_clkdev(clk[emac1_gate], "emac1_hclk", NULL);
+	clk_register_clkdev(clk[emac1_eclk_div], "emac1_eclk_div", NULL);
+	clk_register_clkdev(clk[emac1_eclk_gate], "emac1_eclk", NULL);
+	clk_register_clkdev(clk[usbd_gate], "usbd_hclk", NULL);
+	clk_register_clkdev(clk[fmi_gate], "fmi_hclk", NULL);
+	clk_register_clkdev(clk[nand_gate], "nand_hclk", NULL);
+    clk_register_clkdev(clk[emmc_gate], "emmc_hclk", NULL);
+	clk_register_clkdev(clk[crypto_gate], "crypto_hclk", NULL);
+	clk_register_clkdev(clk[jpeg_gate], "jpeg_hclk", NULL);
+	clk_register_clkdev(clk[jpeg_eclk_div], "jpeg_eclk_div", NULL);
+	clk_register_clkdev(clk[jpeg_eclk_gate], "jpeg_eclk", NULL);
+    clk_register_clkdev(clk[ge2d_gate], "ge2d_hclk", NULL);
+	clk_register_clkdev(clk[ge2d_eclk_div], "ge2d_eclk_div", NULL);
+	clk_register_clkdev(clk[ge2d_eclk_gate], "ge2d_eclk", NULL);
+	
+	//HCLK4
+	clk_register_clkdev(clk[emac0_gate], "emac0_hclk", NULL);
+	clk_register_clkdev(clk[emac0_eclk_div], "emac0_eclk_div", NULL);
+	clk_register_clkdev(clk[emac0_eclk_gate], "emac0_eclk", NULL);
+	clk_register_clkdev(clk[sdh_gate], "sdh_hclk", NULL);
+	clk_register_clkdev(clk[audio_gate], "audio_hclk", NULL);
+	clk_register_clkdev(clk[lcd_gate], "lcd_hclk", NULL);
+	clk_register_clkdev(clk[sensor_gate], "sensor_hclk", NULL);
+	clk_register_clkdev(clk[cap_gate], "cap_hclk", NULL);
+	
+	// ECLK
+	clk_register_clkdev(clk[lcd_aplldiv], "lcd_aplldiv", NULL);
+	clk_register_clkdev(clk[lcd_uplldiv], "lcd_uplldiv", NULL);
+	clk_register_clkdev(clk[lcd_eclk_mux], "lcd_eclk_mux", NULL);
+	clk_register_clkdev(clk[lcd_eclk_div], "lcd_eclk_div", NULL);
+	clk_register_clkdev(clk[lcd_eclk_gate], "lcd_eclk", NULL);
+	
+	clk_register_clkdev(clk[audio_aplldiv], "audio_aplldiv", NULL);
+	clk_register_clkdev(clk[audio_uplldiv], "audio_uplldiv", NULL);
+	clk_register_clkdev(clk[audio_eclk_mux], "audio_eclk_mux", NULL);
+	clk_register_clkdev(clk[audio_eclk_div], "audio_eclk_div", NULL);
+	clk_register_clkdev(clk[audio_eclk_gate], "audio_eclk", NULL);
+	
+	clk_register_clkdev(clk[usb_aplldiv], "usb_aplldiv", NULL);
+	clk_register_clkdev(clk[usb_uplldiv], "usb_uplldiv", NULL);
+	clk_register_clkdev(clk[usb_eclk_mux], "usb_eclk_mux", NULL);
+	clk_register_clkdev(clk[usb_eclk_div], "usb_eclk_div", NULL);
+	clk_register_clkdev(clk[usb_eclk_gate], "usb_eclk", NULL);
+	
+	clk_register_clkdev(clk[sdh_aplldiv], "sdh_aplldiv", NULL);
+	clk_register_clkdev(clk[sdh_uplldiv], "sdh_uplldiv", NULL);
+	clk_register_clkdev(clk[sdh_eclk_mux], "sdh_eclk_mux", NULL);
+	clk_register_clkdev(clk[sdh_eclk_div], "sdh_eclk_div", NULL);
+	clk_register_clkdev(clk[sdh_eclk_gate], "sdh_eclk", NULL);
+    
+    clk_register_clkdev(clk[emmc_aplldiv], "emmc_aplldiv", NULL);
+	clk_register_clkdev(clk[emmc_uplldiv], "emmc_uplldiv", NULL);
+	clk_register_clkdev(clk[emmc_eclk_mux], "emmc_eclk_mux", NULL);
+	clk_register_clkdev(clk[emmc_eclk_div], "emmc_eclk_div", NULL);
+	clk_register_clkdev(clk[emmc_eclk_gate], "emmc_eclk", NULL);
+	
+	clk_register_clkdev(clk[adc_aplldiv], "adc_aplldiv", NULL);
+	clk_register_clkdev(clk[adc_uplldiv], "adc_uplldiv", NULL);
+	clk_register_clkdev(clk[adc_eclk_mux], "adc_eclk_mux", NULL);
+	clk_register_clkdev(clk[adc_eclk_div], "adc_eclk_div", NULL);
+	clk_register_clkdev(clk[adc_eclk_gate], "adc_eclk", NULL);
+	
+	clk_register_clkdev(clk[cap_aplldiv], "cap_aplldiv", NULL);
+	clk_register_clkdev(clk[cap_uplldiv], "cap_uplldiv", NULL);
+	clk_register_clkdev(clk[cap_eclk_mux], "cap_eclk_mux", NULL);
+	clk_register_clkdev(clk[cap_eclk_div], "cap_eclk_div", NULL);
+	clk_register_clkdev(clk[cap_eclk_gate], "cap_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart0_aplldiv], "uart0_aplldiv", NULL);
+	clk_register_clkdev(clk[uart0_uplldiv], "uart0_uplldiv", NULL);
+	clk_register_clkdev(clk[uart0_eclk_mux], "uart0_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart0_eclk_div], "uart0_eclk_div", NULL);
+	clk_register_clkdev(clk[uart0_eclk_gate], "uart0_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart1_aplldiv], "uart1_aplldiv", NULL);
+	clk_register_clkdev(clk[uart1_uplldiv], "uart1_uplldiv", NULL);
+	clk_register_clkdev(clk[uart1_eclk_mux], "uart1_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart1_eclk_div], "uart1_eclk_div", NULL);
+	clk_register_clkdev(clk[uart1_eclk_gate], "uart1_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart2_aplldiv], "uart2_aplldiv", NULL);
+	clk_register_clkdev(clk[uart2_uplldiv], "uart2_uplldiv", NULL);
+	clk_register_clkdev(clk[uart2_eclk_mux], "uart2_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart2_eclk_div], "uart2_eclk_div", NULL);
+	clk_register_clkdev(clk[uart2_eclk_gate], "uart2_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart3_aplldiv], "uart3_aplldiv", NULL);
+	clk_register_clkdev(clk[uart3_uplldiv], "uart3_uplldiv", NULL);
+	clk_register_clkdev(clk[uart3_eclk_mux], "uart3_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart3_eclk_div], "uart3_eclk_div", NULL);
+	clk_register_clkdev(clk[uart3_eclk_gate], "uart3_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart4_aplldiv], "uart4_aplldiv", NULL);
+	clk_register_clkdev(clk[uart4_uplldiv], "uart4_uplldiv", NULL);
+	clk_register_clkdev(clk[uart4_eclk_mux], "uart4_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart4_eclk_div], "uart4_eclk_div", NULL);
+	clk_register_clkdev(clk[uart4_eclk_gate], "uart4_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart5_aplldiv], "uart5_aplldiv", NULL);
+	clk_register_clkdev(clk[uart5_uplldiv], "uart5_uplldiv", NULL);
+	clk_register_clkdev(clk[uart5_eclk_mux], "uart5_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart5_eclk_div], "uart5_eclk_div", NULL);
+	clk_register_clkdev(clk[uart5_eclk_gate], "uart5_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart6_aplldiv], "uart6_aplldiv", NULL);
+	clk_register_clkdev(clk[uart6_uplldiv], "uart6_uplldiv", NULL);
+	clk_register_clkdev(clk[uart6_eclk_mux], "uart6_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart6_eclk_div], "uart6_eclk_div", NULL);
+	clk_register_clkdev(clk[uart6_eclk_gate], "uart6_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart7_aplldiv], "uart7_aplldiv", NULL);
+	clk_register_clkdev(clk[uart7_uplldiv], "uart7_uplldiv", NULL);
+	clk_register_clkdev(clk[uart7_eclk_mux], "uart7_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart7_eclk_div], "uart7_eclk_div", NULL);
+	clk_register_clkdev(clk[uart7_eclk_gate], "uart7_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart8_aplldiv], "uart8_aplldiv", NULL);
+	clk_register_clkdev(clk[uart8_uplldiv], "uart8_uplldiv", NULL);
+	clk_register_clkdev(clk[uart8_eclk_mux], "uart8_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart8_eclk_div], "uart8_eclk_div", NULL);
+	clk_register_clkdev(clk[uart8_eclk_gate], "uart8_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart9_aplldiv], "uart9_aplldiv", NULL);
+	clk_register_clkdev(clk[uart9_uplldiv], "uart9_uplldiv", NULL);
+	clk_register_clkdev(clk[uart9_eclk_mux], "uart9_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart9_eclk_div], "uart9_eclk_div", NULL);
+	clk_register_clkdev(clk[uart9_eclk_gate], "uart9_eclk", NULL);
+	
+	clk_register_clkdev(clk[uart10_aplldiv], "uart10_aplldiv", NULL);
+	clk_register_clkdev(clk[uart10_uplldiv], "uart10_uplldiv", NULL);
+	clk_register_clkdev(clk[uart10_eclk_mux], "uart10_eclk_mux", NULL);
+	clk_register_clkdev(clk[uart10_eclk_div], "uart10_eclk_div", NULL);
+	clk_register_clkdev(clk[uart10_eclk_gate], "uart10_eclk", NULL);
+	
+	clk_register_clkdev(clk[system_aplldiv], "system_aplldiv", NULL);
+	clk_register_clkdev(clk[system_uplldiv], "system_uplldiv", NULL);
+	clk_register_clkdev(clk[system_eclk_mux], "system_eclk_mux", NULL);
+	clk_register_clkdev(clk[system_eclk_div], "system_eclk_div", NULL);
+	clk_register_clkdev(clk[system_eclk_gate], "system_eclk", NULL);
+	
+	clk_register_clkdev(clk[gpio_eclk_mux], "gpio_eclk_mux", NULL);
+	clk_register_clkdev(clk[gpio_eclk_div], "gpio_eclk_div", NULL);
+	clk_register_clkdev(clk[gpio_eclk_gate], "gpio_eclk", NULL);
+	
+	clk_register_clkdev(clk[kpi_eclk_mux], "kpi_eclk_mux", NULL);
+	clk_register_clkdev(clk[kpi_eclk_div], "kpi_eclk_div", NULL);
+	clk_register_clkdev(clk[kpi_eclk_gate], "kpi_eclk", NULL);
+	
+	clk_register_clkdev(clk[etimer0_eclk_mux], "etmr0_eclk_mux", NULL);
+	clk_register_clkdev(clk[etimer0_eclk_gate], "etmr0_eclk", NULL);
+	clk_register_clkdev(clk[etimer1_eclk_mux], "etmr1_eclk_mux", NULL);
+	clk_register_clkdev(clk[etimer1_eclk_gate], "etmr1_eclk", NULL);
+	clk_register_clkdev(clk[etimer2_eclk_mux], "etmr2_eclk_mux", NULL);
+	clk_register_clkdev(clk[etimer2_eclk_gate], "etmr2_eclk", NULL);
+	clk_register_clkdev(clk[etimer3_eclk_mux], "etmr3_eclk_mux", NULL);
+	clk_register_clkdev(clk[etimer3_eclk_gate], "etmr3_eclk", NULL);
+	
+	clk_register_clkdev(clk[wwdt_eclk_mux], "wwdt_eclk_mux", NULL);
+	clk_register_clkdev(clk[wwdt_eclk_gate], "wwdt_eclk", NULL);
+	clk_register_clkdev(clk[wdt_eclk_mux], "wdt_eclk_mux", NULL);
+	clk_register_clkdev(clk[wdt_eclk_gate], "wdt_eclk", NULL);
+	
+	clk_register_clkdev(clk[smc0_eclk_div], "smc0_eclk_div", NULL);
+	clk_register_clkdev(clk[smc0_eclk_gate], "smc0_eclk", NULL);
+	clk_register_clkdev(clk[smc1_eclk_div], "smc1_eclk_div", NULL);
+	clk_register_clkdev(clk[smc1_eclk_gate], "smc1_eclk", NULL);
+
+	//PCLK	
+	clk_register_clkdev(clk[pclk_div], "pclkdiv", NULL);
+	clk_register_clkdev(clk[rtc_gate], "rtc", NULL);
+	clk_register_clkdev(clk[i2c0_gate], "i2c0", NULL);
+	clk_register_clkdev(clk[i2c1_gate], "i2c1", NULL);
+	clk_register_clkdev(clk[spi0_gate], "spi0", NULL);
+	clk_register_clkdev(clk[spi1_gate], "spi1", NULL);
+	clk_register_clkdev(clk[uart0_gate], "uart0", NULL);
+	clk_register_clkdev(clk[uart1_gate], "uart1", NULL);
+	clk_register_clkdev(clk[uart2_gate], "uart2", NULL);
+	clk_register_clkdev(clk[uart3_gate], "uart3", NULL);
+	clk_register_clkdev(clk[uart4_gate], "uart4", NULL);
+	clk_register_clkdev(clk[uart5_gate], "uart5", NULL);
+	clk_register_clkdev(clk[uart6_gate], "uart6", NULL);
+	clk_register_clkdev(clk[uart7_gate], "uart7", NULL);
+	clk_register_clkdev(clk[uart8_gate], "uart8", NULL);
+	clk_register_clkdev(clk[uart9_gate], "uart9", NULL);
+	clk_register_clkdev(clk[uart10_gate], "uart10", NULL);
+	clk_register_clkdev(clk[wdt_gate], "wdt", NULL);
+	clk_register_clkdev(clk[wwdt_gate], "wwdt", NULL);
+	clk_register_clkdev(clk[gpio_gate], "gpio", NULL);
+	clk_register_clkdev(clk[smc0_gate], "smc0", NULL);
+	clk_register_clkdev(clk[smc1_gate], "smc1", NULL);
+	clk_register_clkdev(clk[adc_gate], "adc", NULL);
+	clk_register_clkdev(clk[kpi_gate], "kpi", NULL);
+	clk_register_clkdev(clk[mtpc_gate], "mtpc", NULL);
+	clk_register_clkdev(clk[pwm_gate], "pwm", NULL);
+	clk_register_clkdev(clk[etimer0_gate], "etimer0", NULL);
+	clk_register_clkdev(clk[etimer1_gate], "etimer1", NULL);
+	clk_register_clkdev(clk[etimer2_gate], "etimer2", NULL);
+	clk_register_clkdev(clk[etimer3_gate], "etimer3", NULL);
+	clk_register_clkdev(clk[timer2_gate], "timer2", NULL);
+	clk_register_clkdev(clk[timer3_gate], "timer3", NULL);
+	clk_register_clkdev(clk[timer4_gate], "timer4", NULL);
+	clk_register_clkdev(clk[can0_gate], "can0", NULL);
+	clk_register_clkdev(clk[can1_gate], "can1", NULL);
+	
+	// enable some important clocks
+	clk_prepare(clk_get(NULL, "cpu"));
+	clk_enable(clk_get(NULL, "cpu"));
+	
+	clk_prepare(clk_get(NULL, "hclk"));
+	clk_enable(clk_get(NULL, "hclk"));
+	
+	clk_prepare(clk_get(NULL, "sram"));
+	clk_enable(clk_get(NULL, "sram"));
+	
+	clk_prepare(clk_get(NULL, "dram"));
+	clk_enable(clk_get(NULL, "dram"));
+	
+	clk_prepare(clk_get(NULL, "ddr_hclk"));
+	clk_enable(clk_get(NULL, "ddr_hclk"));		
+	
+
+	return 0;
+}
Index: linux-4.4.92/arch/arm/mach-nuc970/clk-ccf.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/clk-ccf.h
@@ -0,0 +1,47 @@
+#ifndef __MACH_NUC970_CLK_H
+#define __MACH_NUC970_CLK_H
+
+#include <linux/spinlock.h>
+#include <linux/clk-provider.h>
+
+extern struct clk *nuc970_clk_apll(const char *name, const char *parent,
+		void __iomem *base);
+extern struct clk *nuc970_clk_upll(const char *name, const char *parent,
+		void __iomem *base);		
+		
+extern spinlock_t nuc970_lock;
+
+static inline struct clk *nuc970_clk_fixed(const char *name, int rate)
+{
+	return clk_register_fixed_rate(NULL, name, NULL, CLK_IS_ROOT, rate);
+}
+
+static inline struct clk *nuc970_clk_mux(const char *name, void __iomem *reg,
+		u8 shift, u8 width, const char **parents, int num_parents)
+{
+	return clk_register_mux(NULL, name, parents, num_parents, 0, reg, shift,
+			width, 0, &nuc970_lock);
+}
+
+static inline struct clk *nuc970_clk_divider(const char *name, const char *parent,
+		void __iomem *reg, u8 shift, u8 width)
+{
+	return clk_register_divider(NULL, name, parent, 0,
+			reg, shift, width, 0, &nuc970_lock);
+}
+
+static inline struct clk *nuc970_clk_fixed_factor(const char *name,
+		const char *parent, unsigned int mult, unsigned int div)
+{
+	return clk_register_fixed_factor(NULL, name, parent,
+			CLK_SET_RATE_PARENT, mult, div);
+}
+
+static inline struct clk *nuc970_clk_gate(const char *name, const char *parent,
+		void __iomem *reg, u8 shift)
+{
+	return clk_register_gate(NULL, name, parent, CLK_SET_RATE_PARENT, reg,
+			shift, 0, &nuc970_lock);
+}
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/clk-upll.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/clk-upll.c
@@ -0,0 +1,99 @@
+/*
+ * linux/arch/arm/mach-nuc970/clk-upll.c
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+ 
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+
+#include "clk-ccf.h"
+
+/**
+ * upll 
+ *
+ * @clk_hw	clock source
+ * @parent	the parent clock name
+ * @base	base address of pll registers
+ *
+ */
+struct clk_upll {
+	struct clk_hw	hw;
+	void __iomem	*base;
+};
+
+#define to_clk_upll(clk) (container_of(clk, struct clk_upll, clk))
+
+static unsigned long clk_upll_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	struct clk_upll *pll = to_clk_upll(hw);
+	long long ll;
+	u32 reg = readl(pll->base) & 0x0FFFFFFF;
+	
+	if(parent_rate != 12000000)
+		return 0;
+	
+	switch(reg)
+	{
+		case 0x15:
+			ll = 264000000;
+			break;
+		
+		case 0x18:
+			ll = 300000000;
+			break;
+		
+		default:
+			ll = 264000000;
+			break;
+	}
+
+	return ll;
+}
+
+static struct clk_ops clk_upll_ops = {
+	.recalc_rate = clk_upll_recalc_rate,
+};
+
+struct clk *nuc970_clk_upll(const char *name, const char *parent,
+		void __iomem *base)
+{
+	struct clk_upll *pll;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	pll = kmalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+
+	pll->base = base;
+
+	init.name = name;
+	init.ops = &clk_upll_ops;
+	init.flags = 0;
+	init.parent_names = &parent;
+	init.num_parents = 1;
+
+	pll->hw.init = &init;
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk))
+		kfree(pll);
+
+	return clk;
+}
Index: linux-4.4.92/arch/arm/mach-nuc970/clock.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/clock.c
@@ -0,0 +1,295 @@
+/*
+ * linux/arch/arm/mach-nuc970/clock.c
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/clkdev.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-clock.h>
+#include "clock.h"
+
+// TODO: select IP clock source and set rate
+
+void nuc970_hclken(struct clk *clk, int enable);
+void nuc970_pclk0en(struct clk *clk, int enable);
+void nuc970_pclk1en(struct clk *clk, int enable);
+unsigned int nuc970_get_apll(void);
+unsigned int nuc970_get_upll(void);
+unsigned int nuc970_get_hclk(void);
+unsigned int nuc970_get_hclk234(void);
+unsigned int nuc970_get_pclk(void);
+
+static DEFINE_SPINLOCK(clk_lock);
+
+/* Initial clock declarations. */
+struct clk clk_sram = 	{(1 << 8), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_ebi = 	{(1 << 9), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_gdma = 	{(1 << 12), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_cko = 	{(1 << 15), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_emac0 = 	{(1 << 16), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_emac1 = 	{(1 << 17), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_usbh = 	{(1 << 18), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_usbd = 	{(1 << 19), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_fmi = 	{(1 << 20), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_nand = 	{(1 << 21), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_emmc = 	{(1 << 22), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_crypto = {(1 << 23), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_i2s = 	{(1 << 24), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_lcd = 	{(1 << 25), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_vcap = 	{(1 << 26), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_sensor = {(1 << 27), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_ge = 	{(1 << 28), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_jpeg = 	{(1 << 29), 0, 0, nuc970_hclken, NULL, NULL};
+struct clk clk_sdh = 	{(1 << 30), 0, 0, nuc970_hclken, NULL, NULL};
+
+struct clk clk_wdt = 	{(1 << 0), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_wwdt = 	{(1 << 1), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_rtc = 	{(1 << 2), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_gpio = 	{(1 << 3), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_etimer0 = {(1 << 4), 0, 0 , nuc970_pclk0en, NULL, NULL};
+struct clk clk_etimer1 = {(1 << 5), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_etimer2 = {(1 << 6), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_etimer3 = {(1 << 7), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_timer0 = {(1 << 8), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_timer1 = {(1 << 9), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_timer2 = {(1 << 10), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_timer3 = {(1 << 11), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_timer4 = {(1 << 12), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart0 = 	{(1 << 16), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart1 = 	{(1 << 17), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart2 = 	{(1 << 18), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart3 = 	{(1 << 19), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart4 = 	{(1 << 20), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart5 = 	{(1 << 21), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart6 = 	{(1 << 22), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart7 = 	{(1 << 23), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart8 = 	{(1 << 24), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart9 = 	{(1 << 25), 0, 0, nuc970_pclk0en, NULL, NULL};
+struct clk clk_uart10 = {(1 << 26), 0, 0, nuc970_pclk0en, NULL, NULL};
+
+
+struct clk clk_i2c0 = 	{(1 << 0), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_i2c1 = 	{(1 << 1), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_spi0 = 	{(1 << 4), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_spi1 = 	{(1 << 5), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_can0 = 	{(1 << 8), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_can1 = 	{(1 << 9), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_sc0 = 	{(1 << 12), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_sc1 = 	{(1 << 13), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_adc = 	{(1 << 24), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_kpi = 	{(1 << 25), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_mtp = 	{(1 << 26), 0, 0, nuc970_pclk1en, NULL, NULL};
+struct clk clk_pwm = 	{(1 << 27), 0, 0, nuc970_pclk1en, NULL, NULL};
+
+
+
+
+static struct clk_lookup nuc970_clkregs[] = {
+	// AHB
+	DEF_CLKLOOK(&clk_sram, "nuc970-sram", NULL),
+	DEF_CLKLOOK(&clk_ebi, "nuc970-ebi", NULL),
+	DEF_CLKLOOK(&clk_gdma, "nuc970-gdma", NULL),
+	DEF_CLKLOOK(&clk_cko, "nuc97-cko", NULL),
+	DEF_CLKLOOK(&clk_emac0, "nuc970-emac0", NULL),
+	DEF_CLKLOOK(&clk_emac1, "nuc970-emac1", NULL),
+	DEF_CLKLOOK(&clk_usbh, "nuc970-ohci", NULL),
+	DEF_CLKLOOK(&clk_usbh, "nuc970-ehci", NULL),
+	DEF_CLKLOOK(&clk_usbd, "nuc970-usbdev", NULL),
+	DEF_CLKLOOK(&clk_fmi, "nuc970-fmi", NULL),
+	DEF_CLKLOOK(&clk_nand, NULL, "nand"),
+	DEF_CLKLOOK(&clk_emmc, NULL, "emmc"),
+	DEF_CLKLOOK(&clk_crypto, "nuc970-crypto", NULL),
+	DEF_CLKLOOK(&clk_i2s, "nuc970-actl", NULL),
+	DEF_CLKLOOK(&clk_lcd, "nuc970-lcd", NULL),
+	DEF_CLKLOOK(&clk_vcap, "nuc970-vcap", NULL),
+	DEF_CLKLOOK(&clk_sensor, "nuc970-sensor", NULL),
+	DEF_CLKLOOK(&clk_ge, "nuc970-ge", NULL),
+	DEF_CLKLOOK(&clk_jpeg, "nuc970-jpeg", NULL),
+	DEF_CLKLOOK(&clk_sdh, "nuc970-sdh", NULL),
+	// APB
+	DEF_CLKLOOK(&clk_wdt, "nuc970-wdt", NULL),
+	DEF_CLKLOOK(&clk_wwdt, "nuc970-wwdt", NULL),
+	DEF_CLKLOOK(&clk_rtc, "nuc970-rtc", NULL),
+	DEF_CLKLOOK(&clk_gpio, "nuc970-gpio", NULL),
+	DEF_CLKLOOK(&clk_etimer0, "nuc970-etimer0", NULL),
+	DEF_CLKLOOK(&clk_etimer1, "nuc970-etimer1", NULL),
+	DEF_CLKLOOK(&clk_etimer2, "nuc970-etimer2", NULL),
+	DEF_CLKLOOK(&clk_etimer3, "nuc970-etimer3", NULL),
+
+	DEF_CLKLOOK(&clk_timer0, NULL, "nuc970-timer0"),	//cc
+	DEF_CLKLOOK(&clk_timer1, NULL, "nuc970-timer1"),	//cc
+	DEF_CLKLOOK(&clk_timer2, "nuc970-timer2", NULL),
+	DEF_CLKLOOK(&clk_timer3, "nuc970-timer3", NULL),
+
+	DEF_CLKLOOK(&clk_uart0, NULL, "nuc970-uart0"),		//cc
+	DEF_CLKLOOK(&clk_uart1, "nuc970-uart1", NULL),
+	DEF_CLKLOOK(&clk_uart2, "nuc970-uart2", NULL),
+	DEF_CLKLOOK(&clk_uart3, "nuc970-uart3", NULL),
+	DEF_CLKLOOK(&clk_uart4, "nuc970-uart4", NULL),
+	DEF_CLKLOOK(&clk_uart5, "nuc970-uart5", NULL),
+	DEF_CLKLOOK(&clk_uart6, "nuc970-uart6", NULL),
+	DEF_CLKLOOK(&clk_uart7, "nuc970-uart7", NULL),
+	DEF_CLKLOOK(&clk_uart8, "nuc970-uart8", NULL),
+	DEF_CLKLOOK(&clk_uart9, "nuc970-uart9", NULL),
+	DEF_CLKLOOK(&clk_uart10, "nuc970-uart10", NULL),
+
+	DEF_CLKLOOK(&clk_i2c0, "nuc970-i2c0", NULL),
+	DEF_CLKLOOK(&clk_i2c1, "nuc970-i2c1", NULL),
+	DEF_CLKLOOK(&clk_spi0, "nuc970-spi0", NULL),
+	DEF_CLKLOOK(&clk_spi1, "nuc970-spi1", NULL),
+	DEF_CLKLOOK(&clk_can0, "nuc970-can0", NULL),
+	DEF_CLKLOOK(&clk_can1, "nuc970-can1", NULL),
+	DEF_CLKLOOK(&clk_sc0, "nuc970-sc0", NULL),
+	DEF_CLKLOOK(&clk_sc1, "nuc970-sc1", NULL),
+//	DEF_CLKLOOK(&clk_adc, "nuc970-uart0", NULL),	//cc
+//	DEF_CLKLOOK(&clk_kpi, "nuc970-uart0", NULL),	//cc
+	DEF_CLKLOOK(&clk_adc, "nuc970-adc", NULL),
+	DEF_CLKLOOK(&clk_kpi, "nuc970-kpi", NULL),
+	DEF_CLKLOOK(&clk_mtp, "nuc970-mtp", NULL),
+	DEF_CLKLOOK(&clk_pwm, "nuc970-pwm", NULL),
+};
+
+int clk_enable(struct clk *clk)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&clk_lock, flags);
+	if(clk->count++ == 0)
+		clk->control(clk, 1);
+	spin_unlock_irqrestore(&clk_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&clk_lock, flags);
+	if(--clk->count == 0)
+		clk->control(clk, 0);
+	spin_unlock_irqrestore(&clk_lock, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&clk_lock, flags);
+
+	spin_unlock_irqrestore(&clk_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&clk_lock, flags);
+
+	spin_unlock_irqrestore(&clk_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_set_rate);
+#if 0
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+
+	return NULL;
+}
+EXPORT_SYMBOL(clk_get_parent);
+#endif
+void nuc970_hclken(struct clk *clk, int enable)
+{
+	if(enable)
+		__raw_writel(clk->ctlbit | __raw_readl(REG_CLK_HCLKEN), REG_CLK_HCLKEN);
+	else
+		__raw_writel(~clk->ctlbit & __raw_readl(REG_CLK_HCLKEN), REG_CLK_HCLKEN);
+
+	return;
+}
+
+void nuc970_pclk0en(struct clk *clk, int enable)
+{
+	if(enable)
+		__raw_writel(clk->ctlbit | __raw_readl(REG_CLK_PCLKEN0), REG_CLK_PCLKEN0);
+	else
+		__raw_writel(~clk->ctlbit & __raw_readl(REG_CLK_PCLKEN0), REG_CLK_PCLKEN0);
+	return;
+}
+
+
+void nuc970_pclk1en(struct clk *clk, int enable)
+{
+	if(enable)
+		__raw_writel(clk->ctlbit | __raw_readl(REG_CLK_PCLKEN1), REG_CLK_PCLKEN1);
+	else
+		__raw_writel(~clk->ctlbit & __raw_readl(REG_CLK_PCLKEN1), REG_CLK_PCLKEN1);
+	return;
+}
+
+unsigned int nuc970_get_apll(void)
+{
+
+
+	return 0;
+}
+
+unsigned int nuc970_get_upll(void)
+{
+
+
+	return 0;
+}
+
+unsigned int nuc970_get_hclk(void)
+{
+	return 0;
+}
+
+
+unsigned int nuc970_get_hclk234(void)
+{
+	return 0;
+}
+
+unsigned int nuc970_get_pclk(void)
+{
+	return 0;
+}
+
+
+void __init nuc970_init_clocks(void)
+{
+        clkdev_add_table(nuc970_clkregs, ARRAY_SIZE(nuc970_clkregs));
+}
+
+
Index: linux-4.4.92/arch/arm/mach-nuc970/clock.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/clock.h
@@ -0,0 +1,35 @@
+/*
+ * linux/arch/arm/mach-nuc970/clock.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <asm/clkdev.h>
+
+struct clk {
+	unsigned int	ctlbit;
+	unsigned int	count;
+	unsigned int	src;	/* available clock source */
+	void		(*control)(struct clk *clk, int enable);
+	u32		(*set_rate)(struct clk *clk, unsigned int src, unsigned int rate);
+	u32		(*get_rate)(struct clk *clk);
+};
+
+
+#define DEF_CLKLOOK(_clk, _devname, _conname)		\
+	{						\
+		.clk		= _clk,			\
+		.dev_id		= _devname,		\
+		.con_id		= _conname,		\
+	}
+
Index: linux-4.4.92/arch/arm/mach-nuc970/cpu.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/cpu.c
@@ -0,0 +1,62 @@
+/*
+ * linux/arch/arm/mach-nuc970/cpu.c
+ *
+ * Copyright (c) 2014~2016 Nuvoton Technology Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/serial_core.h>
+#include <linux/delay.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+#include <asm/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-gcr.h>
+#include <mach/regs-serial.h>
+#include <mach/regs-clock.h>
+
+#include "cpu.h"
+#include "clock.h"
+
+#ifdef CONFIG_DEBUG_LL
+u32 nuc970_uart_init[1] = {
+	/* Debug UART initialization required */
+	1,
+};
+#endif
+
+void nuc970_restart(/*char*/enum reboot_mode mode, const char *cmd)
+{
+  (void)mode;
+	//UnlockReg
+	while(__raw_readl(NUC970_VA_GCR + 0x1fc) != 1) {
+		__raw_writel(0x59, NUC970_VA_GCR + 0x1fc);
+		__raw_writel(0x16, NUC970_VA_GCR + 0x1fc);
+		__raw_writel(0x88, NUC970_VA_GCR + 0x1fc);
+	}
+
+	__raw_writel(1, REG_AHBIPRST);      // System reset...
+}
+
+EXPORT_SYMBOL(nuc970_restart);
+
Index: linux-4.4.92/arch/arm/mach-nuc970/cpu.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/cpu.h
@@ -0,0 +1,58 @@
+/*
+ * arch/arm/mach-nuc970/cpu.h
+ *
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/serial_core.h>
+
+#ifndef __CPU_H__
+#define __CPU_H__
+
+
+
+#define IODESC_ENT(y)                                  \
+{                                                      \
+       .virtual = (unsigned long)NUC970_VA_##y,       \
+       .pfn     = __phys_to_pfn(NUC970_PA_##y),       \
+       .length  = NUC970_SZ_##y,                      \
+       .type    = MT_DEVICE,                           \
+}
+
+#define NUC970SERIAL_PORT(name)					\
+{								\
+	.membase	= name##_BA,				\
+	.mapbase	= name##_PA,				\
+	.irq		= IRQ_##name,				\
+	.uartclk	= 12000000,				\
+}
+
+#define NUC970PID	NUC970_VA_GCR
+
+
+extern struct platform_device nuc970_device_sdh;
+extern struct platform_device nuc970_device_jpeg;
+
+
+extern void nuc970_init_irq(void);
+extern struct sys_timer nuc970_timer;
+
+extern void nuc970_clock_source(struct device *dev, unsigned char *src);
+extern void nuc970_add_clocks(void);
+extern void nuc970_init_clocks(void);
+extern void nuc970_platform_init(struct platform_device **device, int size);
+
+#endif //__CPU_H__
+
Index: linux-4.4.92/arch/arm/mach-nuc970/dev.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/dev.c
@@ -0,0 +1,1707 @@
+/*
+ * linux/arch/arm/mach-nuc970/dev.c
+ *
+ * Copyright (C) 2014 Nuvoton corporation.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/pwm_backlight.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/pwm.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+
+#include <mach/regs-serial.h>
+#include <mach/irqs.h>
+#include <mach/regs-gcr.h>
+#include <mach/regs-aic.h>
+
+#include <mach/map.h>
+#include <mach/regs-lcd.h>
+#include <mach/gpio.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/i2c/i2c-hid.h>
+
+#include <linux/platform_data/i2c-nuc970.h>
+#include <linux/platform_data/video-nuc970fb.h>
+#include <linux/platform_data/spi-nuc970.h>
+#include <linux/platform_data/dma-nuc970.h>
+#include <linux/platform_data/keypad-nuc970.h>
+
+#include "cpu.h"
+
+/* USB EHCI Host Controller */
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+static struct resource nuc970_ehci_resource[] = {
+        [0] = {
+                .start = NUC970_PA_EHCI,
+                .end   = NUC970_PA_EHCI + NUC970_SZ_EHCI - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_EHCI,
+                .end   = IRQ_EHCI,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static u64 nuc970_device_usb_ehci_dmamask = 0xffffffffUL;
+
+static struct platform_device nuc970_device_ehci = {
+        .name		  = "nuc970-ehci",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_ehci_resource),
+        .resource	  = nuc970_ehci_resource,
+        .dev              = {
+                .dma_mask = &nuc970_device_usb_ehci_dmamask,
+                .coherent_dma_mask = 0xffffffffUL
+        }
+};
+#endif
+/* USB OHCI Host Controller */
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+static struct resource nuc970_ohci_resource[] = {
+        [0] = {
+                .start = NUC970_PA_OHCI,
+                .end   = NUC970_PA_OHCI + NUC970_SZ_OHCI - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_OHCI,
+                .end   = IRQ_OHCI,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static u64 nuc970_device_usb_ohci_dmamask = 0xffffffffUL;
+static struct platform_device nuc970_device_ohci = {
+        .name		  = "nuc970-ohci",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_ohci_resource),
+        .resource	  = nuc970_ohci_resource,
+        .dev              = {
+                .dma_mask = &nuc970_device_usb_ohci_dmamask,
+                .coherent_dma_mask = 0xffffffffUL
+        }
+};
+#endif
+
+/* Cryptographic Accelerator */
+#if defined(CONFIG_CRYPTO_DEV_NUC970) || defined(CONFIG_CRYPTO_DEV_NUC970_MODULE)
+static struct resource nuc970_crypto_resource[] = {
+        [0] = {
+                .start = NUC970_PA_CRYPTO,
+                .end   = NUC970_PA_CRYPTO + NUC970_SZ_CRYPTO - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_CRYPTO,
+                .end   = IRQ_CRYPTO,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static u64 nuc970_device_crypto_dmamask = 0xffffffffUL;
+static struct platform_device nuc970_device_crypto = {
+        .name		  = "nuc970-crypto",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_crypto_resource),
+        .resource	  = nuc970_crypto_resource,
+        .dev              = {
+                .dma_mask = &nuc970_device_crypto_dmamask,
+                .coherent_dma_mask = 0xffffffffUL
+        }
+};
+#endif
+
+/* USB Device (Gadget)*/
+#if defined(CONFIG_USB_NUC970) || defined(CONFIG_USB_NUC970_MODULE)
+static struct resource nuc970_usbgadget_resource[] = {
+        [0] = {
+                .start = NUC970_PA_USBDEV,
+                .end   = NUC970_PA_USBDEV + NUC970_SZ_USBDEV - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_UDC,
+                .end   = IRQ_UDC,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static u64 nuc970_device_udc_dmamask = 0xffffffffUL;
+static struct platform_device nuc970_device_usbgadget = {
+	.name		= "nuc970-usbdev",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(nuc970_usbgadget_resource),
+	.resource	= nuc970_usbgadget_resource,
+	.dev              = {
+		.dma_mask = &nuc970_device_udc_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+#endif
+
+/* Initial serial platform data */
+static struct plat_nuc970serial_port nuc970_uart_data[] = {
+        [0] = NUC970SERIAL_PORT(UART0),
+        [1] = NUC970SERIAL_PORT(UART1),
+        [2] = NUC970SERIAL_PORT(UART2),
+        [3] = NUC970SERIAL_PORT(UART3),
+        [4] = NUC970SERIAL_PORT(UART4),
+        [5] = NUC970SERIAL_PORT(UART5),
+        [6] = NUC970SERIAL_PORT(UART6),
+        [7] = NUC970SERIAL_PORT(UART7),
+        [8] = NUC970SERIAL_PORT(UART8),
+        [9] = NUC970SERIAL_PORT(UART9),
+        [10] = NUC970SERIAL_PORT(UART10),
+        {},
+};
+
+static struct platform_device nuc970_serial_device0 = {
+        .name			= "nuc970-uart",
+        .id			= 0,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[0],
+        },
+};
+
+#if defined(CONFIG_NUC970_UART1) || defined(CONFIG_NUC970_UART1_MODULE)
+static struct platform_device nuc970_serial_device1 = {
+        .name			= "nuc970-uart",
+        .id			= 1,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[1],
+        },
+};
+#endif
+
+#if defined(CONFIG_NUC970_UART2) || defined(CONFIG_NUC970_UART2_MODULE)
+static struct platform_device nuc970_serial_device2 = {
+        .name			= "nuc970-uart",
+        .id			= 2,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[2],
+        },
+};
+#endif
+
+#if defined(CONFIG_NUC970_UART3) || defined(CONFIG_NUC970_UART3_MODULE)
+static struct platform_device nuc970_serial_device3 = {
+        .name			= "nuc970-uart",
+        .id			= 3,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[3],
+        },
+};
+#endif
+
+#if defined(CONFIG_NUC970_UART4) || defined(CONFIG_NUC970_UART4_MODULE)
+static struct platform_device nuc970_serial_device4 = {
+        .name			= "nuc970-uart",
+        .id			= 4,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[4],
+        },
+};
+#endif
+
+#if defined(CONFIG_NUC970_UART5) || defined(CONFIG_NUC970_UART5_MODULE)
+static struct platform_device nuc970_serial_device5 = {
+        .name			= "nuc970-uart",
+        .id			= 5,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[5],
+        },
+};
+#endif
+
+#if defined(CONFIG_NUC970_UART6) || defined(CONFIG_NUC970_UART6_MODULE)
+static struct platform_device nuc970_serial_device6 = {
+        .name			= "nuc970-uart",
+        .id			= 6,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[6],
+        },
+};
+#endif
+
+#if defined(CONFIG_NUC970_UART7) || defined(CONFIG_NUC970_UART7_MODULE)
+static struct platform_device nuc970_serial_device7 = {
+        .name			= "nuc970-uart",
+        .id			= 7,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[7],
+        },
+};
+#endif
+
+#if defined(CONFIG_NUC970_UART8) || defined(CONFIG_NUC970_UART8_MODULE)
+static struct platform_device nuc970_serial_device8 = {
+        .name			= "nuc970-uart",
+        .id			= 8,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[8],
+        },
+};
+#endif
+
+#if defined(CONFIG_NUC970_UART9) || defined(CONFIG_NUC970_UART9_MODULE)
+static struct platform_device nuc970_serial_device9 = {
+        .name			= "nuc970-uart",
+        .id			= 9,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[9],
+        },
+};
+#endif
+
+#if defined(CONFIG_NUC970_UART10) || defined(CONFIG_NUC970_UART10_MODULE)
+static struct platform_device nuc970_serial_device10 = {
+        .name			= "nuc970-uart",
+        .id			= 10,
+        .dev			= {
+                .platform_data	= &nuc970_uart_data[10],
+        },
+};
+#endif
+
+/* LCD controller*/
+#if defined(CONFIG_FB_NUC970) || defined(CONFIG_FB_NUC970_MODULE)
+static struct nuc970fb_display nuc970fb_lcd_info[] = {
+#ifdef CONFIG_A025DL02_320X240
+	/* AUO A035QN02V0 320x240 TFT Panel , 18bits*/
+	[0] = {
+		.type		= LCM_DCCS_VA_SRC_RGB565,
+		.width		= 320,
+		.height		= 240,
+		.xres		= 320,
+		.yres		= 240,
+		.bpp		= 16,
+		.pixclock	= 4000000,
+		.left_margin	= 10,
+		.right_margin   = 54,
+		.hsync_len	= 10,
+		.upper_margin	= 2,
+		.lower_margin	= 4,
+		.vsync_len	= 1,
+		.dccs		= 0x0e00041a,
+		.devctl		= 0x060800c0,
+		.fbctrl		= 0x00a000a0,
+		.scale		= 0x04000400,
+	},
+#endif
+
+#ifdef CONFIG_E50A2V1_800X480
+	/* E50A2V1 800x480 TFT Panel , 24bits*/
+	[0] = {
+#ifdef CONFIG_FB_SRCFMT_RGB888
+		.type		= LCM_DCCS_VA_SRC_RGB888,
+		.bpp		= 32,
+#elif defined(CONFIG_FB_SRCFMT_RGB565)
+		.type   = LCM_DCCS_VA_SRC_RGB565,
+		.bpp		= 16,
+#endif
+		.width		= 800,
+		.height		= 480,
+		.xres		= 800,
+		.yres		= 480,
+		.pixclock	= 20000000,
+		.left_margin	= 88,
+		.right_margin   = 40,
+		.hsync_len		= 48,
+		.upper_margin	= 32,
+		.lower_margin	= 13,
+		.vsync_len		= 3,
+#ifdef CONFIG_FB_SRCFMT_RGB888
+		.dccs		= 0x0e00020a,
+        .fbctrl		= 0x03200320,
+#elif defined(CONFIG_FB_SRCFMT_RGB565)
+		.dccs		= 0x0e00040a,
+		.fbctrl		= 0x01900190,
+#endif
+#ifdef CONFIG_FB_LCD_16BIT_PIN
+        .devctl		= 0x050000c0,
+#elif defined(CONFIG_FB_LCD_18BIT_PIN)
+        .devctl		= 0x060000c0,
+#elif defined(CONFIG_FB_LCD_24BIT_PIN)
+        .devctl		= 0x070000c0,
+#endif
+		.scale		= 0x04000400,
+	},
+#endif
+
+#ifdef CONFIG_ILI9431_MPU80_240x320
+	/* ILI9431 240x320 MPU Panel , 16bits*/
+	[0] = {		
+		.type   = LCM_DCCS_VA_SRC_RGB565,
+		.bpp		= 16,
+		.width		= 240,
+		.height		= 320,
+		.xres		= 240,
+		.yres		= 320,
+		.pixclock	= 6000000,
+		.left_margin	= 6,
+		.right_margin   = 10,
+		.hsync_len		= 2,
+		.upper_margin	= 27,
+		.lower_margin	= 5,
+		.vsync_len		= 11,	
+		.dccs		= 0x0e000400,
+		.fbctrl		= 0x00780078,
+        .devctl		= 0xC50000E0,
+		.scale		= 0x04000400,		
+	},
+#endif
+};
+
+static struct nuc970fb_mach_info nuc970fb_fb_info = {
+	.displays		= &nuc970fb_lcd_info[0],
+	.num_displays		= ARRAY_SIZE(nuc970fb_lcd_info),
+	.default_display	= 0,
+    .gpio_blen          = NUC970_PG3,
+    .gpio_lcs           = NUC970_PG2,
+};
+
+static struct resource nuc970fb_lcd_resource[] = {
+	[0] = {
+		.start = NUC970_PA_LCD,
+		.end   = NUC970_PA_LCD + NUC970_SZ_LCD - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LCD,
+		.end   = IRQ_LCD,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static u64 nuc970fb_device_lcd_dmamask = -1;
+struct platform_device nuc970fb_device_lcd = {
+	.name             = "nuc970-lcd",
+	.id               = -1,
+	.num_resources    = ARRAY_SIZE(nuc970fb_lcd_resource),
+	.resource         = nuc970fb_lcd_resource,
+	.dev              = {
+		.dma_mask               = &nuc970fb_device_lcd_dmamask,
+		.coherent_dma_mask      = -1,
+		.platform_data 		= &nuc970fb_fb_info,
+	}
+};
+#endif
+
+/* SDIO Controller */
+#if defined(CONFIG_MMC_NUC970_SD) || defined(CONFIG_MMC_NUC970_SD_MODULE)
+static struct resource nuc970_sdh_resource[] = {
+        [0] = {
+                .start = NUC970_PA_SDH,
+                .end   = NUC970_PA_SDH + NUC970_SZ_SDH - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_SDH,
+                .end   = IRQ_SDH,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static u64 nuc970_device_sdh_dmamask = 0xffffffffUL;
+struct platform_device nuc970_device_sdh = {
+        .name		  = "nuc970-sdh",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_sdh_resource),
+        .resource	  = nuc970_sdh_resource,
+	    .dev              = {
+		.dma_mask = &nuc970_device_sdh_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+#endif
+
+/* NAND, eMMC Controller */
+#if defined(CONFIG_MTD_NAND_NUC970) || defined(CONFIG_MTD_NAND_NUC970_SD_MODULE) || defined(CONFIG_MMC_NUC970_EMMC) || defined(CONFIG_MMC_NUC970_EMMC_MODULE)
+static struct resource nuc970_fmi_resource[] = {
+        [0] = {
+                .start = NUC970_PA_FMI,
+                .end   = NUC970_PA_FMI + NUC970_SZ_FMI - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_FMI,
+                .end   = IRQ_FMI,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static u64 nuc970_device_fmi_dmamask = 0xffffffffUL;
+struct platform_device nuc970_device_fmi = {
+        .name		  = "nuc970-fmi",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_fmi_resource),
+        .resource	  = nuc970_fmi_resource,
+	    .dev              = {
+		.dma_mask = &nuc970_device_fmi_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+#endif
+
+
+/* Ethernet MAC0 Controller */
+#if defined(CONFIG_NUC970_ETH0) || defined(CONFIG_NUC970_ETH0_MODULE)
+static struct resource nuc970_emac0_resource[] = {
+        [0] = {
+                .start = NUC970_PA_EMAC0,
+                .end   = NUC970_PA_EMAC0 + NUC970_SZ_EMAC0 - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_EMC0TX,
+                .end   = IRQ_EMC0TX,
+                .flags = IORESOURCE_IRQ,
+        },
+        [2] = {
+                .start = IRQ_EMC0RX,
+                .end   = IRQ_EMC0RX,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static u64 nuc970_device_emac0_dmamask = 0xffffffffUL;
+struct platform_device nuc970_device_emac0 = {
+        .name		  = "nuc970-emac0",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_emac0_resource),
+        .resource	  = nuc970_emac0_resource,
+	    .dev              = {
+		.dma_mask = &nuc970_device_emac0_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+#endif
+
+#if defined(CONFIG_NUC970_ETH1) || defined(CONFIG_NUC970_ETH1_MODULE)
+/* Ethernet MAC1 Controller */
+static struct resource nuc970_emac1_resource[] = {
+        [0] = {
+                .start = NUC970_PA_EMAC1,
+                .end   = NUC970_PA_EMAC1 + NUC970_SZ_EMAC1 - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_EMC1TX,
+                .end   = IRQ_EMC1TX,
+                .flags = IORESOURCE_IRQ,
+        },
+        [2] = {
+                .start = IRQ_EMC1RX,
+                .end   = IRQ_EMC1RX,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static u64 nuc970_device_emac1_dmamask = 0xffffffffUL;
+struct platform_device nuc970_device_emac1 = {
+        .name		  = "nuc970-emac1",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_emac1_resource),
+        .resource	  = nuc970_emac1_resource,
+	    .dev              = {
+		.dma_mask = &nuc970_device_emac1_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+#endif
+
+/* JPEG Controller */
+#if defined(CONFIG_NUC970_JPEG_CODEC) || defined(CONFIG_NUC970_JPEG_CODEC_MODULE)
+static struct resource nuc970_jpeg_resource[] = {
+        [0] = {
+                .start = NUC970_PA_JPEG,
+                .end   = NUC970_PA_JPEG + NUC970_SZ_JPEG - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_JPEG,
+                .end   = IRQ_JPEG,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static u64 nuc970_device_jpeg_dmamask = 0xffffffffUL;
+struct platform_device nuc970_device_jpeg = {
+        .name		  = "nuc970-jpeg",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_jpeg_resource),
+        .resource	  = nuc970_jpeg_resource,
+	    .dev              = {
+		.dma_mask = &nuc970_device_jpeg_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+#endif
+
+/* VIDEOIN */
+#if defined(CONFIG_VIDEO_NUC970) || defined(CONFIG_VIDEO_NUC970_MODULE)
+static struct resource nuc970_cap_resource[] = {
+        [0] = {
+                .start = NUC970_PA_CAP,
+                .end   = NUC970_PA_CAP + NUC970_SZ_CAP - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_CAP,
+                .end   = IRQ_CAP,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+struct platform_device nuc970_device_cap = {
+        .name		  = "nuc970-videoin",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_cap_resource),
+        .resource	  = nuc970_cap_resource,
+};
+
+#endif
+
+/* ADC */
+#if defined(CONFIG_NUC970_ADC) || defined(CONFIG_NUC970_ADC_MODULE)
+static struct resource nuc970_adc_resource[] = {
+        [0] = {
+                .start = NUC970_PA_ADC,
+                .end   = NUC970_PA_ADC + NUC970_SZ_ADC - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_ADC,
+                .end   = IRQ_ADC,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+struct platform_device nuc970_device_adc = {
+        .name		  = "nuc970-adc",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_adc_resource),
+        .resource	  = nuc970_adc_resource,
+};
+#endif
+
+/* Normal ADC */
+#if defined(CONFIG_NUC970_NADC) || defined(CONFIG_NUC970_NADC_MODULE)
+static struct resource nuc970_nadc_resource[] = {
+        [0] = {
+                .start = NUC970_PA_ADC,
+                .end   = NUC970_PA_ADC + NUC970_SZ_ADC - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_ADC,
+                .end   = IRQ_ADC,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+struct platform_device nuc970_device_nadc = {
+        .name		  = "nuc970-nadc",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_nadc_resource),
+        .resource	  = nuc970_nadc_resource,
+};
+#endif
+
+#if defined(CONFIG_NUC970_DMA) || defined(CONFIG_NUC970_DMA_MODULE)
+#define DMA_CHANNEL(_name, _base, _irq) \
+	{ .name = (_name), .base = (_base), .irq = (_irq) }
+
+static struct resource nuc970_gdma_resource[] = {
+        [0] = {
+                .start = NUC970_PA_GDMA,
+                .end   = NUC970_PA_GDMA + NUC970_SZ_GDMA - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_GDMA0,
+                .end   = IRQ_GDMA0,
+                .flags = IORESOURCE_IRQ,
+        },
+        [2] = {
+                .start = IRQ_GDMA1,
+                .end   = IRQ_GDMA1,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+struct nuc970_dma_chan_data nuc970_dma_m2m_channels[] = {
+	DMA_CHANNEL("m2m0", NUC970_VA_GDMA + 0x000, IRQ_GDMA0),
+	DMA_CHANNEL("m2m1", NUC970_VA_GDMA + 0x020, IRQ_GDMA1),
+};
+
+struct nuc970_dma_platform_data nuc970_dma_m2m_data = {
+	.channels		= nuc970_dma_m2m_channels,
+	.num_channels		= ARRAY_SIZE(nuc970_dma_m2m_channels),
+};
+
+
+static struct platform_device nuc970_device_gdma = {
+	.name			= "nuc970-dma-m2m",
+	.id			= -1,
+    .num_resources	= ARRAY_SIZE(nuc970_gdma_resource),
+    .resource	= nuc970_gdma_resource,
+	.dev			= {
+	.platform_data	= &nuc970_dma_m2m_data,
+	},
+};
+#endif
+
+
+/* AUDIO controller*/
+#if defined(CONFIG_SND_SOC_NUC970) || defined(CONFIG_SND_SOC_NUC970_MODULE)
+static u64 nuc970_device_audio_dmamask = -1;
+static struct resource nuc970_i2s_resource[] = {
+        [0] = {
+                .start = NUC970_PA_ACTL,
+                .end   = NUC970_PA_ACTL + NUC970_SZ_ACTL - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_ACTL,
+                .end   = IRQ_ACTL,
+                .flags = IORESOURCE_IRQ,
+        }
+
+};
+
+struct platform_device nuc970_device_audio_i2s = {
+        .name		= "nuc970-audio-i2s",
+        .id		= -1,
+        .num_resources	= ARRAY_SIZE(nuc970_i2s_resource),
+        .resource	= nuc970_i2s_resource,
+        .dev              = {
+                .dma_mask               = &nuc970_device_audio_dmamask,
+                .coherent_dma_mask      = -1,
+        }
+};
+
+struct platform_device nuc970_device_audio = {
+	.name		= "nuc970-audio",
+	.id		= -1,
+};
+
+struct platform_device nuc970_device_audio_pcm = {
+	.name		= "nuc970-audio-pcm",
+	.id		= 0,
+};
+#endif
+
+/* I2C */
+#if defined(CONFIG_I2C_BUS_NUC970_P0) || defined(CONFIG_I2C_BUS_NUC970_P0_MODULE)
+// port 0
+/* I2C clients */
+static struct i2c_board_info __initdata nuc970_i2c_clients0[] =
+{
+#ifdef CONFIG_SND_SOC_NAU8822
+	{I2C_BOARD_INFO("nau8822", 0x1a),},
+#endif
+};
+static struct resource nuc970_i2c0_resource[] = {
+        [0] = {
+                .start = NUC970_PA_I2C0,
+                .end   = NUC970_PA_I2C0 + NUC970_SZ_I2C0 - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_I2C0,
+                .end   = IRQ_I2C0,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+static struct nuc970_platform_i2c nuc970_i2c0_data = {
+	.bus_num = 0,
+	.bus_freq = 100000,
+};
+
+struct platform_device nuc970_device_i2c0 = {
+        .name		  = "nuc970-i2c0",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_i2c0_resource),
+        .resource	  = nuc970_i2c0_resource,
+		.dev = {
+        	.platform_data = &nuc970_i2c0_data,
+    	}
+};
+#endif
+#if defined(CONFIG_I2C_BUS_NUC970_P1) || defined(CONFIG_I2C_BUS_NUC970_P1_MODULE)
+//port 1
+static struct nuc970_platform_i2c nuc970_i2c1_data = {
+	.bus_num = 1,
+	.bus_freq = 100000,
+};
+
+static struct resource nuc970_i2c_p1_resource[] = {
+        [0] = {
+                .start = NUC970_PA_I2C1,
+                .end   = NUC970_PA_I2C1+ NUC970_SZ_I2C1 - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_I2C1,
+                .end   = IRQ_I2C1,
+                .flags = IORESOURCE_IRQ,
+        }
+
+};
+
+struct platform_device nuc970_device_i2c1 = {
+        .name		  = "nuc970-i2c1",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_i2c_p1_resource),
+        .resource	  = nuc970_i2c_p1_resource,
+        .dev = {
+        	.platform_data = &nuc970_i2c1_data,
+    	}
+};
+#endif
+
+/* SPI */
+#if defined(CONFIG_SPI_NUC970_P0) || defined(CONFIG_SPI_NUC970_P0_MODULE)
+/* spi device, spi flash info */
+#ifdef CONFIG_MTD_M25P80
+static struct mtd_partition nuc970_spi0_flash_partitions[] = {
+ #ifdef CONFIG_BOARD_ETH2UART
+         {
+                .name = "kernel",
+                .size = 0x0800000,
+                .offset = 0x1000000,
+        },
+        {
+                .name = "rootfs",
+                .size = 0x0800000,
+                .offset = 0x1800000,
+        },
+ #else
+        {
+                .name = "kernel",
+                .size = 0x0800000,
+                .offset = 0,
+        },
+        {
+                .name = "rootfs",
+                .size = 0x0800000,
+                .offset = 0x0800000,
+        },
+ #endif
+};
+static struct flash_platform_data nuc970_spi0_flash_data = {
+        .name = "m25p80",
+        .parts =  nuc970_spi0_flash_partitions,
+        .nr_parts = ARRAY_SIZE(nuc970_spi0_flash_partitions),
+        .type = "w25q128",        
+};
+#endif
+
+static struct spi_board_info nuc970_spi0_board_info[] __initdata = {
+#ifdef CONFIG_MTD_M25P80        
+        {
+                .modalias = "m25p80",
+                .max_speed_hz = 15000000,
+                .bus_num = 0,
+                .chip_select = 0,       //use SS0
+                .platform_data = &nuc970_spi0_flash_data,
+ #if defined(CONFIG_SPI_NUC970_P0_NORMAL)
+                .mode = (SPI_MODE_0 | SPI_RX_DUAL | SPI_TX_DUAL),
+ #elif defined(CONFIG_SPI_NUC970_P0_QUAD) 
+                .mode = (SPI_MODE_0 | SPI_TX_QUAD | SPI_RX_QUAD),
+ #endif
+        },
+#endif
+
+#ifdef CONFIG_SPI_SPIDEV
+        {
+                .modalias = "spidev",
+                .max_speed_hz = 75000000,
+                .bus_num = 0,
+                .chip_select = 1,       //use SS1
+                .mode = SPI_MODE_0,
+        },
+#endif
+};
+
+static struct nuc970_spi_info nuc970_spi0_platform_data = {
+        .num_cs		= 2,
+        .lsb		= 0,
+        .txneg		= 1,
+        .rxneg		= 0,
+        .divider	= 4,
+        .sleep		= 0,
+        .txnum		= 0,
+        .txbitlen	= 8,
+        .bus_num	= 0,
+};
+
+static struct resource nuc970_spi0_resource[] = {
+        [0] = {
+                .start = NUC970_PA_SPI0,
+                .end   = NUC970_PA_SPI0 + NUC970_SZ_SPI0 - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_SPI0,
+                .end   = IRQ_SPI0,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+struct platform_device nuc970_device_spi0 = {
+        .name		  = "nuc970-spi0",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_spi0_resource),
+        .resource	  = nuc970_spi0_resource,
+#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_SPI_SPIDEV)
+        .dev		= {
+                .platform_data = &nuc970_spi0_platform_data,
+    }
+#endif
+};
+#endif
+
+#if defined(CONFIG_SPI_NUC970_P1) || defined(CONFIG_SPI_NUC970_P1_MODULE)
+/* spi device, spi flash info */
+#ifdef CONFIG_BOARD_TOMATO
+
+#ifdef CONFIG_SPI_SPIDEV
+static struct spi_board_info nuc970_spi1_board_info[] __initdata = {
+        {
+                .modalias = "spidev",
+                .max_speed_hz = 75000000,
+                .bus_num = 1,
+                .chip_select = 0,       //use SS0
+                .mode = SPI_MODE_0,
+        },
+};
+#endif
+
+#else   //CONFIG_BOARD_TOMATO
+
+#ifdef CONFIG_MTD_M25P80
+static struct mtd_partition nuc970_spi1_flash_partitions[] = {
+        {
+                .name = "SPI flash",
+                .size = 0x0200000,
+                .offset = 0,
+        },
+};
+
+static struct flash_platform_data nuc970_spi1_flash_data = {
+        .name = "m25p80",
+        .parts =  nuc970_spi1_flash_partitions,
+        .nr_parts = ARRAY_SIZE(nuc970_spi1_flash_partitions),
+        .type = "en25qh16",
+};
+#endif
+
+static struct spi_board_info nuc970_spi1_board_info[] __initdata = {
+#ifdef CONFIG_MTD_M25P80
+        {
+                .modalias = "m25p80",
+                .max_speed_hz = 15000000,
+                .bus_num = 1,
+                .chip_select = 0,       //use SS0
+                .platform_data = &nuc970_spi1_flash_data,
+                .mode = SPI_MODE_0,
+        },
+#endif
+#ifdef CONFIG_SPI_SPIDEV        
+        {
+                .modalias = "spidev",
+                .max_speed_hz = 75000000,
+                .bus_num = 1,
+                .chip_select = 1,       //use SS1
+                .mode = SPI_MODE_0,
+        },
+#endif
+};
+#endif
+
+static struct nuc970_spi_info nuc970_spi1_platform_data = {
+        .num_cs		= 2,
+        .lsb		= 0,
+        .txneg		= 1,
+        .rxneg		= 0,
+        .divider	= 4,
+        .sleep		= 0,
+        .txnum		= 0,
+        .txbitlen	= 8,
+        .bus_num	= 1,
+};
+
+static struct resource nuc970_spi1_resource[] = {
+        [0] = {
+                .start = NUC970_PA_SPI1,
+                .end   = NUC970_PA_SPI1 + NUC970_SZ_SPI1 - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_SPI1,
+                .end   = IRQ_SPI1,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+struct platform_device nuc970_device_spi1 = {
+        .name		  = "nuc970-spi1",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_spi1_resource),
+        .resource	  = nuc970_spi1_resource,
+#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_SPI_SPIDEV)
+        .dev		= {
+                .platform_data = &nuc970_spi1_platform_data,
+		}
+#endif
+};
+#endif
+
+#if defined(CONFIG_KEYBOARD_NUC970) || defined(CONFIG_KEYBOARD_NUC970_MODULE)
+static int nuc970_keymap[] = {
+	KEY(0, 0, KEY_A),	KEY(0, 1, KEY_B),
+	KEY(0, 2, KEY_C),	KEY(0, 3, KEY_D),
+	KEY(0, 4, KEY_E),	KEY(0, 5, KEY_F),
+	KEY(0, 6, KEY_G),	KEY(0, 7, KEY_H),
+
+	KEY(1, 0, KEY_I),	KEY(1, 1, KEY_J),
+	KEY(1, 2, KEY_K),	KEY(1, 3, KEY_L),
+	KEY(1, 4, KEY_M),	KEY(1, 5, KEY_N),
+	KEY(1, 6, KEY_O),	KEY(1, 7, KEY_P),
+
+	KEY(2, 0, KEY_Q),	KEY(2, 1, KEY_R),
+	KEY(2, 2, KEY_S),	KEY(2, 3, KEY_T),
+	KEY(2, 4, KEY_U),	KEY(2, 5, KEY_V),
+	KEY(2, 6, KEY_W),	KEY(2, 7, KEY_X),
+
+	KEY(3, 0, KEY_Y),	KEY(3, 1, KEY_Z),
+	KEY(3, 2, KEY_1),	KEY(3, 3, KEY_2),
+	KEY(3, 4, KEY_3),	KEY(3, 5, KEY_4),
+	KEY(3, 6, KEY_5),	KEY(3, 7, KEY_6),
+};
+
+static struct matrix_keymap_data nuc970_map_data = {
+	.keymap			= nuc970_keymap,
+	.keymap_size	= ARRAY_SIZE(nuc970_keymap),
+};
+
+static struct nuc970_keypad_platform_data nuc970_keypad_info = {
+		.keymap_data	= &nuc970_map_data,
+        .prescale		= 0x80,
+        .debounce		= 0x8,
+};
+
+
+static struct resource nuc970_kpi_resource[] = {
+	[0] = {
+			.start = NUC970_PA_KPI,
+			.end   = NUC970_PA_KPI + NUC970_SZ_KPI - 1,
+			.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+			.start = IRQ_KPI,
+			.end   = IRQ_KPI,
+			.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device nuc970_device_kpi = {
+        .name		  = "nuc970-kpi",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_kpi_resource),
+        .resource	  = nuc970_kpi_resource,
+
+		.dev		= {
+                .platform_data = &nuc970_keypad_info,
+		}
+};
+#endif
+
+#if defined(CONFIG_RTC_DRV_NUC970) || defined(CONFIG_RTC_DRV_NUC970_MODULE)
+static struct resource nuc970_rtc_resource[] = {
+        [0] = {
+                .start = NUC970_PA_RTC,
+                .end   = NUC970_PA_RTC + NUC970_SZ_RTC - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_RTC,
+                .end   = IRQ_RTC,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+struct platform_device nuc970_device_rtc = {
+        .name		= "nuc970-rtc",
+        .id		= -1,
+        .num_resources	= ARRAY_SIZE(nuc970_rtc_resource),
+        .resource	= nuc970_rtc_resource,
+};
+#endif
+
+#if defined(CONFIG_NUC970_CAN0) || defined(CONFIG_NUC970_CAN0_MODULE)
+static struct resource nuc970_can0_resource[] = {
+        [0] = {
+                .start = NUC970_PA_CAN,
+                .end   = NUC970_PA_CAN + NUC970_SZ_CAN - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_CAN0,
+                .end   = IRQ_CAN0,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+struct platform_device nuc970_device_can0 = {
+        .name		= "nuc970-can0",
+        .id		= -1,
+        .num_resources	= ARRAY_SIZE(nuc970_can0_resource),
+        .resource	= nuc970_can0_resource,
+};
+#endif
+
+#if defined(CONFIG_NUC970_CAN1) || defined(CONFIG_NUC970_CAN1_MODULE)
+static struct resource nuc970_can1_resource[] = {
+        [0] = {
+                .start = NUC970_PA_CAN1,
+                .end   = NUC970_PA_CAN1 + NUC970_SZ_CAN1 - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_CAN1,
+                .end   = IRQ_CAN1,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+struct platform_device nuc970_device_can1 = {
+        .name		= "nuc970-can1",
+        .id		= -1,
+        .num_resources	= ARRAY_SIZE(nuc970_can1_resource),
+        .resource	= nuc970_can1_resource,
+};
+#endif
+
+#if defined(CONFIG_NUC970_EBI) || defined(CONFIG_NUC970_EBI_MODULE)
+static struct resource nuc970_ebi_resource[] = {
+        [0] = {
+                .start = NUC970_PA_EBI,
+                .end   = NUC970_PA_EBI + NUC970_SZ_EBI - 1,
+                .flags = IORESOURCE_MEM,
+        },
+};
+
+struct platform_device nuc970_device_ebi = {
+        .name           = "nuc970-ebi",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(nuc970_ebi_resource),
+        .resource       = nuc970_ebi_resource,
+};
+#endif
+
+#if defined(CONFIG_PWM_NUC970) || defined(CONFIG_PWM_NUC970_MODULE)
+static struct pwm_lookup board_pwm_lookup[] = {
+	PWM_LOOKUP("nuc970-pwm", 0, "pwm-backlight", NULL),
+};
+
+#if 0
+static struct resource nuc970_pwm_resource[] = {
+        [0] = {
+                .start = NUC970_PA_PWM,
+                .end   = NUC970_PA_PWM + NUC970_SZ_PWM - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_PWM,
+                .end   = IRQ_PWM,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+#endif
+
+struct platform_device nuc970_device_pwm0 = {
+        .name		  = "nuc970-pwm",
+        .id		  = 0,
+};
+struct platform_device nuc970_device_pwm1 = {
+        .name		  = "nuc970-pwm",
+        .id		  = 1,
+};
+struct platform_device nuc970_device_pwm2 = {
+        .name		  = "nuc970-pwm",
+        .id		  = 2,
+};
+struct platform_device nuc970_device_pwm3 = {
+        .name		  = "nuc970-pwm",
+        .id		  = 3,
+};
+#endif
+
+#if defined(CONFIG_NUC970_WDT) || defined(CONFIG_NUC970_WDT_MODULE)
+static struct resource nuc970_wdt_resource[] = {
+        [0] = {
+                .start = NUC970_PA_WDT,
+                .end   = NUC970_PA_WDT + NUC970_SZ_WDT - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_WDT,
+                .end   = IRQ_WDT,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+struct platform_device nuc970_device_wdt = {
+        .name		  = "nuc970-wdt",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_wdt_resource),
+        .resource	  = nuc970_wdt_resource,
+};
+#endif
+
+#if defined(CONFIG_NUC970_WWDT) || defined(CONFIG_NUC970_WWDT_MODULE)
+static struct resource nuc970_wwdt_resource[] = {
+        [0] = {
+                .start = NUC970_PA_WWDT,
+                .end   = NUC970_PA_WWDT + NUC970_SZ_WWDT - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_WWDT,
+                .end   = IRQ_WWDT,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+struct platform_device nuc970_device_wwdt = {
+        .name		  = "nuc970-wwdt",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_wwdt_resource),
+        .resource	  = nuc970_wwdt_resource,
+};
+#endif
+
+#if defined(CONFIG_SCUART_NUC970) || defined(CONFIG_SCUART_NUC970_MODULE)
+/* Initial serial platform data */
+static struct plat_nuc970serial_port nuc970_scuart_data[] = {
+        [0] = {
+		.membase	= NUC970_VA_SC,
+		.mapbase	= NUC970_PA_SC,
+		.irq 		= IRQ_SMC0,
+		.uartclk 	= 12000000,
+
+        },
+        [1] = {
+		.membase	= (NUC970_VA_SC + 0x400),
+		.mapbase	= (NUC970_PA_SC + 0x400),
+		.irq 		= IRQ_SMC1,
+		.uartclk 	= 12000000,
+
+        },
+        {},
+};
+#endif
+
+#if defined(CONFIG_NUC970_SC) || defined(CONFIG_NUC970_SC_MODULE) || defined(CONFIG_SCUART_NUC970) || defined(CONFIG_SCUART_NUC970_MODULE)
+
+#if defined(CONFIG_NUC970_SC) || defined(CONFIG_NUC970_SC_MODULE)
+static struct resource nuc970_sc0_resource[] = {
+        [0] = {
+                .start = NUC970_PA_SC,
+                .end   = NUC970_PA_SC + 0x400 - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_SMC0,
+                .end   = IRQ_SMC0,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+static struct resource nuc970_sc1_resource[] = {
+        [0] = {
+                .start = NUC970_PA_SC + 0x400,
+                .end   = NUC970_PA_SC + 0x800 - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_SMC1,
+                .end   = IRQ_SMC1,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+#endif
+
+struct platform_device nuc970_device_sc0 = {
+        .name		  = "nuc970-sc",
+        .id		  = 0,
+#if defined(CONFIG_NUC970_SC) || defined(CONFIG_NUC970_SC_MODULE)
+        .num_resources	  = ARRAY_SIZE(nuc970_sc0_resource),
+        .resource	  = nuc970_sc0_resource,
+#endif
+#if defined(CONFIG_SCUART_NUC970) || defined(CONFIG_SCUART_NUC970_MODULE)
+        .dev			= {
+                .platform_data	= &nuc970_scuart_data[0],
+        },
+#endif
+};
+struct platform_device nuc970_device_sc1 = {
+        .name		  = "nuc970-sc",
+        .id		  = 1,
+#if defined(CONFIG_NUC970_SC) || defined(CONFIG_NUC970_SC_MODULE)
+        .num_resources	  = ARRAY_SIZE(nuc970_sc1_resource),
+        .resource	  = nuc970_sc1_resource,
+#endif
+#if defined(CONFIG_SCUART_NUC970) || defined(CONFIG_SCUART_NUC970_MODULE)
+        .dev			= {
+                .platform_data	= &nuc970_scuart_data[1],
+        },
+#endif
+};
+
+#endif
+
+
+#if defined(CONFIG_NUC970_ETIMER) || defined(CONFIG_NUC970_ETIMER_MODULE)
+static struct resource nuc970_etimer_resource[] = {
+        [0] = {
+                .start = IRQ_ETIMER0,
+                .end   = IRQ_ETIMER0,
+                .flags = IORESOURCE_IRQ,
+        },
+        [1] = {
+                .start = IRQ_ETIMER1,
+                .end   = IRQ_ETIMER1,
+                .flags = IORESOURCE_IRQ,
+        },
+        [2] = {
+                .start = IRQ_ETIMER2,
+                .end   = IRQ_ETIMER2,
+                .flags = IORESOURCE_IRQ,
+        },
+        [3] = {
+                .start = IRQ_ETIMER3,
+                .end   = IRQ_ETIMER3,
+                .flags = IORESOURCE_IRQ,
+        },
+};
+
+struct platform_device nuc970_device_etimer0 = {
+        .name		  = "nuc970-etimer",
+        .id		  = 0,
+        .num_resources	  = ARRAY_SIZE(nuc970_etimer_resource),
+        .resource	  = nuc970_etimer_resource,
+};
+struct platform_device nuc970_device_etimer1 = {
+        .name		  = "nuc970-etimer",
+        .id		  = 1,
+        .num_resources	  = ARRAY_SIZE(nuc970_etimer_resource),
+        .resource	  = nuc970_etimer_resource,
+};
+struct platform_device nuc970_device_etimer2 = {
+        .name		  = "nuc970-etimer",
+        .id		  = 2,
+        .num_resources	  = ARRAY_SIZE(nuc970_etimer_resource),
+        .resource	  = nuc970_etimer_resource,
+};
+struct platform_device nuc970_device_etimer3 = {
+        .name		  = "nuc970-etimer",
+        .id		  = 3,
+        .num_resources	  = ARRAY_SIZE(nuc970_etimer_resource),
+        .resource	  = nuc970_etimer_resource,
+};
+#endif
+#if defined(CONFIG_PINCTRL) || defined(CONFIG_PINCTRL_MODULE)
+struct platform_device nuc970_device_pinctrl = {
+        .name		  = "pinctrl-nuc970",
+        .id		  = -1,
+};
+#endif
+
+#if defined(CONFIG_GPIO_NUC970) || defined(CONFIG_GPIO_NUC970_MODULE)
+#if defined(CONFIG_I2C_ALGOBIT) || defined(CONFIG_I2C_ALGOBIT_MODULE)
+static struct i2c_board_info __initdata nuc970_i2c_clients2[] =
+{
+#ifdef CONFIG_SENSOR_OV7725
+	{I2C_BOARD_INFO("ov7725",  0x21),},
+#endif
+#ifdef CONFIG_SENSOR_OV5640
+	{I2C_BOARD_INFO("ov5640",  0x3c),},
+#endif
+#ifdef CONFIG_SENSOR_NT99141
+	{I2C_BOARD_INFO("nt99141", 0x2a),},
+#endif
+#ifdef CONFIG_SENSOR_NT99050
+	{I2C_BOARD_INFO("nt99050", 0x21),},
+#endif
+};
+static struct i2c_gpio_platform_data i2c_gpio_adapter_data = {
+    .sda_pin = NUC970_PB1,
+    .scl_pin = NUC970_PB0,
+    .udelay = 1,
+    .timeout = 100,
+    .sda_is_open_drain = 0,   //not support open drain mode
+    .scl_is_open_drain = 0,   //not support open drain mode
+};
+
+static struct platform_device i2c_gpio = {
+    .name = "i2c-gpio",
+    .id = 2,
+    .dev = {
+        .platform_data = &i2c_gpio_adapter_data,
+        },
+};
+#endif
+static struct resource nuc970_gpio_resource[] = {
+	[0] = {
+	       .start = NUC970_PA_GPIO,
+	       .end = NUC970_PA_GPIO + NUC970_SZ_GPIO - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+struct platform_device nuc970_device_gpio = {
+	.name = "nuc970-gpio",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(nuc970_gpio_resource),
+	.resource = nuc970_gpio_resource,
+};
+
+#ifndef CONFIG_OF
+struct platform_device nuc970_device_eint0 = {
+        .name		  = "nuc970-gpio",
+        .id		  = 1,
+};
+
+struct platform_device nuc970_device_eint1 = {
+        .name		  = "nuc970-gpio",
+        .id		  = 2,
+};
+
+struct platform_device nuc970_device_eint2 = {
+        .name		  = "nuc970-gpio",
+        .id		  = 3,
+};
+
+struct platform_device nuc970_device_eint3 = {
+        .name		  = "nuc970-gpio",
+        .id		  = 4,
+};
+
+struct platform_device nuc970_device_eint4 = {
+        .name		  = "nuc970-gpio",
+        .id		  = 5,
+};
+
+struct platform_device nuc970_device_eint5 = {
+        .name		  = "nuc970-gpio",
+        .id		  = 6,
+};
+
+struct platform_device nuc970_device_eint6 = {
+        .name		  = "nuc970-gpio",
+        .id		  = 7,
+};
+
+struct platform_device nuc970_device_eint7 = {
+        .name		  = "nuc970-gpio",
+        .id		  = 8,
+};
+#endif
+#endif
+
+#if defined(CONFIG_NUC970_GE2D) || defined(CONFIG_NUC970_GE2D_MODULE)
+static struct resource nuc970_ge2d_resource[] = {
+        [0] = {
+                .start = NUC970_PA_GE,
+                .end   = NUC970_PA_GE + NUC970_SZ_GE - 1,
+                .flags = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start = IRQ_GE2D,
+                .end   = IRQ_GE2D,
+                .flags = IORESOURCE_IRQ,
+        }
+};
+
+struct platform_device nuc970_device_ge2d = {
+        .name		  = "nuc970-ge2d",
+        .id		  = -1,
+        .num_resources	  = ARRAY_SIZE(nuc970_ge2d_resource),
+        .resource	  = nuc970_ge2d_resource,
+};
+#endif
+
+#if defined(CONFIG_IIO_GPIO_TRIGGER) || defined(CONFIG_IIO_GPIO_TRIGGER_MODULE)
+static struct resource iio_gpio_trigger_resources[] = {
+	[0] = {
+		.start  = IRQ_GPIO_START+NUC970_PE2,
+		.end    = IRQ_GPIO_START+NUC970_PE2,
+		.flags  = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE,
+	},
+};
+
+static struct platform_device iio_gpio_trigger = {
+	.name = "iio_gpio_trigger",
+	.num_resources = ARRAY_SIZE(iio_gpio_trigger_resources),
+	.resource = iio_gpio_trigger_resources,
+};
+#endif
+#if defined(CONFIG_BACKLIGHT_PWM)
+static struct platform_pwm_backlight_data nuc970_backlight_data = {
+	.pwm_id		= 0,
+	.max_brightness	= 1,
+	.dft_brightness	= 1,
+	.pwm_period_ns	= 78000,
+};
+
+struct platform_device nuc970_pwm_bl = {
+        .name		  = "pwm-backlight",
+	.dev		= {
+		.platform_data = &nuc970_backlight_data,
+	},
+};
+#endif
+static struct platform_device *nuc970_public_dev[] __initdata = {
+        &nuc970_serial_device0,
+
+#if defined(CONFIG_NUC970_UART1) || defined(CONFIG_NUC970_UART1_MODULE)
+		&nuc970_serial_device1,
+#endif
+
+#if defined(CONFIG_NUC970_UART2) || defined(CONFIG_NUC970_UART2_MODULE)
+		&nuc970_serial_device2,
+#endif
+
+#if defined(CONFIG_NUC970_UART3) || defined(CONFIG_NUC970_UART3_MODULE)
+		&nuc970_serial_device3,
+#endif
+
+#if defined(CONFIG_NUC970_UART4) || defined(CONFIG_NUC970_UART4_MODULE)
+		&nuc970_serial_device4,
+#endif
+
+#if defined(CONFIG_NUC970_UART5) || defined(CONFIG_NUC970_UART5_MODULE)
+		&nuc970_serial_device5,
+#endif
+
+#if defined(CONFIG_NUC970_UART6) || defined(CONFIG_NUC970_UART6_MODULE)
+		&nuc970_serial_device6,
+#endif
+
+#if defined(CONFIG_NUC970_UART7) || defined(CONFIG_NUC970_UART7_MODULE)
+		&nuc970_serial_device7,
+#endif
+
+#if defined(CONFIG_NUC970_UART8) || defined(CONFIG_NUC970_UART8_MODULE)
+		&nuc970_serial_device8,
+#endif
+
+#if defined(CONFIG_NUC970_UART9) || defined(CONFIG_NUC970_UART9_MODULE)
+		&nuc970_serial_device9,
+#endif
+
+#if defined(CONFIG_NUC970_UART10) || defined(CONFIG_NUC970_UART10_MODULE)
+		&nuc970_serial_device10,
+#endif
+
+#if defined(CONFIG_NUC970_CAN0) || defined(CONFIG_NUC970_CAN0_MODULE)
+	&nuc970_device_can0,
+#endif
+
+#if defined(CONFIG_NUC970_CAN1) || defined(CONFIG_NUC970_CAN1_MODULE)
+	&nuc970_device_can1,
+#endif
+
+#if defined(CONFIG_NUC970_EBI) || defined(CONFIG_NUC970_EBI_MODULE)
+	&nuc970_device_ebi,
+#endif
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+        &nuc970_device_ohci,
+#endif
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+        &nuc970_device_ehci,
+#endif
+#if defined(CONFIG_CRYPTO_DEV_NUC970) || defined(CONFIG_CRYPTO_DEV_NUC970_MODULE)
+		&nuc970_device_crypto,
+#endif
+#if defined(CONFIG_FB_NUC970) || defined(CONFIG_FB_NUC970_MODULE)
+        &nuc970fb_device_lcd,
+#endif
+#if defined(CONFIG_I2C_BUS_NUC970_P0) || defined(CONFIG_I2C_BUS_NUC970_P0_MODULE)
+	&nuc970_device_i2c0,
+#endif
+#if defined(CONFIG_I2C_BUS_NUC970_P1) || defined(CONFIG_I2C_BUS_NUC970_P1_MODULE)
+        &nuc970_device_i2c1,
+#endif
+#if defined(CONFIG_NUC970_DMA) || defined(CONFIG_NUC970_DMA_MODULE)
+	&nuc970_device_gdma,
+#endif
+
+#if defined(CONFIG_MMC_NUC970_SD) || defined(CONFIG_MMC_NUC970_SD_MODULE)
+	&nuc970_device_sdh,
+#endif
+#if defined(CONFIG_MTD_NAND_NUC970) || defined(CONFIG_MTD_NAND_NUC970_MODULE) || defined(CONFIG_MMC_NUC970_EMMC) || defined(CONFIG_MMC_NUC970_EMMC_MODULE)
+	&nuc970_device_fmi,
+#endif
+#if defined(CONFIG_NUC970_JPEG_CODEC) || defined(CONFIG_NUC970_JPEG_CODEC_MODULE)
+	&nuc970_device_jpeg,
+#endif
+#if defined(CONFIG_NUC970_ETH0) || defined(CONFIG_NUC970_ETH0_MODULE)
+	&nuc970_device_emac0,
+#endif
+#if defined(CONFIG_NUC970_ETH1) || defined(CONFIG_NUC970_ETH1_MODULE)
+	&nuc970_device_emac1,
+#endif
+#if defined(CONFIG_PWM_NUC970) || defined(CONFIG_PWM_NUC970_MODULE)
+	&nuc970_device_pwm0,
+	&nuc970_device_pwm1,
+	&nuc970_device_pwm2,
+	&nuc970_device_pwm3,
+#endif
+#if defined(CONFIG_NUC970_WDT) || defined(CONFIG_NUC970_WDT_MODULE)
+	&nuc970_device_wdt,
+#endif
+#if defined(CONFIG_NUC970_WWDT) || defined(CONFIG_NUC970_WWDT_MODULE)
+	&nuc970_device_wwdt,
+#endif
+#if defined(CONFIG_VIDEO_NUC970) || defined(CONFIG_VIDEO_NUC970_MODULE)
+	&nuc970_device_cap,
+#endif
+#if defined(CONFIG_SND_SOC_NUC970) || defined(CONFIG_SND_SOC_NUC970_MODULE)
+	&nuc970_device_audio_pcm,
+	&nuc970_device_audio,
+	&nuc970_device_audio_i2s,
+#endif
+#if defined(CONFIG_USB_NUC970) || defined(CONFIG_USB_NUC970_MODULE)
+	&nuc970_device_usbgadget,
+#endif
+#if defined(CONFIG_SPI_NUC970_P0) || defined(CONFIG_SPI_NUC970_P0_MODULE)
+	&nuc970_device_spi0,
+#endif
+#if defined(CONFIG_SPI_NUC970_P1) || defined(CONFIG_SPI_NUC970_P1_MODULE)
+	&nuc970_device_spi1,
+#endif
+
+#if defined(CONFIG_NUC970_ADC) || defined(CONFIG_NUC970_ADC_MODULE)
+	&nuc970_device_adc,
+#endif
+#if defined(CONFIG_NUC970_NADC) || defined(CONFIG_NUC970_NADC_MODULE)
+	&nuc970_device_nadc,
+#endif
+
+#if defined(CONFIG_NUC970_ETIMER) || defined(CONFIG_NUC970_ETIMER_MODULE)
+	&nuc970_device_etimer0,
+	&nuc970_device_etimer1,
+	&nuc970_device_etimer2,
+	&nuc970_device_etimer3,
+#endif
+#if defined(CONFIG_PINCTRL) || defined(CONFIG_PINCTRL_MODULE)
+	&nuc970_device_pinctrl,
+#endif
+#if defined(CONFIG_KEYBOARD_NUC970) || defined(CONFIG_KEYBOARD_NUC970_MODULE)
+	&nuc970_device_kpi,
+#endif
+#if defined(CONFIG_RTC_DRV_NUC970) || defined(CONFIG_RTC_DRV_NUC970_MODULE)
+	&nuc970_device_rtc,
+#endif
+#if defined(CONFIG_GPIO_NUC970) || defined(CONFIG_GPIO_NUC970_MODULE)
+	&nuc970_device_gpio,
+	#ifndef CONFIG_OF
+	&nuc970_device_eint0,
+	&nuc970_device_eint1,
+	&nuc970_device_eint2,
+	&nuc970_device_eint3,
+	&nuc970_device_eint4,
+	&nuc970_device_eint5,
+	&nuc970_device_eint6,
+	&nuc970_device_eint7,
+	#endif
+#endif
+#if defined(CONFIG_I2C_ALGOBIT) || defined(CONFIG_I2C_ALGOBIT_MODULE)
+	&i2c_gpio,
+#endif
+#if defined(CONFIG_NUC970_SC) || defined(CONFIG_NUC970_SC_MODULE) || defined(CONFIG_SCUART_NUC970) || defined(CONFIG_SCUART_NUC970_MODULE)
+	&nuc970_device_sc0,
+	&nuc970_device_sc1,
+#endif
+
+#if defined(CONFIG_NUC970_GE2D) || defined(CONFIG_NUC970_GE2D_MODULE)
+    &nuc970_device_ge2d,
+#endif
+
+#if defined(CONFIG_IIO_GPIO_TRIGGER) || defined(CONFIG_IIO_GPIO_TRIGGER_MODULE)
+    &iio_gpio_trigger,
+#endif
+#if defined(CONFIG_BACKLIGHT_PWM)
+    &nuc970_pwm_bl,
+#endif
+};
+
+
+void __init nuc970_platform_init(struct platform_device **device, int size)
+{
+	platform_add_devices(device, size);
+	platform_add_devices(nuc970_public_dev, ARRAY_SIZE(nuc970_public_dev));
+
+#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_SPI_SPIDEV) || defined(CONFIG_SPI_SPIDEV_MODULE)
+ 	/* register spi devices */
+#if defined(CONFIG_SPI_NUC970_P0) || defined(CONFIG_SPI_NUC970_P0_MODULE)
+	spi_register_board_info(nuc970_spi0_board_info, ARRAY_SIZE(nuc970_spi0_board_info));
+#endif
+#if defined(CONFIG_SPI_NUC970_P1) || defined(CONFIG_SPI_NUC970_P1_MODULE)
+    spi_register_board_info(nuc970_spi1_board_info, ARRAY_SIZE(nuc970_spi1_board_info));
+#endif
+#endif
+
+#if defined(CONFIG_I2C_BUS_NUC970_P0) || defined(CONFIG_I2C_BUS_NUC970_P0_MODULE)
+	i2c_register_board_info(0, nuc970_i2c_clients0, sizeof(nuc970_i2c_clients0)/sizeof(struct i2c_board_info));
+#endif
+
+#if defined(CONFIG_GPIO_NUC970) || defined(CONFIG_GPIO_NUC970_MODULE)
+#if defined(CONFIG_I2C_ALGOBIT) || defined(CONFIG_I2C_ALGOBIT_MODULE)
+	i2c_register_board_info(2, nuc970_i2c_clients2, sizeof(nuc970_i2c_clients2)/sizeof(struct i2c_board_info));
+#endif
+#endif
+
+#if defined(CONFIG_PWM_NUC970) || defined(CONFIG_PWM_NUC970_MODULE)
+	pwm_add_table(board_pwm_lookup, ARRAY_SIZE(board_pwm_lookup));
+#endif
+}
+
Index: linux-4.4.92/arch/arm/mach-nuc970/dt-generic.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/dt-generic.h
@@ -0,0 +1,41 @@
+/*
+ * arch/arm/mach-nuc970/dt-generic.h
+ *
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/reboot.h>
+#include <linux/clkdev.h>
+#include <linux/of.h>
+
+#ifndef __GENERIC_H__
+#define __GENERIC_H__
+
+extern void __init nuc970_map_io_dt(void);
+
+extern int  __init nuc970_aic_of_init(struct device_node *node,
+				    struct device_node *parent);
+
+extern void __init nuc970_dt_initialize(void);
+
+extern int __init nuc970_dt_clock_init(void);
+
+extern void nuc970_restart(/*char*/ enum reboot_mode mode, const char *cmd);
+
+extern void __init nuc970_timer_init_dt(void);
+
+
+#endif //__GENERIC_H__
+
Index: linux-4.4.92/arch/arm/mach-nuc970/dt-nuc972-evb.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/dt-nuc972-evb.c
@@ -0,0 +1,92 @@
+ /*
+ * linux/arch/arm/mach-nuc970/Board-dt-nuc972.c
+ *
+ * Copyright (C) 2014 Nuvoton technology corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/clk.h> 
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/gpio.h> 
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/pwm.h>
+
+#include <asm/setup.h>
+#include <asm/irq.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+#include <mach/map.h>
+#include <mach/mfp.h>
+
+#include <mach/irqs.h>
+#include <mach/regs-gcr.h>
+#include <mach/regs-aic.h>
+
+#include "cpu.h"
+#include "pm.h"
+#include "dt-generic.h"
+
+extern void nuc970_timer_init(void);
+extern void __init nuc970_map_io(void);
+extern int __init nuc970_of_init_irq(struct device_node *node, struct device_node *parent);
+
+
+static void __init nuc970_init_late(void)
+{
+	nuc970_init_suspend();
+}
+
+static void __init nuc970_dt_device_init(void)
+{
+    printk("<DT> %s +\n",__func__);
+    of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+    printk("<DT> %s -\n",__func__);
+}
+
+static const struct of_device_id irq_of_match[] __initconst = {
+	{ .compatible = "nuvoton,nuc970-aic", .data = nuc970_of_init_irq },
+	{ /*sentinel*/ }
+};
+
+static void __init nuc970_dt_init_irq(void)
+{
+	of_irq_init(irq_of_match);
+}
+
+static const char *nuc970_dt_board_compat[] __initdata = {
+    "nuvoton,nuc970",
+    "nuvoton,nuc972-evb",
+    NULL
+};
+
+DT_MACHINE_START(nuc970_dt, "Nuvoton NUC972 (Device Tree)")
+    .atag_offset    = 0x100,
+    .init_time      = nuc970_timer_init,
+    .map_io         = nuc970_map_io,
+ //   .init_early     = nuc970_dt_initialize,
+    .init_irq       = nuc970_dt_init_irq,
+    .init_machine   = nuc970_dt_device_init,
+    .dt_compat      = nuc970_dt_board_compat,
+	.init_late	    = nuc970_init_late,
+    .restart        = nuc970_restart,
+MACHINE_END
+
Index: linux-4.4.92/arch/arm/mach-nuc970/etime.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/etime.c
@@ -0,0 +1,302 @@
+/*
+ * linux/arch/arm/mach-nuc970/etime.c
+ *
+ *
+ * Copyright (c) 2017 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/leds.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+
+
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/clkdev.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+
+#include <mach/mfp.h>
+#include <mach/map.h>
+#include <mach/regs-timer.h>
+#include <mach/hardware.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-aic.h>
+#include <mach/regs-etimer.h>
+
+#define RESETINT	0x1f
+#define PERIOD		(0x01 << 4)
+#define ONESHOT		(0x00 << 4)
+#define COUNTEN		(0x01)
+#define INTEN		(0x01)
+
+#define TICKS_PER_SEC	100
+#define PRESCALE	0x63 /* Divider = prescale + 1 */
+
+#define	TDR_SHIFT	24
+#define	TDR_MASK	((1 << TDR_SHIFT) - 1)
+
+static unsigned int etimer0_load;
+
+static void nuc970_clockevent_setmode(enum clock_event_mode mode,
+		struct clock_event_device *clk)
+{
+	unsigned int val;
+
+	__raw_writel(INTEN, REG_ETMR_IER(0));
+	__raw_writel(PRESCALE, REG_ETMR_PRECNT(0));
+	val = __raw_readl(REG_ETMR_CTL(0));
+	val &= ~(0x03 << 4);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		__raw_writel(etimer0_load, REG_ETMR_CMPR(0));
+		val |= (PERIOD | COUNTEN);
+		break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		val |= (ONESHOT | COUNTEN);
+		break;
+
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_RESUME:
+		break;
+	}
+
+	__raw_writel(val, REG_ETMR_CTL(0));
+}
+
+static int nuc970_clockevent_setnextevent(unsigned long evt,
+		struct clock_event_device *clk)
+{
+	if(evt < 2)
+		evt = 2;
+	__raw_writel(evt, REG_ETMR_CMPR(0)); /* CMPR must greater or equal to 2 */
+	__raw_writel(__raw_readl(REG_ETMR_CTL(0)) | COUNTEN, REG_ETMR_CTL(0));
+
+ 	return 0;
+}
+#ifdef CONFIG_PM
+static int etmr0_msk;
+static void nuc970_clockevent_suspend(struct clock_event_device *clk)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if(__raw_readl(REG_AIC_IMRH) & (1 << 15)) {
+		etmr0_msk = 1;
+		__raw_writel(0x8000, REG_AIC_MDCRH);  //etimer0
+	} else
+		etmr0_msk = 0;
+
+	local_irq_restore(flags);
+
+	printk("clk event suspend\n");
+}
+
+static void nuc970_clockevent_resume(struct clock_event_device *clk)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if(etmr0_msk == 1)
+		__raw_writel(0x8000, REG_AIC_MECRH);  //etimer0
+	local_irq_restore(flags);
+
+	printk("clk event resume\n");
+}
+#endif
+static struct clock_event_device nuc970_clockevent_device = {
+	.name		= "nuc970-etimer0",
+	.shift		= 32,
+	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode	= nuc970_clockevent_setmode,
+	.set_next_event	= nuc970_clockevent_setnextevent,
+#ifdef CONFIG_PM
+	.suspend	= nuc970_clockevent_suspend,
+	.resume		= nuc970_clockevent_resume,
+#endif
+	.rating		= 300,
+};
+
+/*IRQ handler for the timer*/
+
+static irqreturn_t nuc970_etimer0_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &nuc970_clockevent_device;
+
+	__raw_writel(0x01, REG_ETMR_ISR(0)); /* clear TIF0 */
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction nuc970_etimer0_irq = {
+	.name		= "nuc970-etimer0",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= nuc970_etimer0_interrupt,
+};
+
+static void __init nuc970_clockevents_init(void)
+{
+	unsigned int rate;
+	struct clk *clk = clk_get(NULL, "etimer0");
+	struct clk *eclk = clk_get(NULL, "etmr0_eclk");
+
+	BUG_ON(IS_ERR(clk));
+	BUG_ON(IS_ERR(eclk));
+
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk_prepare(eclk);
+	clk_enable(eclk);
+	__raw_writel(0x00, REG_ETMR_CTL(0));
+
+	rate = clk_get_rate(eclk) / (PRESCALE + 1);
+
+	etimer0_load = (rate / TICKS_PER_SEC);
+
+	__raw_writel(RESETINT, REG_ETMR_ISR(0));
+	setup_irq(IRQ_ETIMER0, &nuc970_etimer0_irq);
+
+	nuc970_clockevent_device.mult = div_sc(rate, NSEC_PER_SEC,
+					nuc970_clockevent_device.shift);
+	nuc970_clockevent_device.max_delta_ns = clockevent_delta2ns(0xffffffff,
+					&nuc970_clockevent_device);
+	nuc970_clockevent_device.min_delta_ns = clockevent_delta2ns(0xf,
+					&nuc970_clockevent_device);
+	nuc970_clockevent_device.cpumask = cpumask_of(0);
+
+	clockevents_register_device(&nuc970_clockevent_device);
+}
+
+static cycle_t nuc970_get_cycles(struct clocksource *cs)
+{
+	return (__raw_readl(REG_ETMR_DR(1))) & TDR_MASK;
+}
+#ifdef CONFIG_PM
+static int etmr1_msk;
+static void nuc970_clocksource_suspend(struct clocksource *cs)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if(__raw_readl(REG_AIC_IMRH) & (1 << 16)) {
+		etmr1_msk = 1;
+		__raw_writel(0x10000, REG_AIC_MDCRH);  //timer1
+	} else
+		etmr1_msk = 0;
+
+	local_irq_restore(flags);
+
+	printk("clk source suspend\n");
+}
+
+static void nuc970_clocksource_resume(struct clocksource *cs)
+{
+	unsigned long flags;
+
+
+	local_irq_save(flags);
+	if(etmr1_msk == 1)
+		__raw_writel(0x10000, REG_AIC_MECRH);  //timer1
+	local_irq_restore(flags);
+
+	printk("clk source resume\n");
+}
+#endif
+static struct clocksource clocksource_nuc970 = {
+	.name	= "nuc970-timer1",
+	.rating	= 200,
+	.read	= nuc970_get_cycles,
+	.mask	= CLOCKSOURCE_MASK(TDR_SHIFT),
+	.shift	= 10,
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+#ifdef CONFIG_PM
+	.suspend	= nuc970_clocksource_suspend,
+	.resume		= nuc970_clocksource_resume,
+#endif
+};
+
+static void __init nuc970_clocksource_init(void)
+{
+	unsigned int val;
+	unsigned int rate = 0;
+
+	struct clk *clk = clk_get(NULL, "etimer1");
+	struct clk *eclk = clk_get(NULL, "etmr1_eclk");
+
+	BUG_ON(IS_ERR(clk));
+	BUG_ON(IS_ERR(eclk));
+
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk_prepare(eclk);
+	clk_enable(eclk);
+
+	__raw_writel(0x00, REG_ETMR_CTL(1));
+
+
+	rate = clk_get_rate(eclk) / (PRESCALE + 1);
+
+	__raw_writel(0xffffffff, REG_ETMR_CMPR(1));
+	__raw_writel(PRESCALE, REG_ETMR_PRECNT(1));
+	val = __raw_readl(REG_ETMR_CTL(1));
+	val |= (COUNTEN | PERIOD);
+	__raw_writel(val, REG_ETMR_CTL(1));
+
+	clocksource_nuc970.mult =
+		clocksource_khz2mult((rate / 1000), clocksource_nuc970.shift);
+	clocksource_register(&clocksource_nuc970);
+}
+
+void __init nuc970_setup_default_serial_console(void)
+{
+	struct clk *clk = clk_get(NULL, "uart0");
+
+	BUG_ON(IS_ERR(clk));
+
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	/* GPE0, GPE1 */
+	nuc970_mfp_set_port_e(0, 0x9);
+	nuc970_mfp_set_port_e(1, 0x9);
+}
+
+extern int nuc970_init_clocks(void);
+void __init nuc970_timer_init(void)
+{
+	nuc970_init_clocks();
+	nuc970_clocksource_init();
+	nuc970_clockevents_init();
+	nuc970_setup_default_serial_console();
+}
Index: linux-4.4.92/arch/arm/mach-nuc970/fiq.S
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/fiq.S
@@ -0,0 +1,35 @@
+/*
+ * Timer FIQ handler
+ *
+ * Copyright (C) 2015 Nuvoton
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+
+	.text
+	.global fiq_handler_end
+
+ENTRY(fiq_handler)
+    stmdb	sp!, {r0-r12, lr}
+    
+    @ branch to c handler
+    blx     r8
+    
+    @ read REG_AIC_IPER
+    ldr     r12, [r10]
+   
+    @ write 0x1 to REG_AIC_EOSCR
+    mov     r12, #0x1
+    add     r11, r10, #0x38
+    str     r12, [r11]
+        
+	/* return from FIQ */
+	ldmia	sp!, {r0-r12, lr}
+    subs	pc, lr, #4   
+    
+fiq_handler_end:
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/clkdev.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/clkdev.h
@@ -0,0 +1,7 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/debug-macro.S
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/debug-macro.S
@@ -0,0 +1,67 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/debug-macro.S
+ *
+ *  Copyright (C) 2017 Nuvoton Technology Corp.
+ *
+ * Debugging macro include header
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <mach/hardware.h>
+
+#define CLK_PCLKEN0	0xB0000218
+#define SYS_GPE_MFPL	0xB0000090
+#define UART_REG_THR	0x00
+#define UART_REG_FSR	0x18
+#define TX_EMPTY	0x00400000
+#define TE_FLAG		0x10000000
+
+#define TX_IDLE		(TX_EMPTY | TE_FLAG)
+
+	.macro	addruart, rp, rv, tmp
+	adr	\rp, 8f					@ get effective addr of 8f
+	ldr	\rv, [\rp]				@ get absolute addr of 8f
+	sub	\rv, \rv, \rp				@ offset between the two
+	ldr	\rp, [\rp, #4]				@ abs addr of uart_init
+	sub	\tmp, \rp, \rv				@ make it effective
+	ldr	\rp, [\tmp, #0]				@ uart_init val
+	cmp	\rp, #1					@ CLK/MFP configured?
+	bne	6f
+	mov	\rp, #0
+	str	\rp, [\tmp, #0]		
+	ldr	\tmp, =CLK_PCLKEN0			@ Enable UART0 CLK
+	ldr	\rp, [\tmp, #0]
+	orr	\rp, \rp, #0x10000
+	str	\rp, [\tmp, #0]
+	ldr	\tmp, =SYS_GPE_MFPL			@ Enable UART0 MFP
+	mov	\rp, #0x99
+	str	\rp, [\tmp, #0]
+
+6:	ldr	\rp, =NUC970_PA_UART			@ Physical address
+	ldr	\rv, =NUC970_VA_UART			@ Virtual address
+	b	168f
+	.align
+8:	.word	.
+	.word	nuc970_uart_init
+	.ltorg
+168:
+	.endm
+
+	.macro	senduart,rd,rx	
+	str	\rd, [\rx, #(UART_REG_THR)]		@ Write to Tx FIFO
+	.endm
+
+	.macro	waituart,rd,rx				@ Do nothing
+	.endm
+
+	.macro	busyuart,rd,rx
+1688:	ldr	\rd, [\rx, #(UART_REG_FSR)]		@ Read FIFO Status Register
+	and	\rd, \rd, #TX_IDLE
+	tst	\rd, #TX_IDLE
+	beq	1688b
+	.endm
+
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/drvjpeg.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/drvjpeg.h
@@ -0,0 +1,349 @@
+/* drvjpeg.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __DRVJPEG_H__
+#define __DRVJPEG_H__
+
+//Include header file
+
+#define outp32(addr,value)		__raw_writel((value), (addr))
+#define inp32(addr)				__raw_readl(addr)
+
+
+#define DRVJPEG_ENC_PRIMARY		0
+#define DRVJPEG_ENC_THUMBNAIL	1
+
+//Define for Interrupt Status
+#define DRVJPEG_EER_INTS	ERR_INTS
+#define DRVJPEG_DER_INTS	DER_INTS
+#define DRVJPEG_DEC_INTS	DEC_INTS
+#define DRVJPEG_ENC_INTS	ENC_INTS
+#define DRVJPEG_DHE_INTS	DHE_INTS
+#define DRVJPEG_IPW_INTS	IPW_INTS
+//#define DRVJPEG_DOW_INTS	JPG_DOW_INTS
+#define DRVJPEG_DOW_INTS	OPW_INTS
+#define JPG_DOW_INTS		OPW_INTS
+
+//Define for Scaling
+#define DRVJPEG_ENC_UPSCALE_MODE			0
+#define DRVJPEG_DEC_PACKET_DOWNSCALE_MODE	1
+#define DRVJPEG_DEC_PLANAR_DOWNSCALE_MODE	2
+#define DRVJPEG_ENC_PLANAR_DOWNSCALE_MODE	3
+	
+//Define for Interrupt Enable
+#define DRVJPEG_EER_INTE	ERR_INTE
+#define DRVJPEG_DER_INTE	DER_INTE
+#define DRVJPEG_DEC_INTE	DEC_INTE
+#define DRVJPEG_ENC_INTE	ENC_INTE
+#define DRVJPEG_DHE_INTE	DHE_INTE
+#define DRVJPEG_IPW_INTE	IPW_INTE
+//#define DRVJPEG_DOW_INTE	JPG_DOW_INTE
+#define DRVJPEG_DOW_INTE	OPW_INTE
+
+//Define for Encode input Format
+#define DRVJPEG_ENC_SOURCE_PLANAR	0
+#define DRVJPEG_ENC_SOURCE_PACKET	1
+
+//Version definition
+
+
+//Export functions
+#define _DRVJPEG_SET_YADDR(u32Address)				outp32(REG_JYADDR0, u32Address)				
+#define _DRVJPEG_SET_UADDR(u32Address)				outp32(REG_JUADDR0, u32Address)
+#define _DRVJPEG_SET_VADDR(u32Address)				outp32(REG_JVADDR0, u32Address)
+#define _DRVJPEG_GET_YADDR()						inp32(REG_JYADDR0)				
+#define _DRVJPEG_GET_UADDR()						inp32(REG_JUADDR0)
+#define _DRVJPEG_GET_VADDR()						inp32(REG_JVADDR0)
+#define _DRVJPEG_SET_YSTRIDE(u32Stride)				outp32(REG_JYSTRIDE, u32Stride)	
+#define _DRVJPEG_SET_USTRIDE(u32Stride)				outp32(REG_JUSTRIDE, u32Stride)	
+#define _DRVJPEG_SET_VSTRIDE(u32Stride)				outp32(REG_JVSTRIDE, u32Stride)	
+#define _DRVJPEG_GET_YSTRIDE()						inp32(REG_JYSTRIDE)	
+#define _DRVJPEG_GET_USTRIDE()						inp32(REG_JUSTRIDE)
+#define _DRVJPEG_GET_VSTRIDE()						inp32(REG_JVSTRIDE)
+#define _DRVJPEG_SET_BITSTREAM_ADDR(u32Address)		outp32(REG_JIOADDR0,u32Address)	
+#define _DRVJPEG_GET_BITSTREAM_ADDR()				inp32(REG_JIOADDR0)
+#define _DRVJPEG_SET_ENC_DEC(u8Mode)			outp32(REG_JMCR, (inp32(REG_JMCR) & ~ENC_DEC) | (u8Mode << 7));
+
+//Encode
+#define _DRVJPEG_GET_ENC_PRIMARY_BITSTREAM_SIZE()	inp32(REG_JPRI_SIZE)	
+#define _DRVJPEG_GET_ENC_THUMBNAIL_BITSTREAM_SIZE()	inp32(REG_JTHB_SIZE)	
+#define _DRVJPEG_SET_SOURCE_IMAGE_HEIGHT(u16Size)	outp32(REG_JSRCH,u16Size)	
+#define _DRVJPEG_GET_SOURCE_IMAGE_HEIGHT()			inp32(REG_JSRCH)	
+#define _DRVJPEG_ENC_ENABLE_UPSCALING()				outp32(REG_JPSCALU,inp32(REG_JPSCALU) | JPSCALU_8X)	
+#define _DRVJPEG_ENC_DISABLE_UPSCALING()			outp32(REG_JPSCALU,inp32(REG_JPSCALU) & ~JPSCALU_8X)	
+#define _DRVJPEG_ENC_ISENABLE_UPSCALING()			((inp32(REG_JPSCALU) & JPSCALU_8X) >> 6)
+#define _DRVJPEG_ENC_SET_HEADER_CONTROL(u8Control)	outp32(REG_JHEADER, u8Control)
+#define _DRVJPEG_ENC_GET_HEADER_CONTROL()			inp32(REG_JHEADER)
+#define _DRVJPEG_ENC_SET_RDI_VALUE(u8Value)			outp32(REG_JPRST,u8Value)
+#define _DRVJPEG_ENC_GET_RDI_VALUE()				inp32(REG_JPRST)
+
+//Decode
+#define _DRVJPEG_DEC_ENABLE_DOWNSCALING()			outp32(REG_JPSCALD,PSX_ON)	
+#define _DRVJPEG_DEC_ISENABLE_DOWNSCALING()			((inp32(REG_JPSCALD) & PSX_ON) >> 15) 	
+#define _DRVJPEG_DEC_DISABLE_DOWNSCALING()			outp32(REG_JPSCALD,~PSX_ON)	
+#define _DRVJPEG_DEC_GET_DECODED_IMAGE_FORMAT()		(inp32(REG_JITCR) & DYUV_MODE)
+#define _DRVJPEG_DEC_ENABLE_LOW_PASS_FILTER()		outp32(REG_JPSCALD,inp32(REG_JPSCALD) | PS_LPF_ON) 
+#define _DRVJPEG_DEC_DISABLE_LOW_PASS_FILTER()		outp32(REG_JPSCALD,inp32(REG_JPSCALD) & ~PS_LPF_ON) 
+#define _DRVJPEG_DEC_ISENABLE_LOW_PASS_FILTER()		((inp32(REG_JPSCALD) & PS_LPF_ON) >> 14)
+#define _DRVJPEG_DEC_SET_INPUT_WAIT(u16Size)		outp32(REG_JMACR, 0x00400008 | ((u16Size & 0x3FF)<< 8) );
+#define _DRVJPEG_DEC_RESUME_INPUT_WAIT()			outp32(REG_JMCR,inp32(REG_JMCR)|RESUMEI);
+#define _DRVJPEG_DEC_DISABLE_WINDOWDECODE()			outp32(REG_JMCR, inp32(REG_JMCR) & ~(WIN_DEC));
+//Interrupt
+#define _DRVJPEG_INT_ENABLE(u32Intflag)				outp32(REG_JINTCR, u32Intflag)
+#define _DRVJPEG_INT_DISABLE(u32Intflag)			outp32(REG_JINTCR, inp32 (REG_JINTCR) & ~(u32Intflag))
+#define _DRVJPEG_GET_INT_STATUS()					inp32 (REG_JINTCR)
+#define _DRVJPEG_CLEAR_INT(u32Intflag)				outp32(REG_JINTCR, (inp32 (REG_JINTCR) & ~0xFF) | u32Intflag)
+
+//Define inline function
+
+__s32 nuc970_Jpeg_Open(void);
+
+static __inline
+void nuc970_Jpeg_Close(void)
+{
+	outp32(REG_CLK_HCLKEN, (inp32(REG_CLK_HCLKEN) & ~(1<<29)));
+}
+void nuc970_Jpeg_Init(void);
+
+void nuc970_Jpeg_Trigger(void);
+
+__s32
+nuc970_Jpeg_SetEncodeMode(
+	__u8 u8SourceFormat,
+	__u16 u16JpegFormat
+);
+
+__s32
+nuc970_Jpeg_SetDecodeMode(
+	__u32 u32OutputFormat
+);
+
+__s32 nuc970_Jpeg_CalScalingFactor(
+	__u8	u8Mode,						//Up / Down Scaling
+	__u16	u16Height,					//Original Height
+	__u16	u16Width,					//Original Width
+	__u16	u16ScalingHeight,			//Scaled Height
+	__u16	u16ScalingWidth,			//Scaled Width
+	__u16*	pu16RatioH,					//Horizontal Ratio
+	__u16*	pu16RatioW					//Vertical Ratio		
+);
+
+__s32 nuc970_Jpeg_SetScalingFactor(
+	__u8	u8Mode,					//Up / Down Scaling
+	__u16	u16FactorH,				//Vertical Scaling Factor
+	__u16	u16FactorW				//Horizontal Scaling Factor
+);
+
+void nuc970_Jpeg_GetDecodedDimension(
+	__u16* pu16Height,			//Decode/Encode Height
+	__u16*	pu16Width			//Decode/Encode Width
+);
+
+void nuc970_Jpeg_SetDimension(
+	__u16 u16Height,			//Decode/Encode Height
+	__u16 u16Width				//Decode/Encode Width
+);
+
+void nuc970_Jpeg_GetDimension(
+	__u16* pu16Height,			//Decoded Height from bit stream
+	__u16*	pu16Width			//Decoded Width  from bit stream
+);
+
+void nuc970_Jpeg_GetScalingFactor(
+	__u8	u8Mode,				//Up / Down Scaling
+	__u16* pu16FactorH,		//Vertical Scaling Factor
+	__u16*	pu16FactorW			//Horizontal Scaling Factor
+);
+
+__s32
+nuc970_Jpeg_SetWindowDecode(	
+	__u16	u16StartMCUX,	//Start X MCU
+	__u16	u16StartMCUY,	//Horizontal Scaling Factor
+	__u16	u16EndMCUX,		//Vertical Scaling Factor
+	__u16	u16EndMCUY,		//Horizontal Scaling Factor	
+	__u32	u32Stride		//Decode Output Stride
+);
+
+__s32
+nuc970_Jpeg_AdjustQTAB(
+	__u8 u8Mode,
+	__u8 u8Qadjust,
+	__u8 u8Qscaling
+);
+
+__s32
+nuc970_Jpeg_SetQTAB(
+	__u8* puQTable0,
+	__u8* puQTable1,
+	__u8* puQTable2,
+	__u8 u8num);
+
+__u32 nuc970_Jpeg_GetVersion(void);
+
+
+typedef enum jpeg_state{
+	JPEG_IDLE = 1,
+	JPEG_ENCODING = 2,
+	JPEG_ENCODED_IMAGE = 3,
+	JPEG_DECODING = 9,
+	JPEG_DECODED_HEADER = 10,
+	JPEG_DECODED_IMAGE = 11,
+	JPEG_DECODE_ERROR = 12,
+	JPEG_MEM_SHORTAGE = 15,
+	JPEG_DECODE_PARAM_ERROR = 13,
+	JPEG_ENCODE_PARAM_ERROR = 14,
+	JPEG_CLOSED = 20,
+}jpeg_state_t;
+
+#define IS_ENCODE(state)	(state >=JPEG_ENCODING && state <JPEG_DECODING)
+#define IS_DECODE(state)	(state >=JPEG_DECODING)
+#define IS_DECODED(state)	((state == JPEG_DECODED_IMAGE) || (state==JPEG_DECODE_ERROR))
+#define IS_ENCODED(state)	(state == JPEG_ENCODED_IMAGE)
+#define IS_FINISHED(state) (IS_DECODED(state) || IS_ENCODED(state))
+
+typedef struct jpeg_param{
+	/*for get/set parameters*/
+	__u32	vaddr_src;
+	__u32	decopw_vaddr;
+	__u32	decopw_en;
+	__u32	decopw_TargetBuffersize;
+	__u32	vaddr_dst;
+	__u32	paddr_src;
+	__u32	paddr_dst;
+	__u32	src_bufsize;
+	__u32	dst_bufsize;
+	__u32	dec_stride;
+	__u32	windec_en;
+	__u32	windec_mcux_start;
+	__u32	windec_mcux_end;
+	__u32	windec_mcuy_start;
+	__u32	windec_mcuy_end;
+	__u32	windec_stride;
+	/*for set only*/
+	__u32	decode_output_format;//DRVJPEG_DEC_PRIMARY_PACKET_YUV422,
+	__u32	encode;//1 decode, 0 encode	
+	__u32	scale;	//1 enable, 0 disable
+	/* encode / decode scale */
+	__u32	scaled_width;
+	__u32	scaled_height;
+	__u32	decInWait_buffer_size;	
+	/*encode parameters for set only*/
+	__u32	encode_width;/*the width that will be encoded image raw data*/
+	__u32	encode_height;/*the height that will be encoded image raw data*/
+	__u8	qadjust;//the larger the better quality[2-16](0.25Q, 0.5Q, 0.75Q, Q, 1.25Q, 1.5Q, 1.75Q, 2Q, 2.25Q, 2.5Q, 2.75Q, 3Q, 3.25Q, 3.5Q, 3.75Q) 
+	__u8	qscaling;//the smaller the better quality[1-16]
+	__u32	encode_source_format;
+	__u32	encode_image_format;
+    __u32	buffersize;/*each encode buffer size*/
+    __u32	buffercount;/*total encode buffer count*/
+}jpeg_param_t;
+
+//Define for Encode application
+#define DRVJPEG_ENC_THUMBNAIL_QVGA	0
+#define DRVJPEG_ENC_THUMBNAIL_QQVGA	1
+
+typedef struct jpeg_info{
+	/*decode information*/
+	__u32	yuvformat;	/*for decode*/
+	__u32	width;		/*for decode*/
+    __u32	height;		/*for decode*/
+	__u32	dec_stride;
+    /*encode information*/	
+    __u32	bufferend;
+    __u32	state;
+    __u32	image_size[]; /*image size after encoded*/
+}jpeg_info_t;
+
+//Define for Decode Output Format
+#define DRVJPEG_DEC_PRIMARY_PLANAR_YUV		0x8021//(PLANAR_ON | PDHTAB | DHEND)
+#define DRVJPEG_DEC_PRIMARY_PACKET_YUV422	0x0021//(PDHTAB | DHEND)
+#define DRVJPEG_DEC_PRIMARY_PACKET_RGB555	0x004021//(PDHTAB | DHEND | ORDER)
+#define DRVJPEG_DEC_PRIMARY_PACKET_RGB565	0x006021//(PDHTAB | DHEND | RGB555_565 | ORDER )
+#define DRVJPEG_DEC_PRIMARY_PACKET_RGB555R1	0x404021//(PDHTAB | DHEND | ORDER)
+#define DRVJPEG_DEC_PRIMARY_PACKET_RGB565R1	0x406021//(PDHTAB | DHEND | RGB555_565 | ORDER )
+#define DRVJPEG_DEC_PRIMARY_PACKET_RGB565R2	0x806021//(PDHTAB | DHEND | RGB555_565 | ORDER )
+#define DRVJPEG_DEC_PRIMARY_PACKET_RGB555R2	0x804021//(PDHTAB | DHEND | ORDER)
+#define DRVJPEG_DEC_PRIMARY_PACKET_RGB888	0x14021//(PDHTAB | DHEND | ORDER | ARGB888)
+
+#define DRVJPEG_DEC_SOFTWARE_RGB555	        0xFFF0//(PDHTAB | DHEND | ORDER)
+#define DRVJPEG_DEC_SOFTWARE_RGB565	        0xFFF1//(PDHTAB | DHEND | ORDER)
+
+#define DRVJPEG_DEC_THUMBNAIL_PLANAR_YUV	0x8011//(PLANAR_ON | DTHB | PDHTAB)
+#define DRVJPEG_DEC_THUMBNAIL_PACKET_YUV422	0x0031//(DTHB | PDHTAB | DHEND)
+#define DRVJPEG_DEC_THUMBNAIL_PACKET_RGB555	0x4031//(DTHB | PDHTAB | DHEND | ORDER)
+
+//Define for Encode Image Format
+#define DRVJPEG_ENC_PRIMARY_YUV420		0xA0
+#define DRVJPEG_ENC_PRIMARY_YUV422		0xA8
+#define DRVJPEG_ENC_PRIMARY_GRAY		0xA1
+#define DRVJPEG_ENC_THUMBNAIL_YUV420	0x90
+#define DRVJPEG_ENC_THUMBNAIL_YUV422	0x98
+#define DRVJPEG_ENC_THUMBNAIL_GRAY		0x91
+
+//Define for Decode Image Format
+#define DRVJPEG_DEC_YUV420		0x000
+#define DRVJPEG_DEC_YUV422		0x100
+#define DRVJPEG_DEC_YUV444		0x200
+#define DRVJPEG_DEC_YUV411		0x300
+#define DRVJPEG_DEC_GRAY		0x400
+#define DRVJPEG_DEC_YUV422T		0x500
+
+//Define for Encode input Format
+#define DRVJPEG_ENC_SRC_PLANAR	0
+#define DRVJPEG_ENC_SRC_PACKET	1
+
+//Define for Encode Image Header
+#define DRVJPEG_ENC_PRIMARY_DRI		P_DRI
+#define DRVJPEG_ENC_PRIMARY_QTAB	P_QTAB
+#define DRVJPEG_ENC_PRIMARY_HTAB	P_HTAB
+#define DRVJPEG_ENC_PRIMARY_JFIF	P_JFIF
+#define DRVJPEG_ENC_THUMBNAIL_DRI	T_DRI
+#define DRVJPEG_ENC_THUMBNAIL_QTAB	T_QTAB
+#define DRVJPEG_ENC_THUMBNAIL_HTAB	T_HTAB
+#define DRVJPEG_ENC_THUMBNAIL_JFIF	T_JFIF
+
+#define JPEG_DECIPW_BUFFER_EMPTY 	1
+#define JPEG_DECIPW_BUFFER_NOT_EMPTY 	0
+
+#define JPEG_TRIGGER			_IOW('v',120, struct jpeg_param)
+#define JPEG_S_PARAM			_IOW('v',121, struct jpeg_param)
+#define JPEG_G_PARAM			_IOW('v',122, struct jpeg_param)
+#define JPEG_STATE			_IOR('v',123, struct jpeg_param)
+#define JPEG_G_INFO			_IOR('v',124, struct jpeg_info)
+#define JPEG_DECIPW_BUFFER_STATE	_IOR('v',125, __u32)
+#define JPEG_G_DECIPW_BUFFER_SIZE	_IOR('v',126, __u32)
+#define JPEG_DECODE_RESUME		_IOR('v',127, __u32)		
+#define JPEG_S_DECOPW			_IOW('v',128,  __u32)	
+#define JPEG_GET_JPEG_BUFFER		_IOR('v',129, __u32)
+#define JPEG_SET_ENCOCDE_RESERVED	_IOW('v',130,  __u32)
+//#define JPEG_SET_ENC_SRC_FROM_VIN	_IOW('v',131,  __u32)
+#define JPEG_FLUSH_CACHE		_IOW('v',132,  __u32)
+#define JPEG_SET_ENC_THUMBNAIL		_IOW('v',133, __u32)
+#define JPEG_GET_ENC_THUMBNAIL_SIZE	_IOW('v',134, __u32)
+#define JPEG_GET_ENC_THUMBNAIL_OFFSET	_IOW('v',135, __u32)
+#define JPEG_SET_ENC_STRIDE		_IOW('v',136, __u32)
+#define JPEG_SET_ENC_USER_QTABLE0	_IOW('v',137, __u32)
+#define JPEG_SET_ENC_USER_QTABLE1	_IOW('v',138, __u32)
+#define JPEG_ACTIVE_ENC_DEFAULTQTABLE	_IOW('v',139, __u32)
+#define JPEG_ACTIVE_ENC_USER_QTABLE	_IOW('v',140, __u32)
+#define JPEG_SET_ENC_USER_YADDRESS	_IOW('v',141,  __u32)
+#define JPEG_SET_ENC_USER_UADDRESS	_IOW('v',142,  __u32)
+#define JPEG_SET_ENC_USER_VADDRESS	_IOW('v',143,  __u32)
+
+
+#endif
+
+
+
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/entry-macro.S
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/entry-macro.S
@@ -0,0 +1,30 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/entry-macro.S
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corp. 
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+#include <mach/map.h>
+#include <mach/regs-aic.h>
+
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+		mov	\base, #AIC_BA
+
+		ldr	\irqnr, [\base, #AIC_IPER]
+		ldr	\irqnr, [\base, #AIC_ISNR]
+		cmp	\irqnr, #0
+
+	.endm
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/gpio.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/gpio.h
@@ -0,0 +1,187 @@
+/*
+ *  Nuvoton NUC970 GPIO API definitions
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ */
+
+#ifndef __ASM_MACH_NUC970_GPIO_H
+#define __ASM_MACH_NUC970_GPIO_H
+
+#define ARCH_NR_GPIOS		512
+#include <mach/irqs.h>
+#include <linux/interrupt.h>
+#include <asm-generic/gpio.h>
+
+#define	NUC970_PA0	(0x00 + 0)
+#define	NUC970_PA1	(0x00 + 1)
+#define	NUC970_PA2	(0x00 + 2)
+#define	NUC970_PA3	(0x00 + 3)
+#define	NUC970_PA4	(0x00 + 4)
+#define	NUC970_PA5	(0x00 + 5)
+#define	NUC970_PA6	(0x00 + 6)
+#define	NUC970_PA7	(0x00 + 7)
+#define	NUC970_PA8	(0x00 + 8)
+#define	NUC970_PA9	(0x00 + 9)
+#define	NUC970_PA10	(0x00 + 10)
+#define	NUC970_PA11	(0x00 + 11)
+#define	NUC970_PA12	(0x00 + 12)
+#define	NUC970_PA13	(0x00 + 13)
+#define	NUC970_PA14	(0x00 + 14)
+#define	NUC970_PA15	(0x00 + 15)
+
+#define	NUC970_PB0	(0x20 + 0)
+#define	NUC970_PB1	(0x20 + 1)
+#define	NUC970_PB2	(0x20 + 2)
+#define	NUC970_PB3	(0x20 + 3)
+#define	NUC970_PB4	(0x20 + 4)
+#define	NUC970_PB5	(0x20 + 5)
+#define	NUC970_PB6	(0x20 + 6)
+#define	NUC970_PB7	(0x20 + 7)
+#define	NUC970_PB8	(0x20 + 8)
+#define	NUC970_PB9	(0x20 + 9)
+#define	NUC970_PB10	(0x20 + 10)
+#define	NUC970_PB11	(0x20 + 11)
+#define	NUC970_PB12	(0x20 + 12)
+#define	NUC970_PB13	(0x20 + 13)
+#define	NUC970_PB14	(0x20 + 14)
+#define	NUC970_PB15	(0x20 + 15)
+
+#define	NUC970_PC0	(0x40 + 0)
+#define	NUC970_PC1	(0x40 + 1)
+#define	NUC970_PC2	(0x40 + 2)
+#define	NUC970_PC3	(0x40 + 3)
+#define	NUC970_PC4	(0x40 + 4)
+#define	NUC970_PC5	(0x40 + 5)
+#define	NUC970_PC6	(0x40 + 6)
+#define	NUC970_PC7	(0x40 + 7)
+#define	NUC970_PC8	(0x40 + 8)
+#define	NUC970_PC9	(0x40 + 9)
+#define	NUC970_PC10	(0x40 + 10)
+#define	NUC970_PC11	(0x40 + 11)
+#define	NUC970_PC12	(0x40 + 12)
+#define	NUC970_PC13	(0x40 + 13)
+#define	NUC970_PC14	(0x40 + 14)
+#define	NUC970_PC15	(0x40 + 15)
+
+#define	NUC970_PD0	(0x60 + 0)
+#define	NUC970_PD1	(0x60 + 1)
+#define	NUC970_PD2	(0x60 + 2)
+#define	NUC970_PD3	(0x60 + 3)
+#define	NUC970_PD4	(0x60 + 4)
+#define	NUC970_PD5	(0x60 + 5)
+#define	NUC970_PD6	(0x60 + 6)
+#define	NUC970_PD7	(0x60 + 7)
+#define	NUC970_PD8	(0x60 + 8)
+#define	NUC970_PD9	(0x60 + 9)
+#define	NUC970_PD10	(0x60 + 10)
+#define	NUC970_PD11	(0x60 + 11)
+#define	NUC970_PD12	(0x60 + 12)
+#define	NUC970_PD13	(0x60 + 13)
+#define	NUC970_PD14	(0x60 + 14)
+#define	NUC970_PD15	(0x60 + 15)
+
+#define	NUC970_PE0	(0x80 + 0)
+#define	NUC970_PE1	(0x80 + 1)
+#define	NUC970_PE2	(0x80 + 2)
+#define	NUC970_PE3	(0x80 + 3)
+#define	NUC970_PE4	(0x80 + 4)
+#define	NUC970_PE5	(0x80 + 5)
+#define	NUC970_PE6	(0x80 + 6)
+#define	NUC970_PE7	(0x80 + 7)
+#define	NUC970_PE8	(0x80 + 8)
+#define	NUC970_PE9	(0x80 + 9)
+#define	NUC970_PE10	(0x80 + 10)
+#define	NUC970_PE11	(0x80 + 11)
+#define	NUC970_PE12	(0x80 + 12)
+#define	NUC970_PE13	(0x80 + 13)
+#define	NUC970_PE14	(0x80 + 14)
+#define	NUC970_PE15	(0x80 + 15)
+
+#define	NUC970_PF0	(0xA0 + 0)
+#define	NUC970_PF1	(0xA0 + 1)
+#define	NUC970_PF2	(0xA0 + 2)
+#define	NUC970_PF3	(0xA0 + 3)
+#define	NUC970_PF4	(0xA0 + 4)
+#define	NUC970_PF5	(0xA0 + 5)
+#define	NUC970_PF6	(0xA0 + 6)
+#define	NUC970_PF7	(0xA0 + 7)
+#define	NUC970_PF8	(0xA0 + 8)
+#define	NUC970_PF9	(0xA0 + 9)
+#define	NUC970_PF10	(0xA0 + 10)
+#define	NUC970_PF11	(0xA0 + 11)
+#define	NUC970_PF12	(0xA0 + 12)
+#define	NUC970_PF13	(0xA0 + 13)
+#define	NUC970_PF14	(0xA0 + 14)
+#define	NUC970_PF15	(0xA0 + 15)
+
+#define	NUC970_PG0	(0xC0 + 0)
+#define	NUC970_PG1	(0xC0 + 1)
+#define	NUC970_PG2	(0xC0 + 2)
+#define	NUC970_PG3	(0xC0 + 3)
+#define	NUC970_PG4	(0xC0 + 4)
+#define	NUC970_PG5	(0xC0 + 5)
+#define	NUC970_PG6	(0xC0 + 6)
+#define	NUC970_PG7	(0xC0 + 7)
+#define	NUC970_PG8	(0xC0 + 8)
+#define	NUC970_PG9	(0xC0 + 9)
+#define	NUC970_PG10	(0xC0 + 10)
+#define	NUC970_PG11	(0xC0 + 11)
+#define	NUC970_PG12	(0xC0 + 12)
+#define	NUC970_PG13	(0xC0 + 13)
+#define	NUC970_PG14	(0xC0 + 14)
+#define	NUC970_PG15	(0xC0 + 15)
+
+#define	NUC970_PH0	(0xE0 + 0)
+#define	NUC970_PH1	(0xE0 + 1)
+#define	NUC970_PH2	(0xE0 + 2)
+#define	NUC970_PH3	(0xE0 + 3)
+#define	NUC970_PH4	(0xE0 + 4)
+#define	NUC970_PH5	(0xE0 + 5)
+#define	NUC970_PH6	(0xE0 + 6)
+#define	NUC970_PH7	(0xE0 + 7)
+#define	NUC970_PH8	(0xE0 + 8)
+#define	NUC970_PH9	(0xE0 + 9)
+#define	NUC970_PH10	(0xE0 + 10)
+#define	NUC970_PH11	(0xE0 + 11)
+#define	NUC970_PH12	(0xE0 + 12)
+#define	NUC970_PH13	(0xE0 + 13)
+#define	NUC970_PH14	(0xE0 + 14)
+#define	NUC970_PH15	(0xE0 + 15)
+
+#define	NUC970_PI0	(0x100 + 0)
+#define	NUC970_PI1	(0x100 + 1)
+#define	NUC970_PI2	(0x100 + 2)
+#define	NUC970_PI3	(0x100 + 3)
+#define	NUC970_PI4	(0x100 + 4)
+#define	NUC970_PI5	(0x100 + 5)
+#define	NUC970_PI6	(0x100 + 6)
+#define	NUC970_PI7	(0x100 + 7)
+#define	NUC970_PI8	(0x100 + 8)
+#define	NUC970_PI9	(0x100 + 9)
+#define	NUC970_PI10	(0x100 + 10)
+#define	NUC970_PI11	(0x100 + 11)
+#define	NUC970_PI12	(0x100 + 12)
+#define	NUC970_PI13	(0x100 + 13)
+#define	NUC970_PI14	(0x100 + 14)
+#define	NUC970_PI15	(0x100 + 15)
+
+#define	NUC970_PJ0	(0x120 + 0)
+#define	NUC970_PJ1	(0x120 + 1)
+#define	NUC970_PJ2	(0x120 + 2)
+#define	NUC970_PJ3	(0x120 + 3)
+#define	NUC970_PJ4	(0x120 + 4)
+
+typedef struct nuc970_eint_pins{
+	u32	pin;
+	irq_handler_t handler;
+        u32   trigger;
+        char *name;
+}eint_wakeup_pins;
+
+
+
+#endif /* __ASM_MACH_NUC970_GPIO_H*/
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/hardware.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/hardware.h
@@ -0,0 +1,27 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/hardware.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <mach/map.h>
+
+#define CONFIG_NO_MULTIWORD_IO
+
+#endif /* __ASM_ARCH_HARDWARE_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/iic.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/iic.h
@@ -0,0 +1,51 @@
+/*linux/include/asm-arm/arch-nuc970/iic.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+ 
+ 
+#ifndef __ASM_ARCH_IIC_H
+#define __ASM_ARCH_IIC_H __FILE__
+ 
+ 
+ struct nuc970_platform_i2c 
+ {
+         unsigned int    flags;
+         unsigned int    slave_addr;     // slave address for controller 
+         unsigned long   bus_freq;       // standard bus frequency 
+         unsigned long   max_freq;       // max frequency for the bus 
+         unsigned long   min_freq;       // min frequency for the bus 
+         unsigned int	 channel;		 // i2c channel number
+         unsigned int	 bus_num;		 // i2c bus number
+ };
+
+/* bit map in CMDR */
+#define I2C_CMD_START			0x10
+#define I2C_CMD_STOP			0x08
+#define I2C_CMD_READ			0x04
+#define I2C_CMD_WRITE			0x02
+#define I2C_CMD_NACK			0x01
+
+/* for transfer use */
+#define I2C_WRITE				0x00
+#define I2C_READ				0x01
+
+#define I2C_STATE_NOP			0x00
+#define I2C_STATE_READ			0x01
+#define I2C_STATE_WRITE			0x02
+#define I2C_STATE_PROBE			0x03
+
+extern void nuc900_enable_group_irq(int src);
+extern void mfp_set_groupg(struct device *dev);
+ 
+#endif // __ASM_ARCH_IIC_H 
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/io.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/io.h
@@ -0,0 +1,29 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/io.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ 
+ * This program is free software; you can redistribute it and/or
+ ** modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT	0xffffffff
+
+/*
+ * 1:1 mapping for ioremapped regions.
+ */
+
+#define __mem_pci(a)	(a)
+#define __io(a)		__typesafe_io(a)
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/irqs.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/irqs.h
@@ -0,0 +1,130 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/irqs.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+/*
+ * we keep the first set of CPU IRQs out of the range of
+ * the ISA space, so that the PC104 has them to itself
+ * and we don't end up having to do horrible things to the
+ * standard ISA drivers....
+ *
+ */
+
+#define NUC970_IRQ(x)	(x)
+
+/* Main cpu interrupts */
+
+#define IRQ_WDT		NUC970_IRQ(1)
+#define IRQ_WWDT	NUC970_IRQ(2)
+#define IRQ_LVD		NUC970_IRQ(3)
+#define IRQ_EXT0	NUC970_IRQ(4)
+#define IRQ_EXT1	NUC970_IRQ(5)
+#define IRQ_EXT2	NUC970_IRQ(6)
+#define IRQ_EXT3	NUC970_IRQ(7)
+#define IRQ_EXT4	NUC970_IRQ(8)
+#define IRQ_EXT5	NUC970_IRQ(9)
+#define IRQ_EXT6	NUC970_IRQ(10)
+#define IRQ_EXT7	NUC970_IRQ(11)
+#define IRQ_ACTL	NUC970_IRQ(12)
+#define IRQ_LCD		NUC970_IRQ(13)
+#define IRQ_CAP		NUC970_IRQ(14)
+#define IRQ_RTC		NUC970_IRQ(15)
+#define IRQ_TMR0	NUC970_IRQ(16)
+#define IRQ_TMR1	NUC970_IRQ(17)
+#define IRQ_ADC		NUC970_IRQ(18)
+#define IRQ_EMC0RX	NUC970_IRQ(19)
+#define IRQ_EMC1RX	NUC970_IRQ(20)
+#define IRQ_EMC0TX	NUC970_IRQ(21)
+#define IRQ_EMC1TX	NUC970_IRQ(22)
+#define IRQ_EHCI	NUC970_IRQ(23)
+#define IRQ_OHCI	NUC970_IRQ(24)
+#define IRQ_GDMA0	NUC970_IRQ(25)
+#define IRQ_GDMA1	NUC970_IRQ(26)
+#define IRQ_SDH		NUC970_IRQ(27)
+#define IRQ_FMI		NUC970_IRQ(28)
+#define IRQ_UDC		NUC970_IRQ(29)
+#define IRQ_TMR2	NUC970_IRQ(30)
+#define IRQ_TMR3	NUC970_IRQ(31)
+#define IRQ_TMR4	NUC970_IRQ(32)
+#define IRQ_JPEG	NUC970_IRQ(33)
+#define IRQ_GE2D	NUC970_IRQ(34)
+#define IRQ_CRYPTO	NUC970_IRQ(35)
+#define IRQ_UART0	NUC970_IRQ(36)
+#define IRQ_UART1	NUC970_IRQ(37)
+#define IRQ_UART2	NUC970_IRQ(38)
+#define IRQ_UART4	NUC970_IRQ(39)
+#define IRQ_UART6	NUC970_IRQ(40)
+#define IRQ_UART8	NUC970_IRQ(41)
+#define IRQ_UART10	NUC970_IRQ(42)
+#define IRQ_UART3	NUC970_IRQ(43)
+#define IRQ_UART5	NUC970_IRQ(44)
+#define IRQ_UART7	NUC970_IRQ(45)
+#define IRQ_UART9	NUC970_IRQ(46)
+#define IRQ_ETIMER0	NUC970_IRQ(47)
+#define IRQ_ETIMER1	NUC970_IRQ(48)
+#define IRQ_ETIMER2	NUC970_IRQ(49)
+#define IRQ_ETIMER3	NUC970_IRQ(50)
+#define IRQ_SPI0	NUC970_IRQ(51)
+#define IRQ_SPI1	NUC970_IRQ(52)
+#define IRQ_I2C0	NUC970_IRQ(53)
+#define IRQ_I2C1	NUC970_IRQ(54)
+#define IRQ_SMC0	NUC970_IRQ(55)
+#define IRQ_SMC1	NUC970_IRQ(56)
+#define IRQ_GPIO	NUC970_IRQ(57)
+#define IRQ_CAN0	NUC970_IRQ(58)
+#define IRQ_CAN1	NUC970_IRQ(59)
+#define IRQ_PWM		NUC970_IRQ(60)
+#define IRQ_KPI		NUC970_IRQ(61)
+
+#ifndef CONFIG_GPIO_NUC970
+#define SPARE_IRQS          (64)
+#define NR_IRQS		        (IRQ_KPI + SPARE_IRQS + 1)
+
+#else
+#define EXT0_BASE 100
+#define IRQ_EXT0_H0		NUC970_IRQ(EXT0_BASE+0)
+#define IRQ_EXT1_H1		NUC970_IRQ(EXT0_BASE+1)
+#define IRQ_EXT2_H2		NUC970_IRQ(EXT0_BASE+2)
+#define IRQ_EXT3_H3		NUC970_IRQ(EXT0_BASE+3)
+#define IRQ_EXT4_H4		NUC970_IRQ(EXT0_BASE+4)
+#define IRQ_EXT5_H5		NUC970_IRQ(EXT0_BASE+5)
+#define IRQ_EXT6_H6		NUC970_IRQ(EXT0_BASE+6)
+#define IRQ_EXT7_H7		NUC970_IRQ(EXT0_BASE+7)
+
+#define IRQ_EXT0_F11	NUC970_IRQ(EXT0_BASE+8)
+#define IRQ_EXT1_F12	NUC970_IRQ(EXT0_BASE+9)
+#define IRQ_EXT2_F13	NUC970_IRQ(EXT0_BASE+10)
+#define IRQ_EXT3_F14	NUC970_IRQ(EXT0_BASE+11)
+#define IRQ_EXT4_F15	NUC970_IRQ(EXT0_BASE+12)
+#define IRQ_EXT5_G15	NUC970_IRQ(EXT0_BASE+13)
+#define IRQ_EXT6_I1	    NUC970_IRQ(EXT0_BASE+14)
+#define IRQ_EXT7_I2 	NUC970_IRQ(EXT0_BASE+15)
+
+#define IRQ_GPIO_START 	NUC970_IRQ(NUC970_IRQ(0x100))
+#define IRQ_GPIO_END 	NUC970_IRQ(NUC970_IRQ(0x100+0x130))
+
+#define SPARE_IRQS       (64)
+
+#define NR_IRQS		(IRQ_GPIO_END + SPARE_IRQS +1)
+
+#endif
+
+
+
+
+#endif /* __ASM_ARCH_IRQ_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/map.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/map.h
@@ -0,0 +1,246 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/map.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARCH_MAP_H
+#define __ASM_ARCH_MAP_H
+
+#ifndef __ASSEMBLY__
+#define NUC970_ADDR(x)		((void __iomem *)(0xF0000000 + (x)))
+#else
+#define NUC970_ADDR(x)		(0xF0000000 + (x))
+#endif
+
+#define AHB_IO_BASE		0xB0000000
+#define APB_IO_BASE		0xB8000000
+#define CLOCKPW_BASE		(APB_IO_BASE+0x200)
+#define AIC_IO_BASE		(APB_IO_BASE+0x2000)
+#define TIMER_IO_BASE		(APB_IO_BASE+0x1000)
+
+/*
+ * interrupt controller is the first thing we put in, to make
+ * the assembly code for the irq detection easier
+ */
+#define NUC970_VA_IRQ		NUC970_ADDR(0x00000000)
+#define NUC970_PA_IRQ		(0xB8002000)
+#define NUC970_SZ_IRQ		SZ_4K
+
+/* GCR, Clock management */
+#define NUC970_VA_GCR_CLK	NUC970_ADDR(0x08002000)		//cc
+#define NUC970_PA_GCR_CLK	(0xB0000000)
+#define NUC970_SZ_GCR_CLK	SZ_4K
+
+#define NUC970_VA_GCR		NUC970_ADDR(0x08002000)
+#define NUC970_PA_GCR		(0xB0000000)
+#define NUC970_SZ_GCR		SZ_512
+
+/* Clock management */
+#define NUC970_VA_CLK		(NUC970_VA_GCR+0x200)
+#define NUC970_PA_CLK		(0xB0000200)
+#define NUC970_SZ_CLK		SZ_512
+
+/* EBI, SDIC management */
+#define NUC970_VA_EBI_SDIC	NUC970_ADDR(0x00001000)		//cc
+#define NUC970_PA_EBI_SDIC	(0xB0001000)
+#define NUC970_SZ_EBI_SDIC	SZ_4K
+
+/* EBI management */
+#define NUC970_VA_EBI		NUC970_ADDR(0x00001000)
+#define NUC970_PA_EBI		(0xB0001000)
+#define NUC970_SZ_EBI		SZ_2K
+
+/* SDIC management */
+#define NUC970_VA_SDIC		NUC970_ADDR(0x00001800)
+#define NUC970_PA_SDIC		(0xB0001800)
+#define NUC970_SZ_SDIC		SZ_2K
+
+/* External MAC0 control*/
+#define NUC970_VA_EMAC0		NUC970_ADDR(0x00002000)
+#define NUC970_PA_EMAC0		(0xB0002000)
+#define NUC970_SZ_EMAC0		SZ_4K
+
+/* External MAC1 control*/
+#define NUC970_VA_EMAC1		NUC970_ADDR(0x00003000)
+#define NUC970_PA_EMAC1		(0xB0003000)
+#define NUC970_SZ_EMAC1		SZ_4K
+
+/* GDMA control */
+#define NUC970_VA_GDMA		NUC970_ADDR(0x00004000)
+#define NUC970_PA_GDMA		(0xB0004000)
+#define NUC970_SZ_GDMA		SZ_4K
+
+/* USB host controller*/
+#define NUC970_VA_EHCI		NUC970_ADDR(0x00005000)
+#define NUC970_PA_EHCI		(0xB0005000)
+#define NUC970_SZ_EHCI		SZ_4K
+
+#define NUC970_VA_OHCI		NUC970_ADDR(0x00007000)
+#define NUC970_PA_OHCI		(0xB0007000)
+#define NUC970_SZ_OHCI		SZ_4K
+
+/* USB Device port */
+#define NUC970_VA_USBDEV	NUC970_ADDR(0x00006000)
+#define NUC970_PA_USBDEV	(0xB0006000)
+#define NUC970_SZ_USBDEV	SZ_4K
+
+
+/* LCD controller*/
+#define NUC970_VA_LCD		NUC970_ADDR(0x00008000)
+#define NUC970_PA_LCD		(0xB0008000)
+#define NUC970_SZ_LCD		SZ_4K
+
+/* Audio Controller controller */
+#define NUC970_VA_ACTL		NUC970_ADDR(0x00009000)
+#define NUC970_PA_ACTL		(0xB0009000)
+#define NUC970_SZ_ACTL		SZ_4K
+
+/* JPEG codec */
+#define NUC970_VA_JPEG 	   	NUC970_ADDR(0x0000A000)
+#define NUC970_PA_JPEG 	   	(0xB000A000)
+#define NUC970_SZ_JPEG 	   	SZ_4K
+
+/* 2D controller*/
+#define NUC970_VA_GE		NUC970_ADDR(0x0000B000)
+#define NUC970_PA_GE		(0xB000B000)
+#define NUC970_SZ_GE		SZ_4K
+
+/* SDIO Controller */
+#define NUC970_VA_SDH	 	NUC970_ADDR(0x0000C000)
+#define NUC970_PA_SDH 		(0xB000C000)
+#define NUC970_SZ_SDH 		SZ_4K
+
+/* FMI Controller */
+#define NUC970_VA_FMI 	   	NUC970_ADDR(0x0000D000)
+#define NUC970_PA_FMI 	   	(0xB000D000)
+#define NUC970_SZ_FMI 	   	SZ_4K
+
+/* VCAP Interface */
+#define NUC970_VA_CAP   	NUC970_ADDR(0x0000E000)
+#define NUC970_PA_CAP   	(0xB000E000)
+#define NUC970_SZ_CAP   	SZ_4K
+
+/* Crypto Engine */
+#define NUC970_VA_CRYPTO  	NUC970_ADDR(0x0000F000)
+#define NUC970_PA_CRYPTO   	(0xB000F000)
+#define NUC970_SZ_CRYPTO   	SZ_4K
+
+/* UARTs */
+#define NUC970_VA_UART		NUC970_ADDR(0x08000000)
+#define NUC970_PA_UART		(0xB8000000)
+#define NUC970_SZ_UART		SZ_4K
+
+/* Timers, ETimers, Watchdog Timer (WDT), Window Watchdog Timer (WWDT) management */
+#define NUC970_VA_TIMER_ETIMER_WDT_WWDT		NUC970_ADDR(0x08001000)		//cc
+#define NUC970_PA_TIMER_ETIMER_WDT_WWDT		(0xB8001000)
+#define NUC970_SZ_TIMER_ETIMER_WDT_WWDT		SZ_4K
+
+/* Timers */
+#define NUC970_VA_TIMER		NUC970_ADDR(0x08001000)
+#define NUC970_PA_TIMER		(0xB8001000)
+#define NUC970_SZ_TIMER		SZ_1K
+
+/* ETimers */
+#define NUC970_VA_ETIMER	NUC970_ADDR(0x08001400)
+#define NUC970_PA_ETIMER	(0xB8001400)
+#define NUC970_SZ_ETIMER	SZ_1K
+
+/* Watchdog Timer (WDT) */
+#define NUC970_VA_WDT		NUC970_ADDR(0x08001800)
+#define NUC970_PA_WDT		(0xB8001800)
+#define NUC970_SZ_WDT		SZ_256
+
+/* Window Watchdog Timer (WWDT) */
+#define NUC970_VA_WWDT		NUC970_ADDR(0x08001900)
+#define NUC970_PA_WWDT		(0xB8001900)
+#define NUC970_SZ_WWDT		SZ_256
+
+/* GPIO ports */
+#define NUC970_VA_GPIO		NUC970_ADDR(0x08003000)
+#define NUC970_PA_GPIO		(0xB8003000)
+#define NUC970_SZ_GPIO		SZ_4K
+
+/* RTC */
+#define NUC970_VA_RTC		NUC970_ADDR(0x08004000)
+#define NUC970_PA_RTC		(0xB8004000)
+#define NUC970_SZ_RTC		SZ_4K
+
+/* Smart card host*/
+#define NUC970_VA_SC		NUC970_ADDR(0x08005000)
+#define NUC970_PA_SC		(0xB8005000)
+#define NUC970_SZ_SC		SZ_4K
+
+/* I2C, Smart card host*/
+#define NUC970_VA_I2C_SPI	NUC970_ADDR(0x08006000)		//cc
+#define NUC970_PA_I2C_SPI	(0xB8006000)
+#define NUC970_SZ_I2C_SPI	SZ_1K
+
+/* I2C hardware controller */
+#define NUC970_VA_I2C0		NUC970_ADDR(0x08006000)
+#define NUC970_PA_I2C0		(0xB8006000)
+#define NUC970_SZ_I2C0		SZ_256
+
+#define NUC970_VA_I2C1		NUC970_ADDR(0x08006100)
+#define NUC970_PA_I2C1		(0xB8006100)
+#define NUC970_SZ_I2C1		SZ_256
+
+/* SPI0 Controller */
+#define NUC970_VA_SPI0 		NUC970_ADDR(0x08006200)
+#define NUC970_PA_SPI0 		(0xB8006200)
+#define NUC970_SZ_SPI0		SZ_256
+
+/* SPI1 Controller */
+#define NUC970_VA_SPI1 		NUC970_ADDR(0x08006300)
+#define NUC970_PA_SPI1 		(0xB8006300)
+#define NUC970_SZ_SPI1		SZ_256
+
+/* Pulse Width Modulation(PWM) Registers */
+#define NUC970_VA_PWM		NUC970_ADDR(0x08007000)
+#define NUC970_PA_PWM		(0xB8007000)
+#define NUC970_SZ_PWM		SZ_4K
+
+/* Keypad Interface*/
+#define NUC970_VA_KPI		NUC970_ADDR(0x08008000)
+#define NUC970_PA_KPI		(0xB8008000)
+#define NUC970_SZ_KPI		SZ_4K
+
+/* ADC */
+#define NUC970_VA_ADC		NUC970_ADDR(0x0800A000)
+#define NUC970_PA_ADC		(0xB800A000)
+#define NUC970_SZ_ADC		SZ_4K
+
+/* CAN Controller */
+#define NUC970_VA_CAN		NUC970_ADDR(0x0800B000)
+#define NUC970_PA_CAN		(0xB800B000)
+#define NUC970_SZ_CAN		SZ_1K
+
+#define NUC970_VA_CAN1		NUC970_ADDR(0x0800B400)
+#define NUC970_PA_CAN1		(0xB800B400)
+#define NUC970_SZ_CAN1		SZ_1K
+
+
+/* MTP */
+#define NUC970_VA_MTP		NUC970_ADDR(0x0800C000)
+#define NUC970_PA_MTP		(0xB800C000)
+#define NUC970_SZ_MTP		SZ_4K
+
+/* SRAM */
+#define NUC970_VA_SRAM	NUC970_ADDR(0x0C000000)
+#define NUC970_PA_SRAM	(0xBC000000)
+#define NUC970_SZ_SRAM	SZ_32K
+
+
+
+#endif /* __ASM_ARCH_MAP_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/memory.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/memory.h
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/memory.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PHYS_OFFSET	UL(0x00000000)
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/mfp.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/mfp.h
@@ -0,0 +1,32 @@
+/*
+ * linux/arch/arm/mach-nuc970/include/mach/clock.c
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+
+#ifndef __ASM_ARCH_MFP_H
+#define __ASM_ARCH_MFP_H
+
+extern void nuc970_mfp_set_port_a(u32 pin, u32 func);
+extern void nuc970_mfp_set_port_b(u32 pin, u32 func);
+extern void nuc970_mfp_set_port_c(u32 pin, u32 func);
+extern void nuc970_mfp_set_port_d(u32 pin, u32 func);
+extern void nuc970_mfp_set_port_e(u32 pin, u32 func);
+extern void nuc970_mfp_set_port_f(u32 pin, u32 func);
+extern void nuc970_mfp_set_port_g(u32 pin, u32 func);
+extern void nuc970_mfp_set_port_h(u32 pin, u32 func);
+extern void nuc970_mfp_set_port_i(u32 pin, u32 func);
+
+
+#endif /* __ASM_ARCH_MFP_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/nuc970-etimer.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/nuc970-etimer.h
@@ -0,0 +1,39 @@
+/* linux/arch/arm/mach-nuc970/include/mach/nuc970-etimer.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef _NUC970_ETIMER_H_
+#define _NUC970_ETIMER_H_
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+
+
+#define ETMR_IOC_MAGIC		'e'
+#define ETMR_IOC_MAXNR		3
+
+#define ETMR_IOC_STOP			_IO(ETMR_IOC_MAGIC, 0)
+#define ETMR_IOC_TOGGLE			_IOW(ETMR_IOC_MAGIC, 1, unsigned int *)
+#define ETMR_IOC_FREE_COUNTING		_IOW(ETMR_IOC_MAGIC, 2, unsigned int *)
+#define ETMR_IOC_TRIGGER_COUNTING	_IOW(ETMR_IOC_MAGIC, 3, unsigned int *)
+#define ETMR_IOC_PERIODIC	        _IOW(ETMR_IOC_MAGIC, 4, unsigned int *)
+#define ETMR_IOC_PERIODIC_FOR_WKUP	_IOW(ETMR_IOC_MAGIC, 5, unsigned int *)
+#define ETMR_IOC_CLKLXT  	        _IOW(ETMR_IOC_MAGIC, 6, unsigned int *)
+#define ETMR_IOC_CLKHXT  	        _IOW(ETMR_IOC_MAGIC, 7, unsigned int *)
+
+// Valid parameters for capture mode ioctls
+#define ETMR_CAP_EDGE_FF	0x00000
+#define ETMR_CAP_EDGE_RR	0x40000
+#define ETMR_CAP_EDGE_FR	0x80000
+#define ETMR_CAP_EDGE_RF	0xC0000
+
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/nuc970-sc.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/nuc970-sc.h
@@ -0,0 +1,83 @@
+/* linux/arch/arm/mach-nuc970/include/mach/nuc970-sc.h
+ *
+ * Copyright (c) 2015 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _NUC970_SC_H_
+#define _NUC970_SC_H_
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+// parameter for SC_IOC_TRANSACT command
+struct sc_transact{
+	unsigned char *tx_buf;
+	unsigned int tx_len;
+	unsigned char *rx_buf;
+	unsigned int rx_len;
+};
+
+#define SC_IOC_MAGIC		's'
+#define SC_IOC_MAXNR		5
+
+#define SC_IOC_ACTIVATE			_IO(SC_IOC_MAGIC, 0)
+#define SC_IOC_READATR			_IOR(SC_IOC_MAGIC, 1, unsigned int *)
+#define SC_IOC_DEACTIVATE		_IO(SC_IOC_MAGIC, 2)
+#define SC_IOC_GETSTATUS		_IOR(SC_IOC_MAGIC, 3, unsigned int *)
+#define SC_IOC_SETPARAM			_IO(SC_IOC_MAGIC, 4)
+#define SC_IOC_TRANSACT			_IOWR(SC_IOC_MAGIC, 5, unsigned int *)
+
+// Status
+#define SC_OP_IDLE			0x0000
+#define SC_OP_READ			0x0001
+#define SC_OP_WRITE			0x0002
+#define SC_OP_READ_ATR			0x0003
+#define SC_OP_COLD_RESET		0x0004
+#define SC_OP_WARM_RESET		0x0005
+#define SC_OP_DEACTIVATE		0x0006
+
+// Error code
+#define SC_ERR_CARD_REMOVED		0x0001
+#define SC_ERR_TIME0OUT			0x0002
+#define SC_ERR_TIME1OUT			0x0003
+#define SC_ERR_TIME2OUT			0x0004
+#define SC_ERR_AUTOCONVENTION		0x0005
+#define SC_ERR_READ			0x0006
+#define SC_ERR_WRITE			0x0007
+#define SC_ERR_PARAM			0x0008
+#define SC_ERR_ATR			0x0009
+#define SC_ERR_PPS			0x000A
+#define SC_ERR_T0			0x000B
+#define SC_ERR_T1			0x000C
+#define SC_ERR_PARITY			0x000D
+
+// CD/ACT state for user level query
+#define ICC_PRESENT_ACTIVE		0x0000
+#define ICC_PRESENT_INACTIVE		0x0001
+#define ICC_ABSENT			0x0002
+
+#define SC_TMR_MODE_0			0x00000000
+#define SC_TMR_MODE_1			0x01000000
+#define SC_TMR_MODE_2			0x02000000
+#define SC_TMR_MODE_3			0x03000000
+#define SC_TMR_MODE_4			0x04000000
+#define SC_TMR_MODE_5			0x05000000
+#define SC_TMR_MODE_6			0x06000000
+#define SC_TMR_MODE_7			0x07000000
+#define SC_TMR_MODE_8			0x08000000
+#define SC_TMR_MODE_F			0x0F000000
+
+#define SC_PROTOCOL_T0			0
+#define SC_PROTOCOL_T1			1
+
+#define SC_CHKSUM_CRC			0
+#define SC_CHKSUM_LRC			1
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/nuc970_usbd.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/nuc970_usbd.h
@@ -0,0 +1,219 @@
+/* linux/arch/arm/mach-nuc970/include/mach/regs_usbd.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+ 
+#ifndef __NUC970_USBD_H
+#define __NUC970_USBD_H
+
+
+#define USBD_DMA_LEN		0x10000
+#define USB_HIGHSPEED		2
+#define USB_FULLSPEED		1
+#define EPSTADDR        	0x400
+#define CBW_SIZE			64
+
+#define DMA_READ			1
+#define DMA_WRITE			2
+
+#define REG_USBD_IRQ_STAT_L             (0x00)
+#define REG_USBD_IRQ_ENB_L              (0x08)
+#define REG_USBD_IRQ_STAT               (0x10)
+#define REG_USBD_IRQ_ENB                (0x14)
+#define REG_USBD_OPER                   (0x18)
+#define REG_USBD_FRAME_CNT              (0x1c)
+#define REG_USBD_ADDR                   (0x20)
+#define REG_USBD_TEST                   (0x24)
+#define REG_USBD_CEP_DATA_BUF           (0x28)
+#define REG_USBD_CEP_CTRL_STAT          (0x2c)
+#define REG_USBD_CEP_IRQ_ENB            (0x30)
+#define REG_USBD_CEP_IRQ_STAT           (0x34)
+#define REG_USBD_IN_TRNSFR_CNT          (0x38)
+#define REG_USBD_OUT_TRNSFR_CNT         (0x3c)
+#define REG_USBD_CEP_CNT                (0x40)
+#define REG_USBD_SETUP1_0               (0x44)
+#define REG_USBD_SETUP3_2               (0x48)
+#define REG_USBD_SETUP5_4               (0x4c)
+#define REG_USBD_SETUP7_6               (0x50)
+#define REG_USBD_CEP_START_ADDR         (0x54)
+#define REG_USBD_CEP_END_ADDR           (0x58)
+#define REG_USBD_DMA_CTRL_STS           (0x5c)
+#define REG_USBD_DMA_CNT                (0x60)
+
+#define REG_USBD_EPA_DATA_BUF           (0x64)
+#define REG_USBD_EPA_IRQ_STAT           (0x68)
+#define REG_USBD_EPA_IRQ_ENB            (0x6c)
+#define REG_USBD_EPA_DATA_CNT           (0x70)
+#define REG_USBD_EPA_RSP_SC             (0x74)
+#define REG_USBD_EPA_MPS                (0x78)
+#define REG_USBD_EPA_TRF_CNT            (0x7c)
+#define REG_USBD_EPA_CFG                (0x80)
+#define REG_USBD_EPA_START_ADDR         (0x84)
+#define REG_USBD_EPA_END_ADDR           (0x88)
+
+#define REG_USBD_EPB_DATA_BUF           (0x8c)
+#define REG_USBD_EPB_IRQ_STAT           (0x90)
+#define REG_USBD_EPB_IRQ_ENB            (0x94)
+#define REG_USBD_EPB_DATA_CNT           (0x98)
+#define REG_USBD_EPB_RSP_SC             (0x9c)
+#define REG_USBD_EPB_MPS                (0xa0)
+#define REG_USBD_EPB_TRF_CNT            (0xa4)
+#define REG_USBD_EPB_CFG                (0xa8)
+#define REG_USBD_EPB_START_ADDR         (0xac)
+#define REG_USBD_EPB_END_ADDR           (0xb0)
+
+#define REG_USBD_EPC_DATA_BUF           (0xb4)
+#define REG_USBD_EPC_IRQ_STAT           (0xb8)
+#define REG_USBD_EPC_IRQ_ENB            (0xbc)
+#define REG_USBD_EPC_DATA_CNT           (0xc0)
+#define REG_USBD_EPC_RSP_SC             (0xc4)
+#define REG_USBD_EPC_MPS                (0xc8)
+#define REG_USBD_EPC_TRF_CNT            (0xcc)
+#define REG_USBD_EPC_CFG                (0xd0)
+#define REG_USBD_EPC_START_ADDR         (0xd4)
+#define REG_USBD_EPC_END_ADDR           (0xd8)
+
+#define REG_USBD_EPD_DATA_BUF           (0xdc)
+#define REG_USBD_EPD_IRQ_STAT           (0xe0)
+#define REG_USBD_EPD_IRQ_ENB            (0xe4)
+#define REG_USBD_EPD_DATA_CNT           (0xe8)
+#define REG_USBD_EPD_RSP_SC             (0xec)
+#define REG_USBD_EPD_MPS                (0xf0)
+#define REG_USBD_EPD_TRF_CNT            (0xf4)
+#define REG_USBD_EPD_CFG                (0xf8)
+#define REG_USBD_EPD_START_ADDR         (0xfc)
+#define REG_USBD_EPD_END_ADDR           (0x100)
+
+#define REG_USBD_EPE_DATA_BUF           (0x104)
+#define REG_USBD_EPE_IRQ_STAT           (0x108)
+#define REG_USBD_EPE_IRQ_ENB            (0x10c)
+#define REG_USBD_EPE_DATA_CNT           (0x110)
+#define REG_USBD_EPE_RSP_SC             (0x114)
+#define REG_USBD_EPE_MPS                (0x118)
+#define REG_USBD_EPE_TRF_CNT            (0x11c)
+#define REG_USBD_EPE_CFG                (0x120)
+#define REG_USBD_EPE_START_ADDR         (0x124)
+#define REG_USBD_EPE_END_ADDR           (0x128)
+
+#define REG_USBD_EPF_DATA_BUF           (0x12c)
+#define REG_USBD_EPF_IRQ_STAT           (0x130)
+#define REG_USBD_EPF_IRQ_ENB            (0x134)
+#define REG_USBD_EPF_DATA_CNT           (0x138)
+#define REG_USBD_EPF_RSP_SC             (0x13c)
+#define REG_USBD_EPF_MPS                (0x140)
+#define REG_USBD_EPF_TRF_CNT            (0x144)
+#define REG_USBD_EPF_CFG                (0x148)
+#define REG_USBD_EPF_START_ADDR         (0x14c)
+#define REG_USBD_EPF_END_ADDR           (0x150)
+#define REG_USBD_AHB_DMA_ADDR           (0x700)
+#define REG_USBD_PHY_CTL                (0x704) 
+
+
+/*
+ * Standard requests
+ */
+#define USBR_GET_STATUS			0x00
+#define USBR_CLEAR_FEATURE		0x01
+#define USBR_SET_FEATURE		0x03
+#define USBR_SET_ADDRESS		0x05
+#define USBR_GET_DESCRIPTOR		0x06
+#define USBR_SET_DESCRIPTOR		0x07
+#define USBR_GET_CONFIGURATION  0x08
+#define USBR_SET_CONFIGURATION	0x09
+#define USBR_GET_INTERFACE		0x0A
+#define USBR_SET_INTERFACE		0x0B
+#define USBR_SYNCH_FRAME		0x0C
+
+
+//Bit Definitions of IRQ_ENB/STAT register
+#define	IRQ_USB_STAT		    0x01
+#define IRQ_CEP					0x02
+#define IRQ_NCEP				0xfc   
+
+//Definition of Bits in USB_IRQ_STS register
+#define USB_SOF					0x01	
+#define USB_RST_STS				0x02
+#define	USB_RESUME				0x04
+#define	USB_SUS_REQ				0x08
+#define	USB_HS_SETTLE			0x10
+#define	USB_DMA_REQ				0x20
+#define USABLE_CLK				0x40
+#define USB_FLT_DET				0x100
+
+
+//Definition of Bits in USB_OPER register
+#define USB_GEN_RES             0x1
+#define USB_HS		        	0x2
+#define USB_CUR_SPD_HS          0x4
+
+//Definition of Bits in CEP_IRQ_STS register
+#define CEP_SUPTOK	 			0x0001
+#define CEP_SUPPKT				0x0002
+#define CEP_OUT_TOK				0x0004
+#define CEP_IN_TOK				0x0008
+#define CEP_PING_TOK	        0x0010
+#define CEP_DATA_TXD	        0x0020
+#define CEP_DATA_RXD	        0x0040
+#define CEP_NAK_SENT	        0x0080
+#define CEP_STALL_SENT	        0x0100
+#define CEP_USB_ERR				0x0200
+#define CEP_STS_END				0x0400
+#define CEP_BUFF_FULL	        0x0800
+#define CEP_BUFF_EMPTY	        0x1000
+
+//Definition of Bits in CEP_CTRL_STS register
+#define CEP_NAK_CLEAR			0x00  //writing zero clears the nak bit
+#define CEP_SEND_STALL			0x02
+#define CEP_ZEROLEN				0x04
+#define CEP_FLUSH				0x08
+
+//Definition of Bits in EP_IRQ_STS register
+#define EP_BUFF_FULL	        0x001
+#define EP_BUFF_EMPTY	        0x002
+#define EP_SHORT_PKT	        0x004
+#define EP_DATA_TXD				0x008
+#define EP_DATA_RXD				0x010
+#define EP_OUT_TOK				0x020
+#define EP_IN_TOK				0x040
+#define EP_PING_TOK				0x080
+#define EP_NAK_SENT				0x100
+#define EP_STALL_SENT	        0x200
+#define EP_USB_ERR				0x800
+#define EP_BO_SHORT_PKT			0x1000
+
+//Bit Definitons of EP_RSP_SC Register
+#define EP_BUFF_FLUSH           0x01
+#define EP_MODE                 0x06
+#define EP_MODE_AUTO	        0x00
+#define EP_MODE_MAN 	        0x02
+#define EP_MODE_FLY				0x04
+#define EP_TOGGLE				0x8
+#define EP_HALT					0x10
+#define EP_ZERO_IN              0x20
+#define EP_PKT_END              0x40
+
+//Bit Definitons of EP_CFG Register
+#define EP_VALID				0x01
+#define EP_TYPE					0x06 //2-bit size	
+#define EP_TYPE_BLK				0x01
+#define EP_TYPE_INT				0x02
+#define EP_TYPE_ISO				0x03
+#define EP_DIR					0x08
+#define EP_NO					0xf0 //4-bit size
+
+/* Define Endpoint feature */
+#define Ep_In                   0x01
+#define Ep_Out                  0x00
+
+
+#endif /* __NUC970_USBD_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-adc.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-adc.h
@@ -0,0 +1,94 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-adc.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef __ASM_ARCH_REGS_ADC_H
+#define __ASM_ARCH_REGS_ADC_H
+
+#define ADC_BA	NUC970_VA_ADC	/* ADC Control */
+
+#define REG_ADC_CTL					(ADC_BA + 0x000)	/* ADC Control  */	
+#define REG_ADC_CONF				(ADC_BA + 0x004)	/* ADC Configure  */	
+#define REG_ADC_IER					(ADC_BA + 0x008)	/* ADC Interrupt Enable Register */	
+#define REG_ADC_ISR					(ADC_BA + 0x00C) /* ADC Interrupt Status Register */
+#define REG_ADC_WKISR       (ADC_BA + 0x010) /* ADC Wake Up Interrupt Status Register */
+#define REG_ADC_XYDATA      (ADC_BA + 0x020) /* ADC Touch X,Y Position Data  */
+#define REG_ADC_ZDATA       (ADC_BA + 0x024) /* ADC Touch Z Pressure Data  */
+#define REG_ADC_DATA        (ADC_BA + 0x028) /* ADC Normal Conversion Data  */
+#define REG_ADC_VBADATA     (ADC_BA + 0x02C) /* ADC Battery Detection Data  */
+#define REG_ADC_KPDATA      (ADC_BA + 0x030) /* ADC Battery Detection Data  */
+#define REG_ADC_SELFDATA    (ADC_BA + 0x034) /* ADC Self-Test Data  */
+#define REG_ADC_XYSORT0     (ADC_BA + 0x1F4) /* ADC Touch XY Position Mean Value Sort 0 */
+#define REG_ADC_XYSORT1     (ADC_BA + 0x1F8) /* ADC Touch XY Position Mean Value Sort 1 */
+#define REG_ADC_XYSORT2     (ADC_BA + 0x1FC) /* ADC Touch XY Position Mean Value Sort 2 */
+#define REG_ADC_XYSORT3     (ADC_BA + 0x200) /* ADC Touch XY Position Mean Value Sort 3 */
+#define REG_ADC_ZSORT0      (ADC_BA + 0x204) /* ADC Touch Z Position Mean Value Sort 0 */
+#define REG_ADC_ZSORT1      (ADC_BA + 0x208) /* ADC Touch Z Position Mean Value Sort 1 */
+#define REG_ADC_ZSORT2      (ADC_BA + 0x20C) /* ADC Touch Z Pressure Mean Value Sort 2 */
+#define REG_ADC_ZSORT3      (ADC_BA + 0x210) /* ADC Touch Z Pressure Mean Value Sort 3 */
+#define REG_ADC_MTMULCK     (ADC_BA + 0x220) /* ADC Manual Test Mode Unlock */
+#define REG_ADC_MTCONF      (ADC_BA + 0x224) /* ADC Manual Test Mode Configure  */
+#define REG_ADC_MTCTL       (ADC_BA + 0x228) /* ADC Manual Test Mode Control */
+#define REG_ADC_ADCAII      (ADC_BA + 0x22C) /* ADC Analog Interface Information */
+#define REG_ADC_ADCAIIRLT   (ADC_BA + 0x230) /* ADC Analog Interface Information Result */
+
+#if 0
+#define ADC_CTL_ADEN 			0x00000001
+#define ADC_CTL_VBGEN 		0x00000002
+#define ADC_CTL_PKWPEN		0x00000004
+#define ADC_CTL_MST 			0x00000100
+#define ADC_CTL_PEDEEN 		0x00000200
+#define ADC_CTL_WKPEN 		0x00000400
+#define ADC_CTL_WKTEN 		0x00000800
+#define ADC_CTL_WMSWCH 		0x00010000
+
+#define ADC_CONF_TEN 			0x00000001
+#define ADC_CONF_ZEN 			0x00000002
+#define ADC_CONF_NACEN		0x00000004
+#define ADC_CONF_VBATEN 	0x00000100
+#define ADC_CONF_KPCEN 		0x00000200
+#define ADC_CONF_SELFTEN 	0x00000400
+#define ADC_CONF_DISTMAVEN 	(1<<20)
+#define ADC_CONF_DISZMAVEN 	(1<<21)
+#define ADC_CONF_HSPEED 		(1<<22)
+
+#define ADC_CONF_CHSEL_Pos 	3
+#define ADC_CONF_CHSEL_Msk 	(7<<3)
+#define ADC_CONF_CHSEL_VBT 	(0<<3)
+#define ADC_CONF_CHSEL_A2		(2<<3)
+
+#define ADC_IER_MIEN			0x00000001
+#define ADC_IER_KPEIEN		0x00000002
+#define ADC_IER_PEDEIEN		0x00000004
+#define ADC_IER_WKTIEN		0x00000008
+#define ADC_IER_WKPIEN		0x00000010
+#define ADC_IER_KPUEIEN		0x00000020
+#define ADC_IER_PEUEIEN		0x00000040   
+
+#define ADC_ISR_MF			0x00000001
+#define ADC_ISR_KPEF		0x00000002
+#define ADC_ISR_PEDEF		0x00000004
+#define ADC_ISR_KPUEF		0x00000008
+#define ADC_ISR_PEUEF		0x00000010
+#define ADC_ISR_TF			0x00000100
+#define ADC_ISR_ZF			0x00000200
+#define ADC_ISR_NACF		0x00000400
+#define ADC_ISR_VBF			0x00000800
+#define ADC_ISR_KPCF		0x00001000
+#define ADC_ISR_SELFTF	0x00002000
+#define ADC_ISR_INTKP	  0x00010000
+#define ADC_ISR_INTTC	  0x00020000
+
+#define ADC_WKISR_WKPEF		0x00000001
+#define ADC_WKISR_WPEDEF	0x00000002
+#endif
+
+#endif /*  __ASM_ARCH_REGS_CAP_H */
\ No newline at end of file
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-aic.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-aic.h
@@ -0,0 +1,62 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-clock.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_AIC_H
+#define __ASM_ARCH_REGS_AIC_H
+
+/* Advance Interrupt Controller (AIC) Registers */
+#define AIC_BA    NUC970_VA_IRQ /* Interrupt Controller */
+#define     REG_AIC_SCR1    (AIC_BA+0x00)    /* Source control register 1 */
+#define     REG_AIC_SCR2    (AIC_BA+0x04)    /* Source control register 2 */
+#define     REG_AIC_SCR3    (AIC_BA+0x08)    /* Source control register 3 */
+#define     REG_AIC_SCR4    (AIC_BA+0x0C)    /* Source control register 4 */
+#define     REG_AIC_SCR5    (AIC_BA+0x10)    /* Source control register 5 */
+#define     REG_AIC_SCR6    (AIC_BA+0x14)    /* Source control register 6 */
+#define     REG_AIC_SCR7    (AIC_BA+0x18)    /* Source control register 7 */
+#define     REG_AIC_SCR8    (AIC_BA+0x1C)    /* Source control register 8 */
+#define     REG_AIC_SCR9    (AIC_BA+0x20)    /* Source control register 9 */
+#define     REG_AIC_SCR10   (AIC_BA+0x24)    /* Source control register 10 */
+#define     REG_AIC_SCR11   (AIC_BA+0x28)    /* Source control register 11 */
+#define     REG_AIC_SCR12   (AIC_BA+0x2C)    /* Source control register 12 */
+#define     REG_AIC_SCR13   (AIC_BA+0x30)    /* Source control register 13 */
+#define     REG_AIC_SCR14   (AIC_BA+0x34)    /* Source control register 14 */
+#define     REG_AIC_SCR15   (AIC_BA+0x38)    /* Source control register 15 */
+#define     REG_AIC_IRSR    (AIC_BA+0x100)   /* Interrupt raw status register */
+#define     REG_AIC_IRSRH   (AIC_BA+0x104)   /* Interrupt raw status register (Hign) */
+#define     REG_AIC_IASR    (AIC_BA+0x108)   /* Interrupt active status register */
+#define     REG_AIC_IASRH   (AIC_BA+0x10C)   /* Interrupt active status register (Hign) */
+#define     REG_AIC_ISR     (AIC_BA+0x110)   /* Interrupt status register */
+#define     REG_AIC_ISRH    (AIC_BA+0x114)   /* Interrupt status register (High) */
+#define     REG_AIC_IPER    (AIC_BA+0x118)   /* Interrupt priority encoding register */
+#define     REG_AIC_ISNR    (AIC_BA+0x120)   /* Interrupt source number register */
+#define     REG_AIC_OISR    (AIC_BA+0x124)   /* Output interrupt status register */
+#define     REG_AIC_IMR     (AIC_BA+0x128)   /* Interrupt mask register */
+#define     REG_AIC_IMRH    (AIC_BA+0x12C)   /* Interrupt mask register (High) */
+#define     REG_AIC_MECR    (AIC_BA+0x130)   /* Mask enable command register */
+#define     REG_AIC_MECRH   (AIC_BA+0x134)   /* Mask enable command register (High) */
+#define     REG_AIC_MDCR    (AIC_BA+0x138)   /* Mask disable command register */
+#define     REG_AIC_MDCRH   (AIC_BA+0x13C)   /* Mask disable command register (High) */
+#define     REG_AIC_SSCR    (AIC_BA+0x140)   /* Source Set Command Register */
+#define     REG_AIC_SSCRH   (AIC_BA+0x144)   /* Source Set Command Register (High) */
+#define     REG_AIC_SCCR    (AIC_BA+0x148)   /* Source Clear Command Register */
+#define     REG_AIC_SCCRH   (AIC_BA+0x14C)   /* Source Clear Command Register (High) */
+#define     REG_AIC_EOSCR   (AIC_BA+0x150)   /* End of service command register */
+
+#define AIC_ISNR		(0x120)
+#define AIC_IPER		(0x118)
+
+#endif /*  __ASM_ARCH_REGS_AIC_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-audio.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-audio.h
@@ -0,0 +1,37 @@
+/* linux/include/asm/arch-nuc900/regs-audio.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#ifndef __ASM_ARM_NUC970_REGS_AUDIO_H
+#define __ASM_ARM_NUC970_REGS_AUDIO_H
+
+/* Audio Control Registers */
+#define ACTL_CON			0x00
+#define ACTL_RESET			0x04
+#define ACTL_RDESB			0x08
+#define ACTL_RDES_LENGTH	0x0C
+#define ACTL_RDESC			0x10
+#define ACTL_PDESB			0x14
+#define ACTL_PDES_LENGTH	0x18
+#define ACTL_PDESC			0x1C
+#define ACTL_RSR			0x20
+#define ACTL_PSR			0x24
+#define ACTL_I2SCON			0x28
+#define ACTL_COUNTER		0x2C
+#define ACTL_PCMCON			0x30
+#define ACTL_PCM1ST			0x34
+#define ACTL_PCM2ST			0x38
+#define ACTL_RDESB2			0x40
+#define ACTL_PDESB2			0x44
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-cap.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-cap.h
@@ -0,0 +1,219 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-vcap.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef __ASM_ARCH_REGS_CAP_H
+#define __ASM_ARCH_REGS_CAP_H
+
+#define BIT0	0x00000001
+#define BIT1	0x00000002
+#define BIT2	0x00000004
+#define BIT3	0x00000008
+#define BIT4	0x00000010
+#define BIT5	0x00000020
+#define BIT6	0x00000040
+#define BIT7	0x00000080
+#define BIT8	0x00000100
+#define BIT9	0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+#include <mach/map.h>
+ 
+#define VIDEOIN_BASE	NUC970_VA_CAP	/* Videoin Control */
+
+#define CAP_BA	NUC970_VA_CAP	/* Videoin Control */
+/*
+ VideoIn Control Registers
+*/
+#define REG_CAP_CTL					(CAP_BA + 0x00)	/* Image Capture Interface Control Register */	
+#define REG_CAP_PAR					(CAP_BA + 0x04)	/* Image Capture Interface Parameter Register */
+#define REG_CAP_INT					(CAP_BA + 0x08)	/* Image Capture Interface Interrupt Register */
+#define REG_CAP_POSTERIZE		(CAP_BA + 0x0C)	/* YUV Component Posterizing Factor Register */
+#define REG_CAP_MD					(CAP_BA + 0x10)	/* Motion Detection Register */
+#define REG_CAP_MDADDR			(CAP_BA + 0x14)	/* Motion Detection Output Address Register */
+#define REG_CAP_MDYADDR			(CAP_BA + 0x18)	/* Motion Detection Temp Y Output Address Register */
+#define REG_CAP_SEPIA				(CAP_BA + 0X1C)	/* Sepia Effect Control Register */
+#define REG_CAP_CWSP        (CAP_BA + 0X20)	/* Cropping Window Starting Address Register */
+#define REG_CAP_CWS         (CAP_BA + 0X24)	/* Cropping Window Size Register */
+#define REG_CAP_PKTSL       (CAP_BA + 0X28)	/* Packet Scaling Vertical/Horizontal Factor Register (LSB) */
+#define REG_CAP_PLNSL       (CAP_BA + 0X2C)	/* Planar Scaling Vertical/Horizontal Factor Register (LSB) */
+#define REG_CAP_FRCTL       (CAP_BA + 0X30)	/* Scaling Frame Rate Factor Register */
+#define REG_CAP_STRIDE      (CAP_BA + 0X34)	/* Frame Output Pixel Stride Width Register */
+#define REG_CAP_FIFOTH      (CAP_BA + 0X3C)	/* FIFO Threshold Register */
+#define REG_CAP_CMPADDR     (CAP_BA + 0X40)	/* Compare Memory Base Address Register */
+#define REG_CAP_PKTSM       (CAP_BA + 0X48)	/* Packet Scaling Vertical/Horizontal Factor Register (MSB) */
+#define REG_CAP_PLNSM       (CAP_BA + 0X4C)	/* Planar Scaling Vertical/Horizontal Factor Register (MSB) */
+#define REG_CAP_CURADDRP    (CAP_BA + 0X50)	/* Current Packet System Memory Address Register */
+#define REG_CAP_CURADDRY    (CAP_BA + 0X54)	/* Current Planar Y System Memory Address Register */
+#define REG_CAP_CURADDRU    (CAP_BA + 0X58)	/* Current Planar U System Memory Address Register */
+#define REG_CAP_CURADDRV    (CAP_BA + 0X5C)	/* Current Planar V System Memory Address Register */
+#define REG_CAP_PKTBA0      (CAP_BA + 0X60)	/* System Memory Packet Base Address 0 Register */
+#define REG_CAP_PKTBA1			(CAP_BA + 0X64)	/* System Memory Packet Base Address 1 Register */
+#define REG_CAP_YBA					(CAP_BA + 0X80)	/* System Memory Planar Y Base Address Register */
+#define REG_CAP_UBA					(CAP_BA + 0X84)	/* System Memory Planar U Base Address Register */
+#define REG_CAP_VBA					(CAP_BA + 0X88)	/* System Memory Planar V Base Address Register */    
+
+#define CAP_CTL_CAPEN 	(1<<0 )
+#define CAP_CTL_PLNEN		(1<<5 )
+#define CAP_CTL_PKTEN		(1<<6 )
+#define CAP_CTL_UPDATE	(1<<20)
+
+#define CAP_CWSP_CWSADDRV (0x3FF<<16)
+#define CAP_CWSP_CWSADDRH	(0x3FF<<0 )  
+
+#define CAP_PKTSL_PKTSVNL (0xFF<<24)
+#define CAP_PKTSL_PKTSVML (0xFF<<16)
+#define CAP_PKTSL_PKTSHNL (0xFF<<8 )
+#define CAP_PKTSL_PKTSHML (0xFF<<0 )
+
+#define CAP_PKTSM_PKTSVNH (0xFF<<24)
+#define CAP_PKTSM_PKTSVMH (0xFF<<16)
+#define CAP_PKTSM_PKTSHNH (0xFF<<8 )
+#define CAP_PKTSM_PKTSHMH (0xFF<<0 )
+
+#define CAP_STRIDE_PLNSTRIDE	(0x3FFF<<16)
+#define CAP_STRIDE_PKTSTRIDE	(0x3FFF<<0 )
+
+
+#define CAP_PLNSL_PLNSVNL (0xFF<<24)
+#define CAP_PLNSL_PLNSVML (0xFF<<16)
+#define CAP_PLNSL_PLNSHNL (0xFF<<8 )
+#define CAP_PLNSL_PLNSHML (0xFF<<0 )
+
+#define CAP_PLNSM_PLNSVNH (0xFF<<24)
+#define CAP_PLNSM_PLNSVMH (0xFF<<16)
+#define CAP_PLNSM_PLNSHNH (0xFF<<8 )
+#define CAP_PLNSM_PLNSHMH (0xFF<<0 )
+
+
+#if 0
+#define REG_VPECTL  		(VIDEOIN_BASE + 0x00)	// R/W: Video Pre-processor Control Register
+			#define VPRST		BIT24										// Video Pre-processor Reset.
+			#define UPDATE 		BIT20									// Video-In Update Register at New Frame	
+			#define CAPONE		BIT16									// Video-In One Shutter
+			#define VPRBIST		BIT8									// Video-In One Shutter
+			#define PKEN		BIT6										// Packet Output Enable
+			#define PNEN		BIT5										// Planar Output Enable
+			#define ADDRSW		BIT3									// Packet Buffer Address select
+			#define FBMODE		BIT2									// Packet Frame Buffer Control by FSC
+			#define VPEEN		BIT0										// Planar Output Enable	
+
+#define REG_VPEPAR		(VIDEOIN_BASE + 0x04)		// R/W: Video Pre-processor Parameter Register
+			#define VPEBFIN		BIT28									// BIST Finish [Read Only]
+			#define BFAIL		NVTBIT(27, 24)					// BIST Fail Flag [Read Only]
+			#define FLDID		BIT20										// Field ID [Read Only]
+			#define FLD1EN		BIT17									// Field 1 Input Enable
+			#define FLD0EN		BIT16					// Field 0 Input Enable
+			#define FLDDETP		BIT15					// Field Detect Position
+			#define FLDDETM 	BIT14					// Field Detect Mode (By HSYNC or input FIELD PIN)
+			#define FLDSWAP	BIT13					// Swap Input Field
+			#define VSP			BIT10					// Sensor Vsync Polarity.
+			#define HSP			BIT9					// Sensor Hsync Polarity
+			#define PCLKP		BIT8					// Sensor Pixel Clock Polarity	
+			#define PNFMT		BIT7					// Planar Output Format
+			#define RANGE		BIT6					// Scale Input YUV CCIR601 color range to full range
+			#define OUTFMT 	NVTBIT(5, 4)				// Image Data Format Output to System Memory.
+			#define PDORD		NVTBIT(3, 2)				// Sensor Output Type
+			#define SNRTYPE 	BIT1					// device is CCIR601 or CCIR656
+			#define INFMT 		BIT0					// Sensor Output Format
+
+
+#define REG_VPEINT  		(VIDEOIN_BASE + 0x08)	// R/W: Video Pre-processor Interrupt  Register
+			#define MDINTEN	BIT20					// Motion Detection Interrupt Enable
+			#define ADDRMEN  	BIT19					// Address Match Interrupt Enable.	
+			#define MEINTEN	BIT17					// System Memory Error Interrupt Enable.
+			#define VINTEN		BIT16					// Video Frame End Interrupt Enable.
+			#define MDINT		BIT4					// Motion Detection Output Finsish Interrupt		
+			#define ADDRMINT	BIT3					// Memory Address Match Interrupt Flag.
+			#define MEINT		BIT1					// System Memory Error Interrupt. If read this bit shows 1, 
+														// Memory Error occurs. Write 0 to clear it.
+			#define VINT		BIT0					// Video Frame End Interrupt. If read this bit shows 1, 
+														// received a frame complete. Write 0 to clear it.
+
+
+#define REG_VPEMD  		(VIDEOIN_BASE + 0x10)	// R/W: Motion Detection  Register
+			#define MDTHR	  	NVTBIT(20, 16)			// MD Differential Threshold	
+			#define MDDF		NVTBIT(11, 10)			// MD Detect Frequence
+			#define MDSM		BIT9					// MD Save Mode
+			#define MDBS		BIT8					// MD Block Size
+			#define MDEN		BIT0					// MD Enable
+			
+#define REG_MDADDR  		(VIDEOIN_BASE + 0x14)	// R/W: Motion Detection Output Address Register
+#define REG_MDYADDR  	(VIDEOIN_BASE + 0x18)	// R/W: Motion Detection Output Address Register
+
+#define REG_VPECWSP  	(VIDEOIN_BASE + 0x20)	// R/W:  Cropping Window Starting Address Register
+			#define CWSPV		NVTBIT(26, 16)			// Cropping Window Vertical Starting Address
+			#define CWSPH		NVTBIT(11, 0)			// Cropping Window Horizontal  Starting Address
+
+#define REG_VPECWS	 	(VIDEOIN_BASE + 0x24)	// R/W:  Cropping Window Size Register
+			#define CWSH			NVTBIT(26, 16)		// Cropping Image Window Height
+			#define CWSW		NVTBIT(11, 0)			// Cropping Image Window Width
+
+#define REG_VPEPKDS  		(VIDEOIN_BASE + 0x28)	// R/W  : Packet Scaling Vertical/Horizontal Factor Register
+#define REG_VPEPNDS 		(VIDEOIN_BASE + 0x2C)	// R?W  : Planar Scaling Vertical/Horizontal Factor Register	
+			#define DSVN		NVTBIT(31, 24)			// Scaling Vertical Factor N
+			#define DSVM		NVTBIT(23, 16)			// Scaling Vertical Factor M
+			#define DSHN		NVTBIT(15, 8)			// Scaling Horizontal Factor N
+			#define DSHM		NVTBIT(7, 0)				// Scaling Horizontal Factor M
+
+#define REG_VPEFRC  		(VIDEOIN_BASE + 0x30)	// R/W  : Scaling Frame Rate Factor Register
+			#define FRCN		NVTBIT(13, 8)			// Scaling Frame Rate Factor N
+			#define FRCM		NVTBIT(5, 0)				// Scaling Frame Rate Factor M
+		
+/*
+#define REG_VWIDTH  		(VIDEOIN_BASE + 0x34)	// R/W  : Frame Output Pixel Straight Width Register
+			#define PNOW		BIT(27, 16)				// Planar Frame Output Pixel Straight Width
+			#define PKOW		BIT(11, 0)				// Packet Frame Output Pixel Straight Width
+*/
+#define REG_VSTRIDE 		(VIDEOIN_BASE + 0x34)	// R/W  : Frame Stride Register
+			#define PNSTRIDE	NVTBIT(27, 16)			// Planar Frame Stride
+			#define PKSTRIDE	NVTBIT(11, 0)			// Packet Frame Stride
+
+#define REG_VFIFO 		(VIDEOIN_BASE + 0x3C)		// R/W  : FIFO threshold Register
+			#define FTHP		NVTBIT(27, 24)			// Packet FIFO Threshold 
+			#define PTHY		NVTBIT(19, 16)			// Planar Y FIFO Threshold 
+			#define PTHU		NVTBIT(10, 8)			// Planar U FIFO Threshold 
+			#define PTHV		NVTBIT(2, 0)				// Planar V FIFO Threshold 
+
+#define REG_CMPADDR 	(VIDEOIN_BASE + 0x40)		// R/W  : Current Packet System Memory Address Register
+#define REG_CURADDRP 	(VIDEOIN_BASE + 0x50)		// R/W  : FIFO threshold Register
+#define REG_CURADDRY 	(VIDEOIN_BASE + 0x54)		// R/W  : Current Planar Y System Memory Address Register
+#define REG_CURADDRU 	(VIDEOIN_BASE + 0x58)		// R/W  : Current Planar U System Memory Address Register
+#define REG_CURADDRV 	(VIDEOIN_BASE + 0x5C)		// R/W  : Current Planar V System Memory Address Register
+#define REG_PACBA0 	(VIDEOIN_BASE + 0x60)		// R/W  : System Memory Packet 0 Base Address Register
+#define REG_PACBA1 	(VIDEOIN_BASE + 0x64)		// R/W  : System Memory Packet 1 Base Address Register
+#define REG_YBA0 		(VIDEOIN_BASE + 0x80)		// R/W  : System Memory Planar Y Base Address Register
+#define REG_UBA0 		(VIDEOIN_BASE + 0x84)		// R/W  : System Memory Planar U Base Address Register
+#define REG_VBA0 		(VIDEOIN_BASE + 0x88)		// R/W  : System Memory Planar V Base Address Register
+#endif
+
+#endif /*  __ASM_ARCH_REGS_CAP_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-clock.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-clock.h
@@ -0,0 +1,40 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-clock.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_CLOCK_H
+#define __ASM_ARCH_REGS_CLOCK_H
+
+/* Clock Control Registers  */
+#define CLK_BA		NUC970_VA_CLK
+
+#define REG_CLK_PMCON		(CLK_BA+0x000)  /*  Power Management Control Register */
+#define REG_CLK_HCLKEN		(CLK_BA+0x010)  /*  AHB IP Clock Enable Control Register */
+#define REG_CLK_PCLKEN0		(CLK_BA+0x018)  /*  APB IP Clock Enable Control Register 0 */
+#define REG_CLK_PCLKEN1		(CLK_BA+0x01C)  /*  APB IP Clock Enable Control Register 1 */
+#define REG_CLK_DIV0		(CLK_BA+0x020)  /*  Clock Divider Control Register 0 */
+#define REG_CLK_DIV1		(CLK_BA+0x024)  /*  Clock Divider Control Register 1 */
+#define REG_CLK_DIV2		(CLK_BA+0x028)  /*  Clock Divider Control Register 2 */
+#define REG_CLK_DIV3		(CLK_BA+0x02C)  /*  Clock Divider Control Register 3 */
+#define REG_CLK_DIV4		(CLK_BA+0x030)  /*  Clock Divider Control Register 4 */
+#define REG_CLK_DIV5		(CLK_BA+0x034)  /*  Clock Divider Control Register 5 */
+#define REG_CLK_DIV6		(CLK_BA+0x038)  /*  Clock Divider Control Register 6 */
+#define REG_CLK_DIV7		(CLK_BA+0x03C)  /*  Clock Divider Control Register 7 */
+#define REG_CLK_DIV8		(CLK_BA+0x040)  /*  Clock Divider Control Register 8 */
+#define REG_CLK_DIV9		(CLK_BA+0x044)  /*  Clock Divider Control Register 9 */
+#define REG_CLK_APLLCON		(CLK_BA+0x060)  /*  APLL Control Register */
+#define REG_CLK_UPLLCON		(CLK_BA+0x064)  /*  UPLL Control Register */
+
+#endif /*  __ASM_ARCH_REGS_CLOCK_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-crypto.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-crypto.h
@@ -0,0 +1,322 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-crypto.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARM_REGS_IPSEC_H
+#define __ASM_ARM_REGS_IPSEC_H
+
+struct nuc970_crypto_regs
+{
+	u32 CRPT_INTEN;				/*!< Offset: 0x0000   Crypto Interrupt Enable Control Register           */ 
+	u32 CRPT_INTSTS;			/*!< Offset: 0x0004   Crypto Interrupt Flag                              */ 
+	u32 CRPT_PRNG_CTL;          /*!< Offset: 0x0008   PRNG Control Register                              */
+	u32 CRPT_PRNG_SEED;			/*!< Offset: 0x000C   Seed for PRNG                                      */
+	u32 CRPT_PRNG_KEY0;			/*!< Offset: 0x0010   PRNG Generated Key0                                */
+	u32 CRPT_PRNG_KEY1;			/*!< Offset: 0x0014   PRNG Generated Key1                                */
+	u32 CRPT_PRNG_KEY2;			/*!< Offset: 0x0018   PRNG Generated Key2                                */
+	u32 CRPT_PRNG_KEY3;			/*!< Offset: 0x001C   PRNG Generated Key3                                */
+	u32 CRPT_PRNG_KEY4;			/*!< Offset: 0x0020   PRNG Generated Key4                                */
+	u32 CRPT_PRNG_KEY5;			/*!< Offset: 0x0024   PRNG Generated Key5                                */
+	u32 CRPT_PRNG_KEY6;			/*!< Offset: 0x0028   PRNG Generated Key6                                */
+	u32 CRPT_PRNG_KEY7;			/*!< Offset: 0x002C   PRNG Generated Key7                                */
+	u32 RESERVED1[8];		    /*!< Offset: 0x0030 ~ 0x004C   Reserved                                  */
+	u32 CRPT_AES_FDBCK0;		/*!< Offset: 0x0050   AES Engine Output Feedback Data after Cryptographic Operation */
+	u32 CRPT_AES_FDBCK1;		/*!< Offset: 0x0054   AES Engine Output Feedback Data after Cryptographic Operation */
+	u32 CRPT_AES_FDBCK2;		/*!< Offset: 0x0058   AES Engine Output Feedback Data after Cryptographic Operation */
+	u32 CRPT_AES_FDBCK3;		/*!< Offset: 0x005C   AES Engine Output Feedback Data after Cryptographic Operation */
+	u32 CRPT_TDES_FDBCKH;		/*!< Offset: 0x0060   Triple DES engine Output higher feedback data after cryptographic operation */
+	u32 CRPT_TDES_FDBCKL;		/*!< Offset: 0x0064   Triple DES engine Output lower feedback data after cryptographic operation */
+	u32 RESERVED2[38];		    /*!< Offset: 0x0068 ~ 0x00FC   Reserved                                  */
+	u32 CRPT_AES_CTL;			/*!< Offset: 0x0100   AES engine setting                                 */
+	u32 CRPT_AES_STS;			/*!< Offset: 0x0104   AES engine flag                                    */
+	u32 CRPT_AES_DATIN;			/*!< Offset: 0x0108   AES engine data input port                         */
+	u32 CRPT_AES_DATOUT;		/*!< Offset: 0x010C   AES engine data output port                        */
+	u32 CRPT_AES0_KEY0;			/*!< Offset: 0x0110   AES0 Key Word 0 Register                           */
+	u32 CRPT_AES0_KEY1;			/*!< Offset: 0x0114   AES0 Key Word 1 Register                           */
+	u32 CRPT_AES0_KEY2;			/*!< Offset: 0x0118   AES0 Key Word 2 Register                           */
+	u32 CRPT_AES0_KEY3;			/*!< Offset: 0x011C   AES0 Key Word 3 Register                           */
+	u32 CRPT_AES0_KEY4;			/*!< Offset: 0x0120   AES0 Key Word 4 Register                           */
+	u32 CRPT_AES0_KEY5;			/*!< Offset: 0x0124   AES0 Key Word 5 Register                           */
+	u32 CRPT_AES0_KEY6;			/*!< Offset: 0x0128   AES0 Key Word 6 Register                           */
+	u32 CRPT_AES0_KEY7;			/*!< Offset: 0x012C   AES0 Key Word 7 Register                           */
+	u32 CRPT_AES0_IV0;			/*!< Offset: 0x0130   AES0 Initial Vector Word 0 Register                */
+	u32 CRPT_AES0_IV1;			/*!< Offset: 0x0134   AES0 Initial Vector Word 1 Register                */
+	u32 CRPT_AES0_IV2;			/*!< Offset: 0x0138   AES0 Initial Vector Word 2 Register                */
+	u32 CRPT_AES0_IV3;			/*!< Offset: 0x013C   AES0 Initial Vector Word 3 Register                */
+	u32 CRPT_AES0_SADDR;		/*!< Offset: 0x0140   AES0 Source Address Register                       */
+	u32 CRPT_AES0_DADDR;		/*!< Offset: 0x0144   AES0 Destination Address Register                  */
+	u32 CRPT_AES0_CNT;			/*!< Offset: 0x0148   AES0 Byte Count Register                           */
+	u32 CRPT_AES1_KEY0;			/*!< Offset: 0x014C   AES1 Key Word 0 Register                           */
+	u32 CRPT_AES1_KEY1;			/*!< Offset: 0x0150   AES1 Key Word 1 Register                           */
+	u32 CRPT_AES1_KEY2;			/*!< Offset: 0x0154   AES1 Key Word 2 Register                           */
+	u32 CRPT_AES1_KEY3;			/*!< Offset: 0x0158   AES1 Key Word 3 Register                           */
+	u32 CRPT_AES1_KEY4;			/*!< Offset: 0x015C   AES1 Key Word 4 Register                           */
+	u32 CRPT_AES1_KEY5;			/*!< Offset: 0x0160   AES1 Key Word 5 Register                           */
+	u32 CRPT_AES1_KEY6;			/*!< Offset: 0x0164   AES1 Key Word 6 Register                           */
+	u32 CRPT_AES1_KEY7;			/*!< Offset: 0x0168   AES1 Key Word 7 Register                           */
+	u32 CRPT_AES1_IV0;			/*!< Offset: 0x016C   AES1 Initial Vector Word 0 Register                */
+	u32 CRPT_AES1_IV1;			/*!< Offset: 0x0170   AES1 Initial Vector Word 1 Register                */
+	u32 CRPT_AES1_IV2;			/*!< Offset: 0x0174   AES1 Initial Vector Word 2 Register                */
+	u32 CRPT_AES1_IV3;			/*!< Offset: 0x0178   AES1 Initial Vector Word 3 Register                */
+	u32 CRPT_AES1_SADDR;		/*!< Offset: 0x017C   AES1 Source Address Register                       */
+	u32 CRPT_AES1_DADDR;		/*!< Offset: 0x0180   AES1 Destination Address Register                  */
+	u32 CRPT_AES1_CNT;			/*!< Offset: 0x0184   AES1 Byte Count Register                           */
+	u32 CRPT_AES2_KEY0;			/*!< Offset: 0x0188   AES2 Key Word 0 Register                           */
+	u32 CRPT_AES2_KEY1;			/*!< Offset: 0x018C   AES2 Key Word 1 Register                           */
+	u32 CRPT_AES2_KEY2;			/*!< Offset: 0x0190   AES2 Key Word 2 Register                           */
+	u32 CRPT_AES2_KEY3;			/*!< Offset: 0x0194   AES2 Key Word 3 Register                           */
+	u32 CRPT_AES2_KEY4;			/*!< Offset: 0x0198   AES2 Key Word 4 Register                           */
+	u32 CRPT_AES2_KEY5;			/*!< Offset: 0x019C   AES2 Key Word 5 Register                           */
+	u32 CRPT_AES2_KEY6;			/*!< Offset: 0x01A0   AES2 Key Word 6 Register                           */
+	u32 CRPT_AES2_KEY7;			/*!< Offset: 0x01A4   AES2 Key Word 7 Register                           */
+	u32 CRPT_AES2_IV0;			/*!< Offset: 0x01A8   AES2 Initial Vector Word 0 Register                */
+	u32 CRPT_AES2_IV1;			/*!< Offset: 0x01AC   AES2 Initial Vector Word 1 Register                */
+	u32 CRPT_AES2_IV2;			/*!< Offset: 0x01B0   AES2 Initial Vector Word 2 Register                */
+	u32 CRPT_AES2_IV3;			/*!< Offset: 0x01B4   AES2 Initial Vector Word 3 Register                */
+	u32 CRPT_AES2_SADDR;		/*!< Offset: 0x01B8   AES2 Source Address Register                       */
+	u32 CRPT_AES2_DADDR;		/*!< Offset: 0x01BC   AES2 Destination Address Register                  */
+	u32 CRPT_AES2_CNT;			/*!< Offset: 0x01C0   AES2 Byte Count Register                           */
+	u32 CRPT_AES3_KEY0;			/*!< Offset: 0x01C4   AES3 Key Word 0 Register                           */
+	u32 CRPT_AES3_KEY1;			/*!< Offset: 0x01C8   AES3 Key Word 1 Register                           */
+	u32 CRPT_AES3_KEY2;			/*!< Offset: 0x01CC   AES3 Key Word 2 Register                           */
+	u32 CRPT_AES3_KEY3;			/*!< Offset: 0x01D0   AES3 Key Word 3 Register                           */
+	u32 CRPT_AES3_KEY4;			/*!< Offset: 0x01D4   AES3 Key Word 4 Register                           */
+	u32 CRPT_AES3_KEY5;			/*!< Offset: 0x01D8   AES3 Key Word 5 Register                           */
+	u32 CRPT_AES3_KEY6;			/*!< Offset: 0x01DC   AES3 Key Word 6 Register                           */
+	u32 CRPT_AES3_KEY7;			/*!< Offset: 0x01E0   AES3 Key Word 7 Register                           */
+	u32 CRPT_AES3_IV0;			/*!< Offset: 0x01E4   AES3 Initial Vector Word 0 Register                */
+	u32 CRPT_AES3_IV1;			/*!< Offset: 0x01E8   AES3 Initial Vector Word 1 Register                */
+	u32 CRPT_AES3_IV2;			/*!< Offset: 0x01EC   AES3 Initial Vector Word 2 Register                */
+	u32 CRPT_AES3_IV3;			/*!< Offset: 0x01F0   AES3 Initial Vector Word 3 Register                */
+	u32 CRPT_AES3_SADDR;		/*!< Offset: 0x01F4   AES3 Source Address Register                       */
+	u32 CRPT_AES3_DADDR;		/*!< Offset: 0x01F8   AES3 Destination Address Register                  */
+	u32 CRPT_AES3_CNT;			/*!< Offset: 0x01FC   AES3 Byte Count Register                           */
+	u32 CRPT_TDES_CTL;			/*!< Offset: 0x0200   3DES engine parameter  setting                     */
+	u32 CRPT_TDES_STS;		    /*!< Offset: 0x0204   3DES flag setting                                  */
+	u32 CRPT_TDES0_KEY1H;	    /*!< Offset: 0x0208   DES/3DES Key 1 Higher Word Register                */
+	u32 CRPT_TDES0_KEY1L;	    /*!< Offset: 0x020C   DES/3DES Key 1 Lower Word Register                 */
+	u32 CRPT_TDES0_KEY2H;	    /*!< Offset: 0x0210   3DES Key 2 Higher Word Register                    */
+	u32 CRPT_TDES0_KEY2L;	    /*!< Offset: 0x0214   3DES Key 2 Lower Word Register                     */
+	u32 CRPT_TDES0_KEY3H;	    /*!< Offset: 0x0218   3DES Key 3 Higher Word Register                    */
+	u32 CRPT_TDES0_KEY3L;	    /*!< Offset: 0x021C   3DES Key 3 Lower Word Register                     */
+	u32 CRPT_TDES0_IVH;		    /*!< Offset: 0x0220   3DES Initial Vector Higher Word Register           */
+	u32 CRPT_TDES0_IVL;			/*!< Offset: 0x0224   3DES Initial Vector Lower Word Register            */
+	u32 CRPT_TDES0_SADDR;		/*!< Offset: 0x0228   DES/3DES Source Address Register                   */
+	u32 CRPT_TDES0_DADDR;		/*!< Offset: 0x022C   DES/3DES Destination Address Register              */
+	u32 CRPT_TDES0_CNT;			/*!< Offset: 0x0230   DES/3DES Block Count Register                      */
+	u32 CRPT_TDES_DATIN;		/*!< Offset: 0x0234   DES/3DES engine Input Word data Register           */
+	u32 CRPT_TDES_DATOUT;		/*!< Offset: 0x0238   DES/3DES engine Output Word data Register          */
+	u32 RESERVED3[3];		    /*!< Offset: 0x023C ~ 0x0244   Reserved                                  */
+	u32 CRPT_TDES1_KEY1H;		/*!< Offset: 0x0248   DES/3DES Key 1 Higher Word Register                */
+	u32 CRPT_TDES1_KEY1L; 		/*!< Offset: 0x024C   DES/3DES Key 1 Lower Word Register                 */
+	u32 CRPT_TDES1_KEY2H;		/*!< Offset: 0x0250   3DES Key 2 Higher Word Register                    */
+	u32 CRPT_TDES1_KEY2L;		/*!< Offset: 0x0254   3DES Key 2 Lower Word Register                     */
+	u32 CRPT_TDES1_KEY3H;		/*!< Offset: 0x0258   3DES Key 3 Higher Word Register                    */
+	u32 CRPT_TDES1_KEY3L;		/*!< Offset: 0x025C   3DES Key 3 Lower Word Register                     */
+	u32 CRPT_TDES1_IVH;		    /*!< Offset: 0x0260   3DES Initial Vector Higher Word Register           */
+	u32 CRPT_TDES1_IVL;		    /*!< Offset: 0x0264   3DES Initial Vector Lower Word Register            */
+	u32 CRPT_TDES1_SADDR;	    /*!< Offset: 0x0268   DES/3DES Source Address Register                   */
+	u32 CRPT_TDES1_DADDR;	    /*!< Offset: 0x026C   DES/3DES Destination Address Register              */
+	u32 CRPT_TDES1_CNT;		    /*!< Offset: 0x0270   DES/3DES Block Count Register                      */
+	u32 RESERVED4[5];		    /*!< Offset: 0x0274 ~ 0x0284   Reserved                                  */
+	u32 CRPT_TDES2_KEY1H;		/*!< Offset: 0x0288   DES/3DES Key 1 Higher Word Register                */
+	u32 CRPT_TDES2_KEY1L;		/*!< Offset: 0x028C   DES/3DES Key 1 Lower Word Register                 */
+	u32 CRPT_TDES2_KEY2H;		/*!< Offset: 0x0290   3DES Key 2 Higher Word Register                    */
+	u32 CRPT_TDES2_KEY2L;		/*!< Offset: 0x0294   3DES Key 2 Lower Word Register                     */
+	u32 CRPT_TDES2_KEY3H;		/*!< Offset: 0x0298   3DES Key 3 Higher Word Register                    */
+	u32 CRPT_TDES2_KEY3L;		/*!< Offset: 0x029C   3DES Key 3 Lower Word Register                     */
+	u32 CRPT_TDES2_IVH;		    /*!< Offset: 0x02A0   3DES Initial Vector Higher Word Register           */
+	u32 CRPT_TDES2_IVL;		    /*!< Offset: 0x02A4   3DES Initial Vector Lower Word Register            */
+	u32 CRPT_TDES2_SADDR;	    /*!< Offset: 0x02A8   DES/3DES Source Address Register                   */
+	u32 CRPT_TDES2_DADDR;	    /*!< Offset: 0x02AC   DES/3DES Destination Address Register              */
+	u32 CRPT_TDES2_CNT;		    /*!< Offset: 0x02B0   DES/3DES Block Count Register                      */
+	u32 RESERVED5[5];		    /*!< Offset: 0x02B4 ~ 0x02C4   Reserved                                  */
+	u32 CRPT_TDES3_KEY1H;		/*!< Offset: 0x02C8   DES/3DES Key 1 Higher Word Register                */
+	u32 CRPT_TDES3_KEY1L;		/*!< Offset: 0x02CC   DES/3DES Key 1 Lower Word Register                 */
+	u32 CRPT_TDES3_KEY2H;		/*!< Offset: 0x02D0   3DES Key 2 Higher Word Register                    */
+	u32 CRPT_TDES3_KEY2L;		/*!< Offset: 0x02D4   3DES Key 2 Lower Word Register                     */
+	u32 CRPT_TDES3_KEY3H;		/*!< Offset: 0x02D8   3DES Key 3 Higher Word Register                    */
+	u32 CRPT_TDES3_KEY3L;		/*!< Offset: 0x02DC   3DES Key 3 Lower Word Register                     */
+	u32 CRPT_TDES3_IVH;		    /*!< Offset: 0x02E0   3DES Initial Vector Higher Word Register           */
+	u32 CRPT_TDES3_IVL;		    /*!< Offset: 0x02E4   3DES Initial Vector Lower Word Register            */
+	u32 CRPT_TDES3_SADDR;	    /*!< Offset: 0x02E8   DES/3DES Source Address Register                   */
+	u32 CRPT_TDES3_DADDR;	    /*!< Offset: 0x02EC   DES/3DES Destination Address Register              */
+	u32 CRPT_TDES3_CNT;		    /*!< Offset: 0x02F0   DES/3DES Block Count Register                      */
+	u32 RESERVED6[3];		    /*!< Offset: 0x02F4 ~ 0x02FC   Reserved                                  */
+	u32 CRPT_HMAC_CTL;		    /*!< Offset: 0x0300   HMAC/SHA engine parameter setting                  */
+	u32 CRPT_HMAC_STS;		    /*!< Offset: 0x0304   HMAC/SHA status flag                               */
+	u32 CRPT_HMAC_DGST[16];		/*!< Offset: 0x0308   HMAC/SHA digest message word 0~15                  */
+	u32 CRPT_HMAC_KEYCNT;		/*!< Offset: 0x0348   HMAC/SHA key byte length                           */
+	u32 CRPT_HMAC_SADDR;	    /*!< Offset: 0x034C   HMAC DMA Source Address Register                   */
+	u32 CRPT_HMAC_DMACNT;		/*!< Offset: 0x0350   HMAC DMA count                                     */
+	u32 CRPT_HMAC_DATIN;		/*!< Offset: 0x0354   HMAC software write to engine port                 */
+};
+
+struct nuc970_aes_regs
+{
+	u32 key[8];
+	u32 iv[4];
+	u32 src_addr;
+	u32 dst_addr;
+	u32 count;
+};
+
+struct nuc970_tdes_regs
+{
+	u32 key[6];
+	u32 iv[2];
+	u32 src_addr;
+	u32 dst_addr;
+	u32 count;
+};
+
+
+/********************* Bit definition of CRPT_INTEN  ************************/
+#define AESIEN						((u32)0x00000001)			/*!<AES DMA finish interrupt flag enable */
+#define AESERRIEN					((u32)0x00000002)			/*!<AES error flag enable */
+#define TDESIEN						((u32)0x00000100)			/*!<TDES interrupt source enable */
+#define TDESERRIEN					((u32)0x00000200)			/*!<TDES error flag enable */
+#define PRNGIEN						((u32)0x00010000)			/*!<PRNG finish interrupt enable */
+#define HMACIEN						((u32)0x01000000)			/*!<HMAC interrupt enable */
+#define HMACERRIEN					((u32)0x02000000)			/*!<HMAC error interrupt enable */
+
+/********************* Bit definition of CRPT_INTSTS *******************/
+#define AESIF						((u32)0x00000001)			/*!<AES finish interrupt flag */
+#define AESERRIF					((u32)0x00000002)			/*!<AES error flag */
+#define TDESIF						((u32)0x00000100)			/*!<TDES finish interrupt flag */
+#define TDESERRIF					((u32)0x00000200)			/*!<TDES error flag */
+#define PRNGIF						((u32)0x00010000)			/*!<PRNG finish interrupt flag */
+#define HMACIF						((u32)0x01000000)			/*!<HMAC finish interrupt flag */
+#define HMACERRIF					((u32)0x02000000)		/*!<HMAC error flag */
+
+/********************* Bit definition of CRPT_PRNG_CTL *******************/
+#define PRNG_START					((u32)0x00000001)			/*!<Write 1 start PRNG engine generate new KEY and store KEYx register. */
+#define SEEDRLD						((u32)0x00000002)			/*!1: reload new seed; 0: generate key base original seed. */
+#define PRNG_KEYSZ_MASK				((u32)0x0000000C)			/*!<PRNG KEY SIZE bit mask */
+#define PRNG_KEYSZ_64			  	((u32)0x00000000)			/*!<PRNG 64 bits key */
+#define PRNG_KEYSZ_128  			((u32)0x00000004)			/*!<PRNG 128 bits key */
+#define PRNG_KEYSZ_192  			((u32)0x00000008)			/*!<PRNG 192 bits key */
+#define PRNG_KEYSZ_256  			((u32)0x0000000C)			/*!<PRNG 256 bits key */
+#define PRNG_BUSY					((u32)0x00000100)			/*!<read only, 1:  indicate the PRNG engine under generating KEY */
+
+
+/********************* Bit definition of CRPT_AES_CTL *******************/
+#define AES_START					((u32)0x00000001)			/*!<Write 1, AES engine starting. AES_BUSY flag will be set. */
+#define AES_STOP					((u32)0x00000002)			/*!<Write 1,  stop  AES engine instantly. */
+#define AES_KEYSZ_MASK 				((u32)0x0000000C)			/*!<AES KEY_SIZE bit mask */
+#define AES_KEYSZ_128				((u32)0x00000000)			/*!<AES 128 bits key */
+#define AES_KEYSZ_192				((u32)0x00000004)			/*!<AES 192 bits key */
+#define AES_KEYSZ_256				((u32)0x00000008)			/*!<AES 256 bits key */
+#define AES_EXTERNAL_KEY			((u32)0x00000010)			/*!<1: AES KEY use extend key. 0:  AES KEY source form  AES_KEYx registers. */
+#define AES_DMALAST					((u32)0x00000020)			/*!<Index current operation is  last one. */
+#define AES_DMACSCAD				((u32)0x00000040)			/*!<Cascade AES encrypt/decrypt result */
+#define AES_DMAEN					((u32)0x00000080)			/*!<enable AES DMA engine */
+#define AES_OPMODE_MASK		 		((u32)0x0000FF00)			/*!<AES engine operation mode bit mask */
+#define AES_ECB_MODE				((u32)0x00000000)			/*!<AES ECB mode */
+#define AES_CBC_MODE				((u32)0x00000100)			/*!<AES CBC mode */
+#define AES_CFB_MODE				((u32)0x00000200)			/*!<AES CFB mode */
+#define AES_OFB_MODE				((u32)0x00000300)			/*!<AES OFB mode */
+#define AES_CTR_MODE				((u32)0x00000400)			/*!<AES CTR mode */
+#define AES_CBCCS1_MODE				((u32)0x00001000)			/*!<AES CBC CS1 mode */
+#define AES_CBCCS2_MODE				((u32)0x00001100)			/*!<AES CBC CS2 mode */
+#define AES_CBCCS3_MODE				((u32)0x00001200)			/*!<AES CBC CS3 mode */
+#define AES_ENCRYPT					((u32)0x00010000)			/*!<AES engine execute encryption */
+#define AES_DECRYPT					((u32)0x00000000)			/*!<AES engine execute decryption */
+#define AES_OUTSWAP					((u32)0x00400000)			/*!<AES engine output data transform */
+#define AES_INSWAP					((u32)0x00800000)			/*!<AES engine input data transform */
+#define AES_CHANNEL_MASK			((u32)0x03000000)			/*!<AES working channel bit mask */
+#define AES_CHANNEL0				((u32)0x00000000)			/*!<AES Current  control register  setting on channel 0 */
+#define AES_CHANNEL1				((u32)0x01000000)			/*!<AES Current  control register  setting on channel 0 */
+#define AES_CHANNEL2				((u32)0x02000000)			/*!<AES Current  control register  setting on channel 0 */
+#define AES_CHANNEL3				((u32)0x03000000)			/*!<AES Current  control register  setting on channel 0 */
+#define AES_KEYPRT_MASK				((u32)0xFC000000)			/*!<AES unprotect key bit mask */
+#define AES_KEY_UNPRT        		((u32)0x58000000)			/*!<Set AES unprotect key */
+#define AES_KEY_PRT					((u32)0x80000000)			/*!<AES key protect */
+
+/********************* Bit definition of CRPT_AES_STS *******************/
+#define AES_BUSY					((u32)0x00000001)			/*!<AES engine under archiving */
+#define AES_INBUFEMPTY				((u32)0x00000100)			/*!<AES input buffer empty */
+#define AES_INBUFFULL				((u32)0x00000200)			/*!<AES input buffer full */
+#define AES_INBUFERR				((u32)0x00000400)			/*!<ERROR during feed AES engine data. */
+#define AES_CNTERR					((u32)0x00001000)			/*!<AES_CNT setting error */
+#define AES_OUTBUFEMPTY				((u32)0x00010000)			/*!<AES output buffer empty */
+#define AES_OUTBUFFULL				((u32)0x00020000)			/*!<AES output buffer full */
+#define AES_OUTBUFERR				((u32)0x00040000)			/*!<ERROR during get AES engine result */
+#define AES_BUSERR					((u32)0x00100000)			/*!<AES bus error */
+
+/********************* Bit definition of CRPT_TDES_CTL *******************/
+#define TDES_START					((u32)0x00000001)			/*!<Write 1, TDES engine starting. AES_BUSY flag will be set. */
+#define TDES_STOP					((u32)0x00000002)			/*!<Write 1 , stop TDES engine instantly. */
+#define TDES_TMODE			 		((u32)0x00000004)			/*!<Tripple DES mode */
+#define TDES_3KEYS			 		((u32)0x00000008)			/*!<enable triple KEY in TDES engine */
+#define TDES_EXTERNAL_KEY			((u32)0x00000010)			/*!<TDES KEY use extend key */
+#define TDES_DMALAST				((u32)0x00000020)			/*!<TDES last DMA cascade round */
+#define TDES_DMACSCAD				((u32)0x00000040)			/*!<TDES DMA cascade mode */
+#define TDES_DMAEN					((u32)0x00000080)			/*!<enable TDES_DMA engine */
+#define TDES_OPMODE_MASK			((u32)0x00000700)			/*!<TDES engine operation mode bit mask */
+#define TDES_ECB_MODE				((u32)0x00000000)			/*!<ECB mode */
+#define TDES_CBC_MODE				((u32)0x00000100)			/*!<CBC mode */
+#define TDES_CFB_MODE				((u32)0x00000200)			/*!<CFB mode */
+#define TDES_OFB_MODE				((u32)0x00000300)			/*!<OFB mode */
+#define TDES_CTR_MODE				((u32)0x00000400)			/*!<CTR mode */
+#define TDES_ENCRYPT				((u32)0x00010000)			/*!<TDES engine execute encryption */
+#define TDES_DECRYPT				((u32)0x00000000)			/*!<TDES engine execute decryption */
+#define TDES_BLKSWAP				((u32)0x00200000)			/*!<TDES engine Swap High/Low word */
+#define TDES_OUTSWAP				((u32)0x00400000)			/*!<TDES engine output data transform */
+#define TDES_INSWAP					((u32)0x00800000)			/*!<TDES engine input data transform */
+#define TDES_CHANNEL_MASK			((u32)0x03000000)			/*!<TDES working channel bit mask */
+#define TDES_CHANNEL_0				((u32)0x00000000)			/*!<TDES Current  control register  setting on channel 0 */
+#define TDES_CHANNEL_1				((u32)0x01000000)			/*!<TDES Current  control register  setting on channel 0 */
+#define TDES_CHANNEL_2				((u32)0x02000000)			/*!<TDES Current  control register  setting on channel 0 */
+#define TDES_CHANNEL_3				((u32)0x03000000)			/*!<TDES Current  control register  setting on channel 0 */
+#define TDES_KEYPRT_MASK			((u32)0xFC000000)			/*!<TDES unprotect key bit mask */
+#define TDES_KEYUNPRT		       	((u32)0x58000000)			/*!<Set TDES unprotect key */
+#define TDES_KEYPRT					((u32)0x80000000)			/*!<TDES key protect */
+
+/********************* Bit definition of CRPT_TDES_STS *******************/
+#define TDES_BUSY					((u32)0x00000001)			/*!<TDES engine under archiving */
+#define TDES_INBUFEMPTY				((u32)0x00000100)	/*!<TDES input buffer empty */
+#define TDES_INBUFFULL				((u32)0x00000200)	/*!<TDES input buffer full */
+#define TDES_INBUFERR				((u32)0x00000400)			/*!<ERROR during feed TDES engine data. */
+#define TDES_OUTBUFEMPTY			((u32)0x00010000)	/*!<TDES output buffer empty */
+#define TDES_OUTBUFFULL				((u32)0x00020000)	/*!<TDES output buffer full */
+#define TDES_OUTBUFERR				((u32)0x00040000)	/*!<ERROR during get TDES engine result */
+#define TDES_BUSERR					((u32)0x00100000)			/*!<TDES bus error */
+
+/********************* Bit definition of HMAC_CTL ********************/
+#define HMAC_START					((u32)0x00000001)			/*!<HMAC engine starting */
+#define HMAC_STOP					((u32)0x00000002)			/*!<HMAC engine stop */
+#define HMAC_EN						((u32)0x00000010)			/*!<execute HMAC function */
+#define HMAC_DMALAST				((u32)0x00000020)			/*!<last DMA cascade round */
+#define HMAC_DMAEN					((u32)0x00000080)			/*!<enable HMAC_DMA engine */
+#define HMAC_OPMODE_MASK			((u32)0x00000700)			/*!<HMAC engine operation modes mask */
+#define HMAC_SHA1					((u32)0x00000000)			/*!<SHA1 */
+#define HMAC_SHA224					((u32)0x00000500)			/*!<SHA224 */
+#define HMAC_SHA256					((u32)0x00000400)			/*!<SHA256 */
+#define HMAC_SHA384					((u32)0x00000700)			/*!<SHA384 */
+#define HMAC_SHA512					((u32)0x00000600)			/*!<SHA512 */
+#define HMAC_OUTSWAP				((u32)0x00400000)			/*!<HMAC engine output data transform */
+#define HMAC_INSWAP					((u32)0x00800000)			/*!<HMAC engine input data transform */
+
+/********************* Bit definition of HMAC_FLAG *******************/
+#define HMAC_BUSY					((u32)0x00000001)			/*!<HMAC engine busy */
+#define HMAC_DMABUSY				((u32)0x00000002)			/*!<HMAC engine is under active */
+#define HMAC_DMAERR					((u32)0x00000100)			/*!<HMAC DMA error */
+#define HMAC_DINREQ					((u32)0x00010000)			/*!<HMAC_SOFTWARE mode Data input  request */
+
+
+#endif /* __ASM_ARM_REGS_IPSEC_H */
+
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-ebi.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-ebi.h
@@ -0,0 +1,48 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-ebi.h
+ *
+ * Copyright (c) 2015 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_EBI_H
+#define __ASM_ARCH_REGS_EBI_H
+
+#define REG_EBI_CTL		(NUC970_VA_EBI + 0x00)
+#define REG_EBI_BNKCTL(x)	(NUC970_VA_EBI + 0x18 + (x) * 0x4)
+
+#define NUC970_EBI_8BIT		0x00000001
+#define NUC970_EBI_16BIT	0x00000002
+
+#define NUC970_EBI_80TYPE_nBE_WRITE	0x00000000
+#define NUC970_EBI_80TYPE_nWE_WRITE	0x01000000
+#define NUC970_EBI_68TYPE		0x00080000
+
+
+#define NUC970_EBI_TYPE_MASK 0x01080000
+static inline void nuc970_set_ebi_mode(unsigned int bank, unsigned int mode)
+{
+	__raw_writel((__raw_readl(REG_EBI_CTL) & ~(NUC970_EBI_TYPE_MASK << bank)) | (mode << bank), REG_EBI_CTL);
+}
+
+#define NUC970_EBI_ATTRIB_MASK 0xFFFF0003
+// size is not used in NUC970 and should set 0
+static inline void nuc970_set_ebi_attrib(unsigned int bank, unsigned int base, unsigned int size, unsigned int width)
+{
+	__raw_writel((__raw_readl(REG_EBI_BNKCTL(bank)) & ~NUC970_EBI_ATTRIB_MASK) | ((base << 1) & 0xFFF80000) | width, REG_EBI_BNKCTL(bank));
+}
+
+#define NUC970_EBI_TIMING_MASK 0x00007FFC
+static inline void nuc970_set_ebi_timing(unsigned int bank, unsigned int tACC, unsigned int tCOH, unsigned int tACS, unsigned int tCOS)
+{	
+	__raw_writel((__raw_readl(REG_EBI_BNKCTL(bank)) & ~NUC970_EBI_TIMING_MASK) | (tACC << 11) | (tCOH << 8) | (tACS << 5) | (tCOS << 2), REG_EBI_BNKCTL(bank));
+}
+
+
+#endif /*  __ASM_ARCH_REGS_EBI_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-etimer.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-etimer.h
@@ -0,0 +1,29 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-etimer.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_ETIMER_H
+#define __ASM_ARCH_REGS_ETIMER_H
+
+/* ETimer Registers */
+
+
+#define REG_ETMR_CTL(x)		(NUC970_VA_ETIMER + 0x100 * (x) + 0x00)
+#define REG_ETMR_PRECNT(x)	(NUC970_VA_ETIMER + 0x100 * (x) + 0x04)
+#define REG_ETMR_CMPR(x)	(NUC970_VA_ETIMER + 0x100 * (x) + 0x08)
+#define REG_ETMR_IER(x)		(NUC970_VA_ETIMER + 0x100 * (x) + 0x0C)
+#define REG_ETMR_ISR(x)		(NUC970_VA_ETIMER + 0x100 * (x) + 0x10)
+#define REG_ETMR_DR(x)		(NUC970_VA_ETIMER + 0x100 * (x) + 0x14)
+#define REG_ETMR_TCAP(x)	(NUC970_VA_ETIMER + 0x100 * (x) + 0x18)
+
+
+#endif /*  __ASM_ARCH_REGS_ETIMER_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-fmi.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-fmi.h
@@ -0,0 +1,135 @@
+/* linux/include/asm-arm/arch-nuc900/nuc900_reg.h
+ *
+ * Copyright (c) 2008 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Changelog:
+ *
+ *   2006/08/26     vincen.zswan add this file for nuvoton nuc900 MCU ip REG.
+ */
+
+#ifndef __ASM_ARCH_REGS_FMI_H
+#define __ASM_ARCH_REGS_FMI_H
+
+#define FMI_BA   			NUC970_VA_FMI /* Flash Memory Card Interface */
+
+#define REG_NAND_FB0		(FMI_BA+0x000)  /* DMAC Control and Status Register */
+#define REG_NAND_DMACCSR	(FMI_BA+0x400)  /* DMAC Control and Status Register */
+#define REG_NAND_DMACSAR	(FMI_BA+0x408)  /* DMAC Transfer Starting Address Register */
+#define REG_NAND_DMACBCR	(FMI_BA+0x40C)  /* DMAC Transfer Byte Count Register */
+#define REG_NAND_DMACIER	(FMI_BA+0x410)  /* DMAC Interrupt Enable Register */
+#define REG_NAND_DMACISR	(FMI_BA+0x414)  /* DMAC Interrupt Status Register */
+
+#define REG_NAND_FMICSR		(FMI_BA+0x800)   /* Global Control and Status Register */
+#define REG_NAND_FMIIER	    	(FMI_BA+0x804)   /* Global Interrupt Control Register */
+#define REG_NAND_FMIISR	    	(FMI_BA+0x808)   /* Global Interrupt Status Register */
+
+/* eMMC Registers */
+#define REG_EMMCCSR	    	(FMI_BA+0x820)   /* SD control and status register */
+#define REG_EMMCARG	    	(FMI_BA+0x824)   /* SD command argument register */
+#define REG_EMMCIER		(FMI_BA+0x828)   /* SD interrupt enable register */
+#define REG_EMMCISR		(FMI_BA+0x82C)   /* SD interrupt status register */
+#define REG_EMMCRSP0		(FMI_BA+0x830)   /* SD receive response token register 0 */
+#define REG_EMMCRSP1		(FMI_BA+0x834)   /* SD receive response token register 1 */
+#define REG_EMMCBLEN		(FMI_BA+0x838)   /* SD block length register */
+#define REG_EMMCTMOUT		(FMI_BA+0x83C)   /* SD block length register */
+
+/* NAND-type Flash Registers */
+#define REG_SMCSR	        (FMI_BA+0x8A0)   /* NAND Flash Control and Status Register */
+#define REG_SMTCR	        (FMI_BA+0x8A4)   /* NAND Flash Timing Control Register */
+#define REG_SMIER	        (FMI_BA+0x8A8)   /* NAND Flash Interrupt Control Register */
+#define REG_SMISR	        (FMI_BA+0x8AC)   /* NAND Flash Interrupt Status Register */
+#define REG_SMCMD	        (FMI_BA+0x8B0)   /* NAND Flash Command Port Register */
+#define REG_SMADDR	        (FMI_BA+0x8B4)   /* NAND Flash Address Port Register */
+#define REG_SMDATA		    (FMI_BA+0x8B8)   /* NAND Flash Data Port Register */
+#define REG_SMREACTL        (FMI_BA+0x8BC)   /* NAND Flash Smart-Media Redundant Area Control Register */
+#define REG_NFECR           (FMI_BA+0x8C0)   /* NAND Flash Extend Control Regsiter */
+#define REG_SMECC_ST0	    (FMI_BA+0x8D0)	 /* Smart-Media ECC Error Status 0 */
+#define REG_SMECC_ST1	    (FMI_BA+0x8D4)	 /* Smart-Media ECC Error Status 1 */
+#define REG_SMECC_ST2	    (FMI_BA+0x8D8)	 /* Smart-Media ECC Error Status 2 */
+#define REG_SMECC_ST3	    (FMI_BA+0x8DC)	 /* Smart-Media ECC Error Status 3 */
+#define REG_SMPROT_ADDR0    (FMI_BA+0x8E0)  /* Smart-Media Protect region end address 0 */
+#define REG_SMPROT_ADDR1    (FMI_BA+0x8E4)  /* Smart-Media Protect region end address 1 */
+
+/* NAND-type Flash BCH Error Address Registers */
+#define REG_BCH_ECC_ADDR0	(FMI_BA+0x900)  /* BCH error byte address 0 */
+#define REG_BCH_ECC_ADDR1	(FMI_BA+0x904)  /* BCH error byte address 1 */
+#define REG_BCH_ECC_ADDR2	(FMI_BA+0x908)  /* BCH error byte address 2 */
+#define REG_BCH_ECC_ADDR3	(FMI_BA+0x90C)  /* BCH error byte address 3 */
+#define REG_BCH_ECC_ADDR4	(FMI_BA+0x910)  /* BCH error byte address 4 */
+#define REG_BCH_ECC_ADDR5	(FMI_BA+0x914)  /* BCH error byte address 5 */
+#define REG_BCH_ECC_ADDR6	(FMI_BA+0x918)  /* BCH error byte address 6 */
+#define REG_BCH_ECC_ADDR7	(FMI_BA+0x91C)  /* BCH error byte address 7 */
+#define REG_BCH_ECC_ADDR8	(FMI_BA+0x920)  /* BCH error byte address 8 */
+#define REG_BCH_ECC_ADDR9	(FMI_BA+0x924)  /* BCH error byte address 9 */
+#define REG_BCH_ECC_ADDR10	(FMI_BA+0x928)  /* BCH error byte address 10 */
+#define REG_BCH_ECC_ADDR11	(FMI_BA+0x92C)  /* BCH error byte address 11 */
+
+/* NAND-type Flash BCH Error Data Registers */
+#define REG_BCH_ECC_DATA0	(FMI_BA+0x960)  /* BCH error byte data 0 */
+#define REG_BCH_ECC_DATA1	(FMI_BA+0x964)  /* BCH error byte data 1 */
+#define REG_BCH_ECC_DATA2	(FMI_BA+0x968)  /* BCH error byte data 2 */
+#define REG_BCH_ECC_DATA3	(FMI_BA+0x96C)  /* BCH error byte data 3 */
+#define REG_BCH_ECC_DATA4	(FMI_BA+0x970)  /* BCH error byte data 4 */
+#define REG_BCH_ECC_DATA5	(FMI_BA+0x974)  /* BCH error byte data 5 */
+
+/* NAND-type Flash Redundant Area Registers */
+#define REG_SMRA0			(FMI_BA+0xA00)  /* Smart-Media Redundant Area Register */
+#define REG_SMRA1			(FMI_BA+0xA04)  /* Smart-Media Redundant Area Register */
+
+/* FMI Global Control and Status Register(FMICSR) */
+#define FMICSR_SWRST        (1)
+#define FMICSR_EMMCEN       (1<<1)
+
+/* FMI Global Interrupt Control Register(FMIIER) */
+#define FMIIER_DTAIE        (1)
+
+/* FMI Global Interrupt Status Register (FMIISR) */
+#define FMIISR_DTAIF        (1)
+
+/* EMMC Control and Status Register (EMMCCSR) */
+#define EMMCCSR_CO_EN         (1)
+#define EMMCCSR_RI_EN         (1<<1)
+#define EMMCCSR_DI_EN         (1<<2)
+#define EMMCCSR_DO_EN         (1<<3)
+#define EMMCCSR_R2_EN         (1<<4)
+#define EMMCCSR_CLK74_OE      (1<<5)
+#define EMMCCSR_CLK8_OE       (1<<6)
+#define EMMCCSR_SW_RST        (1<<14)
+#define EMMCCSR_DBW           (1<<15)
+
+/* EMMC Interrupt Control Register (EMMCIER) */
+#define EMMCIER_BLKD_IE       (1)
+#define EMMCIER_CRC_IE        (1<<1)
+#define EMMCIER_RITO_IE       (1<<12)
+#define EMMCIER_DITO_IE       (1<<13)
+
+/* EMMC Interrupt Status Register (EMMCISR) */
+#define EMMCISR_BLKD_IF       (1)
+#define EMMCISR_CRC_IF        (1<<1)
+#define EMMCISR_CRC_7         (1<<2)
+#define EMMCISR_CRC_16        (1<<3)
+#define EMMCISR_SDDAT0        (1<<7)
+#define EMMCISR_RITO_IF       (1<<12)
+#define EMMCISR_DITO_IF       (1<<13)
+
+/* DMAC Control and Status Register (DMACCSR) */
+#define DMACCSR_DMAC_EN     (1)
+#define DMACCSR_SWRST       (1<<1)
+#define DMACCSR_SGEN        (1<<3)
+#define DMACCSR_FMIBUSY     (1<<9)
+
+/* DMAC Interrupt Enable Register (DMACIER) */
+#define DMACIER_TABORTIE   (1)
+#define DMACIER_WEOTIE     (1<<1)
+
+/* DMAC Interrupt Status Register (DMACISR) */
+#define DMACISR_TABORTIF   (1)
+#define DMACISR_WEOTIF     (1<<1)
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-gcr.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-gcr.h
@@ -0,0 +1,62 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-gcr.h
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_GCR_H
+#define __ASM_ARCH_REGS_GCR_H
+
+/* Global control registers */
+
+#define GCR_BA		NUC970_VA_GCR
+
+#define REG_PDID     	(GCR_BA+0x000)  /* Product Identifier Register */
+#define REG_PWRON	(GCR_BA+0x004)  /* Power-On Setting Register */
+#define REG_ARBCON	(GCR_BA+0x008)  /* Arbitration Control Register */
+#define REG_LVRDCR 	(GCR_BA+0x020)  /* Low Voltage Reset & Detect Control Register */
+#define REG_MISCFCR  	(GCR_BA+0x030)  /* Miscellaneous Function Control Register */
+#define REG_MISCIER 	(GCR_BA+0x040)  /* Miscellaneous Interrupt Enable Register */
+#define REG_MISCISR 	(GCR_BA+0x044)  /* Miscellaneous Interrupt Status Register */
+#define REG_ROMSUM0 	(GCR_BA+0x048)  /* Internal ROM BIST Checksum Register 0 */
+#define REG_ROMSUM1 	(GCR_BA+0x04C)  /* Internal ROM BIST Checksum Register 1 */
+#define REG_WKUPSER	(GCR_BA+0x058)  /* System Wakeup Source Enable Register */
+#define REG_WKUPSSR	(GCR_BA+0x05C)  /* System Wakeup Source Status Register */
+#define REG_AHBIPRST	(GCR_BA+0x060)  /* AHB IP Reset Control Register */
+#define REG_APBIPRST0	(GCR_BA+0x064)  /* APB IP Reset Control Register 0 */
+#define REG_APBIPRST1	(GCR_BA+0x068)  /* APB IP Reset Control Register 1 */
+#define REG_RSTSTS	(GCR_BA+0x06C)  /* Reset Source Active Status Register */
+
+#define REG_MFP_GPA_L	(GCR_BA+0x070)  /* GPIOA Low Byte Multiple Function Control Register */
+#define REG_MFP_GPA_H	(GCR_BA+0x074)  /* GPIOA High Byte Multiple Function Control Register */
+#define REG_MFP_GPB_L	(GCR_BA+0x078)  /* GPIOB Low Byte Multiple Function Control Register */
+#define REG_MFP_GPB_H	(GCR_BA+0x07C)  /* GPIOB High Byte Multiple Function Control Register */
+#define REG_MFP_GPC_L	(GCR_BA+0x080)  /* GPIOC Low Byte Multiple Function Control Register */
+#define REG_MFP_GPC_H	(GCR_BA+0x084)  /* GPIOC High Byte Multiple Function Control Register */
+#define REG_MFP_GPD_L	(GCR_BA+0x088)  /* GPIOD Low Byte Multiple Function Control Register */
+#define REG_MFP_GPD_H	(GCR_BA+0x08C)  /* GPIOD High Byte Multiple Function Control Register */
+#define REG_MFP_GPE_L	(GCR_BA+0x090)  /* GPIOE Low Byte Multiple Function Control Register */
+#define REG_MFP_GPE_H	(GCR_BA+0x094)  /* GPIOE High Byte Multiple Function Control Register */
+#define REG_MFP_GPF_L	(GCR_BA+0x098)  /* GPIOF Low Byte Multiple Function Control Register */
+#define REG_MFP_GPF_H	(GCR_BA+0x09C)  /* GPIOF High Byte Multiple Function Control Register */
+#define REG_MFP_GPG_L	(GCR_BA+0x0A0)  /* GPIOG Low Byte Multiple Function Control Register */
+#define REG_MFP_GPG_H	(GCR_BA+0x0A4)  /* GPIOG High Byte Multiple Function Control Register */
+#define REG_MFP_GPH_L	(GCR_BA+0x0A8)  /* GPIOH Low Byte Multiple Function Control Register */
+#define REG_MFP_GPH_H	(GCR_BA+0x0AC)  /* GPIOH High Byte Multiple Function Control Register */
+#define REG_MFP_GPI_L	(GCR_BA+0x0B0)  /* GPIOI Low Byte Multiple Function Control Register */
+#define REG_MFP_GPI_H	(GCR_BA+0x0B4)  /* GPIOI High Byte Multiple Function Control Register */
+#define REG_MFP_GPJ_L	(GCR_BA+0x0B8)  /* GPIOJ Low Byte Multiple Function Control Register */
+#define REG_DDR_DS_CR	(GCR_BA+0x0E0)  /* DDR I/O Driving Strength Control Register */
+#define REG_PORDISCR    (GCR_BA+0x100)  /* Power-On-Reset Disable Control Register */
+#define REG_ICEDBGCR    (GCR_BA+0x104)  /* ICE Debug Interface Control Register */
+#define REG_WRPRTR	(GCR_BA+0x1FC)  /* Register Write-Protection Control Register */
+
+
+#endif /*  __ASM_ARCH_REGS_GCR_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-gdma.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-gdma.h
@@ -0,0 +1,72 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-gdma.h
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_GDMA_H
+#define __ASM_ARCH_REGS_GDMA_H
+
+/* GDMA Registers */
+
+#define		 	GDMA_BA							NUC970_VA_GDMA
+
+#define     GDMA_CTL				(0x000)  /* Channel 0/1 Control Register */
+#define     GDMA_SRCB				(0x004)  /* Channel 0/1 Source Base Address Register */
+#define     GDMA_DSTB				(0x008)  /* Channel 0/1 Destination Base Address Register */
+#define     GDMA_TCNT				(0x00C)  /* Channel 0/1 Transfer Count Register */
+#define     GDMA_CSRC				(0x010)  /* Channel 0/1 Current Source Address Register */
+#define     GDMA_CDST				(0x014)  /* Channel 0/1 Current Destination Address Register */
+#define     GDMA_CTCNT			(0x018)  /* Channel 0/1 Current Transfer Count Register */
+#define     GDMA_DADR				(0x01C)  /* Channel 0/1 Descriptor Address Register */
+
+#define     REG_GDMA_CTL0				(GDMA_BA+0x000)  /* Channel 0 Control Register */
+#define     REG_GDMA_SRCB0			(GDMA_BA+0x004)  /* Channel 0 Source Base Address Register */
+#define     REG_GDMA_DSTB0			(GDMA_BA+0x008)  /* Channel 0 Destination Base Address Register */
+#define     REG_GDMA_TCNT0			(GDMA_BA+0x00C)  /* Channel 0 Transfer Count Register */
+#define     REG_GDMA_CSRC0			(GDMA_BA+0x010)  /* Channel 0 Current Source Address Register */
+#define     REG_GDMA_CDST0			(GDMA_BA+0x014)  /* Channel 0 Current Destination Address Register */
+#define     REG_GDMA_CTCNT0			(GDMA_BA+0x018)  /* Channel 0 Current Transfer Count Register */
+#define     REG_GDMA_DADR0			(GDMA_BA+0x01C)  /* Channel 0 Descriptor Address Register */
+
+#define     REG_GDMA_CTL1				(GDMA_BA+0x020)  /* Channel 1 Control Register */
+#define     REG_GDMA_SRCB1			(GDMA_BA+0x024)  /* Channel 1 Source Base Address Register */
+#define     REG_GDMA_DSTB1			(GDMA_BA+0x028)  /* Channel 1 Destination Base Address Register */
+#define     REG_GDMA_TCNT1			(GDMA_BA+0x02C)  /* Channel 1 Transfer Count Register */
+#define     REG_GDMA_CSRC1			(GDMA_BA+0x030)  /* Channel 1 Current Source Address Register */
+#define     REG_GDMA_CDST1			(GDMA_BA+0x034)  /* Channel 1 Current Destination Address Register */
+#define     REG_GDMA_CTCNT1			(GDMA_BA+0x038)  /* Channel 1 Current Transfer Count Register */
+#define     REG_GDMA_DADR1			(GDMA_BA+0x03C)  /* Channel 1 Descriptor Address Register */
+
+#define     REG_GDMA_INTBUF0    (GDMA_BA+0x080)  /* GDMA Internal Buffer Word 0 */
+#define     REG_GDMA_INTBUF1    (GDMA_BA+0x084)  /* GDMA Internal Buffer Word 1 */
+#define     REG_GDMA_INTBUF2    (GDMA_BA+0x088)  /* GDMA Internal Buffer Word 2 */
+#define     REG_GDMA_INTBUF3    (GDMA_BA+0x08C)  /* GDMA Internal Buffer Word 3 */
+#define     REG_GDMA_INTBUF4    (GDMA_BA+0x090)  /* GDMA Internal Buffer Word 4 */
+#define     REG_GDMA_INTBUF5    (GDMA_BA+0x094)  /* GDMA Internal Buffer Word 5 */
+#define     REG_GDMA_INTBUF6    (GDMA_BA+0x098)  /* GDMA Internal Buffer Word 6 */
+#define     REG_GDMA_INTBUF7    (GDMA_BA+0x09C)  /* GDMA Internal Buffer Word 7 */
+#define     REG_GDMA_INTCS			(GDMA_BA+0x0A0)  /* Interrupt Control and Status Register */
+
+
+#define TWS_Msk			(0x3<<12)  //GDMA_CTL : Transfer Width Select
+#define TWS_8BIT		(0x0<<12)
+#define TWS_16BIT		(0x1<<12)
+#define TWS_32BIT		(0x2<<12)
+#define SOFTREQ		(0x1<<16) 
+
+#define BME			(0x1<<1)   //GDMA_CTL : Burst Mode Enable
+
+#define TERR1EN 	(0x1<<3)
+#define TC1EN			(0x1<<2)
+#define TERR0EN 	(0x1<<1)
+#define TC0EN			(0x1)
+
+#endif /*  __ASM_ARCH_REGS_GDMA_H */
\ No newline at end of file
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-ge.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-ge.h
@@ -0,0 +1,53 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-ge.h
+ *
+ * Copyright (c) 2013 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_GE_H
+#define __ASM_ARCH_REGS_GE_H
+
+/* Clock Control Registers  */
+#define GE_BA		NUC970_VA_GE
+
+#define REG_GE2D_TRG		(GE_BA+0x000)  	/* Graphic Engine Trigger Control Register       */
+#define REG_GE2D_XYSORG		(GE_BA+0x004)  	/* Graphic Engine XY Mode Source Origin Starting Register */
+#define REG_GE2D_TCNTVHSF	(GE_BA+0x008)  	/* Graphic Engine Tile Width/Height or V/H Scale Factor N/M */
+#define REG_GE2D_XYRRP	    (GE_BA+0x00C)  	/* Graphic Engine Rotate Reference Point XY Address       */
+#define REG_GE2D_INTSTS		(GE_BA+0x010)  	/* Graphic Engine Interrupt Status Register      */
+#define REG_GE2D_PATSA		(GE_BA+0x014)  	/* Graphic Engine Pattern Location Starting Address Register  */
+#define REG_GE2D_BETSC		(GE_BA+0x018)  	/* GE Bresenham Error Term Stepping Constant Register */
+#define REG_GE2D_BIEPC		(GE_BA+0x01C)  	/* GE Bresenham Initial Error, Pixel Count Major M Register */
+#define REG_GE2D_CTL      	(GE_BA+0x020)  	/* Graphic Engine Control Register               */
+#define REG_GE2D_BGCOLR		(GE_BA+0x024)  	/* Graphic Engine Background Color Register      */
+#define REG_GE2D_FGCOLR		(GE_BA+0x028)  	/* Graphic Engine Foreground Color Register      */
+#define REG_GE2D_TRNSCOLR	(GE_BA+0x02C)  	/* Graphic Engine Transparency Color Register    */
+#define REG_GE2D_TCMSK		(GE_BA+0x030)  	/* Graphic Engine Transparency Color Mask Register */
+#define REG_GE2D_XYDORG		(GE_BA+0x034)  	/* Graphic Engine XY Mode Display Origin Starting Register */
+#define REG_GE2D_SDPITCH	(GE_BA+0x038)  	/* Graphic Engine Source/Destination Pitch Register */
+#define REG_GE2D_SRCSPA		(GE_BA+0x03C)  	/* Graphic Engine Source Start XY/Linear Address Register */
+#define REG_GE2D_DSTSPA		(GE_BA+0x040)  	/* Graphic Engine Destination Start XY/Linear Register  */
+#define REG_GE2D_RTGLSZ		(GE_BA+0x044)  	/* Graphic Engine Dimension XY/Linear Register   */
+#define REG_GE2D_CLPBTL		(GE_BA+0x048)  	/* Graphic Engine Clipping Boundary Top/Left Register */
+#define REG_GE2D_CLPBBR		(GE_BA+0x04C)  	/* Graphic Engine Clipping Boundary Bottom/Right Register */
+#define REG_GE2D_PTNA 		(GE_BA+0x050)  	/* Graphic Engine Pattern A Register             */
+#define REG_GE2D_PTN  B		(GE_BA+0x054)  	/* Graphic Engine Pattern B Register             */
+#define REG_GE2D_WRPLNMSK	(GE_BA+0x058)  	/* Graphic Engine Write Plane Mask Register      */
+#define REG_GE2D_MISCTL   	(GE_BA+0x05C)  	/* Graphic Engine Miscellaneous Control Register */
+#define REG_GE2D_HSTBLTDP0	(GE_BA+0x060)  	/* Graphic Engine HostBLT Double Word Data Port0 Register */
+#define REG_GE2D_HSTBLTDP1	(GE_BA+0x064)  	/* Graphic Engine HostBLT Double Word Data Port1 Register */
+#define REG_GE2D_HSTBLTDP2	(GE_BA+0x068)  	/* Graphic Engine HostBLT Double Word Data Port2 Register */
+#define REG_GE2D_HSTBLTDP3	(GE_BA+0x06C)  	/* Graphic Engine HostBLT Double Word Data Port3 Register */
+#define REG_GE2D_HSTBLTDP4	(GE_BA+0x070)  	/* Graphic Engine HostBLT Double Word Data Port4 Register */
+#define REG_GE2D_HSTBLTDP5	(GE_BA+0x074)  	/* Graphic Engine HostBLT Double Word Data Port5 Register */
+#define REG_GE2D_HSTBLTDP6	(GE_BA+0x078)  	/* Graphic Engine HostBLT Double Word Data Port6 Register */
+#define REG_GE2D_HSTBLTDP7	(GE_BA+0x07C)  	/* Graphic Engine HostBLT Double Word Data Port7 Register */
+
+
+#endif /*  __ASM_ARCH_REGS_GE_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-gpio.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-gpio.h
@@ -0,0 +1,158 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-gpio.h
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_GPIO_H
+#define __ASM_ARCH_REGS_GPIO_H
+
+/* Global control registers */
+#define GPIO_BA		NUC970_VA_GPIO
+
+#define REG_GPIOA_DIR 		(GPIO_BA+0x000)
+#define REG_GPIOA_DATAOUT 	(GPIO_BA+0x004)
+#define REG_GPIOA_DATAIN 	(GPIO_BA+0x008)
+#define REG_GPIOA_IMD 		(GPIO_BA+0x00C)
+#define REG_GPIOA_IREN 		(GPIO_BA+0x010)
+#define REG_GPIOA_IFEN 		(GPIO_BA+0x014)
+#define REG_GPIOA_ISR 		(GPIO_BA+0x018)
+#define REG_GPIOA_DBEN 		(GPIO_BA+0x01C)
+#define REG_GPIOA_PUEN 		(GPIO_BA+0x020)
+#define REG_GPIOA_PDEN 		(GPIO_BA+0x024)
+#define REG_GPIOA_ICEN 		(GPIO_BA+0x028)
+#define REG_GPIOA_ISEN 		(GPIO_BA+0x02C)
+	
+#define REG_GPIOB_DIR 		(GPIO_BA+0x040)              
+#define REG_GPIOB_DATAOUT 	(GPIO_BA+0x044)            
+#define REG_GPIOB_DATAIN 	(GPIO_BA+0x048)              
+#define REG_GPIOB_IMD 		(GPIO_BA+0x04C)              
+#define REG_GPIOB_IREN 		(GPIO_BA+0x050)              
+#define REG_GPIOB_IFEN 		(GPIO_BA+0x054)              
+#define REG_GPIOB_ISR 		(GPIO_BA+0x058)              
+#define REG_GPIOB_DBEN 		(GPIO_BA+0x05C)              
+#define REG_GPIOB_PUEN 		(GPIO_BA+0x060)              
+#define REG_GPIOB_PDEN 		(GPIO_BA+0x064)              
+#define REG_GPIOB_ICEN 		(GPIO_BA+0x068)              
+#define REG_GPIOB_ISEN 		(GPIO_BA+0x06C)              
+                                                     
+#define REG_GPIOC_DIR 		(GPIO_BA+0x080)              
+#define REG_GPIOC_DATAOUT 	(GPIO_BA+0x084)            
+#define REG_GPIOC_DATAIN 	(GPIO_BA+0x088)              
+#define REG_GPIOC_IMD 		(GPIO_BA+0x08C)              
+#define REG_GPIOC_IREN 		(GPIO_BA+0x090)              
+#define REG_GPIOC_IFEN 		(GPIO_BA+0x094)              
+#define REG_GPIOC_ISR 		(GPIO_BA+0x098)              
+#define REG_GPIOC_DBEN 		(GPIO_BA+0x09C)              
+#define REG_GPIOC_PUEN 		(GPIO_BA+0x0A0)              
+#define REG_GPIOC_PDEN 		(GPIO_BA+0x0A4)              
+#define REG_GPIOC_ICEN 		(GPIO_BA+0x0A8)              
+#define REG_GPIOC_ISEN 		(GPIO_BA+0x0AC)              
+                                                     
+#define REG_GPIOD_DIR 		(GPIO_BA+0x0C0)              
+#define REG_GPIOD_DATAOUT 	(GPIO_BA+0x0C4)            
+#define REG_GPIOD_DATAIN 	(GPIO_BA+0x0C8)              
+#define REG_GPIOD_IMD 		(GPIO_BA+0x0CC)              
+#define REG_GPIOD_IREN 		(GPIO_BA+0x0D0)              
+#define REG_GPIOD_IFEN 		(GPIO_BA+0x0D4)              
+#define REG_GPIOD_ISR 		(GPIO_BA+0x0D8)              
+#define REG_GPIOD_DBEN 		(GPIO_BA+0x0DC)              
+#define REG_GPIOD_PUEN 		(GPIO_BA+0x0E0)              
+#define REG_GPIOD_PDEN 		(GPIO_BA+0x0E4)              
+#define REG_GPIOD_ICEN 		(GPIO_BA+0x0E8)              
+#define REG_GPIOD_ISEN 		(GPIO_BA+0x0EC)              
+                                                     
+#define REG_GPIOE_DIR 		(GPIO_BA+0x100)              
+#define REG_GPIOE_DATAOUT 	(GPIO_BA+0x104)            
+#define REG_GPIOE_DATAIN 	(GPIO_BA+0x108)              
+#define REG_GPIOE_IMD 		(GPIO_BA+0x10C)              
+#define REG_GPIOE_IREN 		(GPIO_BA+0x110)              
+#define REG_GPIOE_IFEN 		(GPIO_BA+0x114)              
+#define REG_GPIOE_ISR 		(GPIO_BA+0x118)              
+#define REG_GPIOE_DBEN 		(GPIO_BA+0x11C)              
+#define REG_GPIOE_PUEN 		(GPIO_BA+0x120)              
+#define REG_GPIOE_PDEN 		(GPIO_BA+0x124)              
+#define REG_GPIOE_ICEN 		(GPIO_BA+0x128)              
+#define REG_GPIOE_ISEN 		(GPIO_BA+0x12C)              
+                                                     
+#define REG_GPIOF_DIR 		(GPIO_BA+0x140)              
+#define REG_GPIOF_DATAOUT 	(GPIO_BA+0x144)
+#define REG_GPIOF_DATAIN 	(GPIO_BA+0x148)              
+#define REG_GPIOF_IMD 		(GPIO_BA+0x14C)              
+#define REG_GPIOF_IREN 		(GPIO_BA+0x150)              
+#define REG_GPIOF_IFEN 		(GPIO_BA+0x154)              
+#define REG_GPIOF_ISR 		(GPIO_BA+0x158)              
+#define REG_GPIOF_DBEN 		(GPIO_BA+0x15C)              
+#define REG_GPIOF_PUEN 		(GPIO_BA+0x160)             
+#define REG_GPIOF_PDEN 		(GPIO_BA+0x164)              
+#define REG_GPIOF_ICEN 		(GPIO_BA+0x168)              
+#define REG_GPIOF_ISEN 		(GPIO_BA+0x16C)              
+	                                                     
+#define REG_GPIOG_DIR 		(GPIO_BA+0x180)              
+#define REG_GPIOG_DATAOUT 	(GPIO_BA+0x184)
+#define REG_GPIOG_DATAIN 	(GPIO_BA+0x188)              
+#define REG_GPIOG_IMD 		(GPIO_BA+0x18C)              
+#define REG_GPIOG_IREN 		(GPIO_BA+0x190)              
+#define REG_GPIOG_IFEN 		(GPIO_BA+0x194)              
+#define REG_GPIOG_ISR 		(GPIO_BA+0x198)              
+#define REG_GPIOG_DBEN 		(GPIO_BA+0x19C)              
+#define REG_GPIOG_PUEN 		(GPIO_BA+0x1A0)              
+#define REG_GPIOG_PDEN 		(GPIO_BA+0x1A4)             
+#define REG_GPIOG_ICEN 		(GPIO_BA+0x1A8)              
+#define REG_GPIOG_ISEN 		(GPIO_BA+0x1AC)
+                                                     
+#define REG_GPIOH_DIR 		(GPIO_BA+0x1C0)              
+#define REG_GPIOH_DATAOUT 	(GPIO_BA+0x1C4)            
+#define REG_GPIOH_DATAIN 	(GPIO_BA+0x1C8)              
+#define REG_GPIOH_IMD 		(GPIO_BA+0x1CC)              
+#define REG_GPIOH_IREN 		(GPIO_BA+0x1D0)              
+#define REG_GPIOH_IFEN 		(GPIO_BA+0x1D4)
+#define REG_GPIOH_ISR 		(GPIO_BA+0x1D8)              
+#define REG_GPIOH_DBEN 		(GPIO_BA+0x1DC)              
+#define REG_GPIOH_PUEN 		(GPIO_BA+0x1E0)              
+#define REG_GPIOH_PDEN 		(GPIO_BA+0x1E4)              
+#define REG_GPIOH_ICEN 		(GPIO_BA+0x1E8)              
+#define REG_GPIOH_ISEN 		(GPIO_BA+0x1EC)              
+	                                                     
+#define REG_GPIOI_DIR 		(GPIO_BA+0x200)              
+#define REG_GPIOI_DATAOUT 	(GPIO_BA+0x204)            
+#define REG_GPIOI_DATAIN 	(GPIO_BA+0x208)              
+#define REG_GPIOI_IMD 		(GPIO_BA+0x20C)              
+#define REG_GPIOI_IREN 		(GPIO_BA+0x210)              
+#define REG_GPIOI_IFEN 		(GPIO_BA+0x214)              
+#define REG_GPIOI_ISR 		(GPIO_BA+0x218)              
+#define REG_GPIOI_DBEN 		(GPIO_BA+0x21C)              
+#define REG_GPIOI_PUEN 		(GPIO_BA+0x220)              
+#define REG_GPIOI_PDEN 		(GPIO_BA+0x224)              
+#define REG_GPIOI_ICEN 		(GPIO_BA+0x228)              
+#define REG_GPIOI_ISEN 		(GPIO_BA+0x22C)  
+
+
+#define REG_GPIOJ_DIR 		(GPIO_BA+0x240)              
+#define REG_GPIOJ_DATAOUT (GPIO_BA+0x244)            
+#define REG_GPIOJ_DATAIN 	(GPIO_BA+0x248)              
+#define REG_GPIOJ_IMD 		(GPIO_BA+0x24C)              
+#define REG_GPIOJ_IREN 		(GPIO_BA+0x250)              
+#define REG_GPIOJ_IFEN 		(GPIO_BA+0x254)              
+#define REG_GPIOJ_ISR 		(GPIO_BA+0x258)              
+#define REG_GPIOJ_DBEN 		(GPIO_BA+0x25C)              
+#define REG_GPIOJ_PUEN 		(GPIO_BA+0x260)              
+#define REG_GPIOJ_PDEN 		(GPIO_BA+0x264)              
+#define REG_GPIOJ_ICEN 		(GPIO_BA+0x268)              
+#define REG_GPIOJ_ISEN 		(GPIO_BA+0x26C) 
+                                               
+#define REG_GPIO_DBNCECON	(GPIO_BA+0x3F0)              
+#define REG_GPIO_ISR		  (GPIO_BA+0x3FC)
+
+#define GPIO_OFFSET 0x20
+#define	DRIVER_NAME "nuc970-gpio"
+#define NUMGPIO 0x20 * 10	//(PortA~Portj)
+
+#endif /*  __ASM_ARCH_REGS_GPIO_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-iic.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-iic.h
@@ -0,0 +1,36 @@
+/* linux/include/asm/arch-nuc900/regs-iic.h
+ *
+ * Copyright (c) 2008 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Changelog:
+ *
+ *   2006/08/26     vincen.zswan add this file for nuvoton nuc900 evb.
+ */
+
+
+
+#ifndef ___ASM_ARCH_REGS_IIC_H
+#define ___ASM_ARCH_REGS_IIC_H "$Id: lcd.h,v 1.3 2003/06/26 13:25:06 ben Exp $"
+
+/* I2C control registers */
+#define I2C0_BA                         NUC970_VA_I2C
+#define I2C1_BA                         (NUC970_VA_I2C+0x100)
+
+#define NUC970_I2CCSR                   0x00
+#define NUC970_I2CDIVIDER               0x04
+#define NUC970_I2CCMDR                  0x08
+#define NUC970_I2CSWR                   0x0C
+#define NUC970_I2CRXR                   0x10
+#define NUC970_I2CTXR                   0x14
+
+
+#endif /* ___ASM_ARCH_REGS_IIC_H */
+
+
+
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-jpeg.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-jpeg.h
@@ -0,0 +1,125 @@
+/* linux/include/asm/arch-nuc970/regs-jpeg.h
+ *
+ * Copyright (c) 2015 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Changelog:
+ *
+ *   2015/09/04     Add this file for nuvoton nuc970 JPEG engine.
+ */
+
+
+
+#ifndef ___ASM_ARCH_REGS_JPEG_H
+#define ___ASM_ARCH_REGS_JPEG_H "$Id: lcd.h,v 1.3 2003/06/26 13:25:06 ben Exp $"
+
+#include "map.h"
+
+#define JPEG_BA		NUC970_VA_JPEG
+
+#define REG_JMCR		(JPEG_BA+0x000)
+#define REG_JHEADER		(JPEG_BA+0x004)
+#define REG_JITCR		(JPEG_BA+0x008)
+#define REG_JPRIQC		(JPEG_BA+0x010)
+#define REG_JTHBQC		(JPEG_BA+0x014)
+#define REG_JPRIWH		(JPEG_BA+0x018)
+#define REG_JTHBWH		(JPEG_BA+0x01C)
+#define REG_JPRST		(JPEG_BA+0x020)
+#define REG_JTRST		(JPEG_BA+0x024)
+#define REG_JDECWH		(JPEG_BA+0x028)
+#define REG_JINTCR		(JPEG_BA+0x02C)
+#define REG_JDOWFBS		(JPEG_BA+0x03C)
+#define REG_JTEST		(JPEG_BA+0x040)
+#define REG_JWINDEC0	(JPEG_BA+0x044)
+#define REG_JWINDEC1	(JPEG_BA+0x048)
+#define REG_JWINDEC2	(JPEG_BA+0x04C)
+#define REG_JMACR		(JPEG_BA+0x050)
+#define REG_JPSCALU		(JPEG_BA+0x054)
+#define REG_JPSCALD		(JPEG_BA+0x058)
+#define REG_JTSCALD		(JPEG_BA+0x05C)
+#define REG_JDBCR		(JPEG_BA+0x060)
+#define REG_JRESERVE	(JPEG_BA+0x070)
+#define REG_JOFFSET		(JPEG_BA+0x074)
+#define REG_JFSTRIDE	(JPEG_BA+0x078)
+#define REG_JYADDR0		(JPEG_BA+0x07C)
+#define REG_JUADDR0		(JPEG_BA+0x080)
+#define REG_JVADDR0		(JPEG_BA+0x084)
+#define REG_JYADDR1		(JPEG_BA+0x088)
+#define REG_JUADDR1		(JPEG_BA+0x08C)
+#define REG_JVADDR1		(JPEG_BA+0x090)
+#define REG_JYSTRIDE	(JPEG_BA+0x094)
+#define REG_JUSTRIDE	(JPEG_BA+0x098)
+#define REG_JVSTRIDE	(JPEG_BA+0x09C)
+#define REG_JIOADDR0	(JPEG_BA+0x0A0)
+#define REG_JIOADDR1	(JPEG_BA+0x0A4)
+#define REG_JPRI_SIZE	(JPEG_BA+0x0A8)
+#define REG_JTHB_SIZE	(JPEG_BA+0x0AC)
+#define REG_JUPRAT		(JPEG_BA+0x0B0)
+#define REG_JBSFIFO		(JPEG_BA+0x0B4)
+#define REG_JSRCH		(JPEG_BA+0x0B8)
+#define REG_JQTAB0		(JPEG_BA+0x100)
+#define REG_JQTAB1		(JPEG_BA+0x140)
+#define REG_JQTAB2		(JPEG_BA+0x180)
+
+
+/********************* Bit definition of REG_JMCR  ************************/
+#define JPG_EN			((u32)0x00000001)			/*!<JPEG Engine Operation Control              */
+#define ENG_RST			((u32)0x00000002)			/*!<Soft Reset JPEG Engine (Except JPEG Control Registers) */
+#define QT_BUSY			((u32)0x00000004)			/*!<Quantization-Table Busy Status (Read-Only) */
+#define EY422			((u32)0x00000008)			/*!<Encode Image Format                        */
+#define THB				((u32)0x00000010)			/*!<Encode Thumbnail Image                     */
+#define PRI				((u32)0x00000020)			/*!<Encode Primary Image                       */
+#define WIN_DEC			((u32)0x00000040)			/*!<JPEG Window Decode Mode                    */
+#define ENC_DEC			((u32)0x00000080)			/*!<JPEG Encode/Decode Mode                    */
+#define RESUMEO			((u32)0x00000100)			/*!<Resume JPEG Operation for Output On-the-Fly Mode */
+#define RESUMEI			((u32)0x00000200)			/*!<Resume JPEG Operation for Input On-the-Fly Mode  */
+
+/********************* Bit definition of REG_JHEADER  ************************/
+#define P_QTAB			((u32)0x00000020)			/*!<Primary JPEG Bit-stream Include Quantization-Table */
+#define P_HTAB			((u32)0x00000040)			/*!<Primary JPEG Bit-stream Include Huffman-Table */
+
+/********************* Bit definition of REG_JITCR  ************************/
+#define ERR_DIS			((u32)0x00000001)			/*!<Decode Error Engine Abort                  */
+#define EY_ONLY			((u32)0x00000020)			/*!<Encode Gray-level (Y-component Only) Image */
+#define DYUV_MODE		((u32)0x00000700)			/*!<Decoded Image YUV Color Format (Read-Only) */
+#define PLANAR_ON		((u32)0x00008000)			
+#define BIT18			(1<<18)
+
+/********************* Bit definition of REG_JINTCR  ************************/
+#define ERR_INTS		((u32)0x00000001)			/*!<Encode (On-The-Fly) Error Interrupt Status */
+#define DER_INTS		((u32)0x00000002)			/*!<Decode Error Interrupt Status              */
+#define DEC_INTS		((u32)0x00000004)			/*!<Decode Complete Interrupt Status           */
+#define ENC_INTS		((u32)0x00000008)			/*!<Encode Complete Interrupt Status           */
+#define OPW_INTS		((u32)0x00000010)			/*!<Output Wait Interrupt Status               */
+#define IPW_INTS		((u32)0x00000020)			/*!<Input Wait Interrupt Status                */
+#define DHE_INTS		((u32)0x00000040)			/*!<JPEG Header Decode End Wait Interrupt Status */
+#define EER_INTE		((u32)0x00000100)			/*!<Encode (On-The-Fly) Error Interrupt Enable */
+#define DER_INTE		((u32)0x00000200)			/*!<Decode Error Interrupt Enable              */
+#define DEC_INTE		((u32)0x00000400)			/*!<Decode Complete Interrupt Enable           */
+#define ENC_INTE		((u32)0x00000800)			/*!<Encode Complete Interrupt Enable           */
+#define OPW_INTE		((u32)0x00001000)			/*!<Output Wait Interrupt Enable               */
+#define IPW_INTE		((u32)0x00002000)			/*!<Input Wait Interrupt Enable                */
+#define DHE_INTE		((u32)0x00004000)			/*!<JPEG Header Decode End Wait Interrupt Enable */
+#define DOW_INTS		((u32)0x01000000)			/*!<decoding output Wait Interrupt Status      */
+#define DOW_INTE		((u32)0x10000000)			/*!<decoding output Wait Interrupt Enable      */
+
+/********************* Bit definition of REG_JPSCALU  ************************/
+#define A_JUMP			((u32)0x00000004)			/*!<Reserve Buffer Size In JPEG Bit-stream For Software Application */
+#define JPSCALU_8X		((u32)0x00000040)
+
+/********************* Bit definition of REG_JPSCALD  ************************/
+#define PSCALY_F		((u32)0x0000003F)
+#define PSCALX_F		((u32)0x00001F00)
+#define PS_LPF_ON		((u32)0x00004000)
+#define PSX_ON			((u32)0x00008000)
+
+
+#endif /* ___ASM_ARCH_REGS_JPEG_H */
+
+
+
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-lcd.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-lcd.h
@@ -0,0 +1,247 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-lcd.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#ifndef __ASM_ARM_NUC970_REGS_LCD_H
+#define __ASM_ARM_NUC970_REGS_LCD_H
+
+#include <mach/map.h>
+
+/* Display Controller Control/Status Register */
+#define REG_LCM_DCCS			(0x00)
+
+#define LCM_DCCS_ENG_RST		(1 << 0)
+#define LCM_DCCS_VA_EN			(1 << 1)
+#define LCM_DCCS_OSD_EN			(1 << 2)
+#define LCM_DCCS_DISP_OUT_EN		(1 << 3)
+#define LCM_DCCS_DISP_INT_EN		(1 << 4)
+#define LCM_DCCS_CMD_ON			(1 << 5)
+#define LCM_DCCS_FIELD_INTR		(1 << 6)
+#define LCM_DCCS_SINGLE			(1 << 7)
+
+enum LCM_DCCS_VA_SRC {
+	LCM_DCCS_VA_SRC_YUV422		= (0 << 8),
+	LCM_DCCS_VA_SRC_YCBCR422	= (1 << 8),
+	LCM_DCCS_VA_SRC_RGB888		= (2 << 8),
+	LCM_DCCS_VA_SRC_RGB666		= (3 << 8),
+	LCM_DCCS_VA_SRC_RGB565		= (4 << 8),
+	LCM_DCCS_VA_SRC_RGB444LOW	= (5 << 8),
+	LCM_DCCS_VA_SRC_RGB444HIGH 	= (7 << 8)
+};
+
+
+/* Display Device Control Register */
+#define REG_LCM_DEV_CTRL		(0x04)
+
+enum LCM_DEV_CTRL_SWAP_YCbCr {
+	LCM_DEV_CTRL_SWAP_UYVY		= (0 << 1),
+	LCM_DEV_CTRL_SWAP_YUYV		= (1 << 1),
+	LCM_DEV_CTRL_SWAP_VYUY		= (2 << 1),
+	LCM_DEV_CTRL_SWAP_YVYU		= (3 << 1)
+};
+
+enum LCM_DEV_CTRL_RGB_SHIFT {
+	LCM_DEV_CTRL_RGB_SHIFT_NOT 	= (0 << 3),
+	LCM_DEV_CTRL_RGB_SHIFT_ONECYCLE = (1 << 3),
+	LCM_DEV_CTRL_RGB_SHIFT_TWOCYCLE = (2 << 3),
+	LCM_DEV_CTRL_RGB_SHIFT_NOT_DEF	= (3 << 3)
+};
+
+enum LCM_DEV_CTRL_DEVICE {
+	LCM_DEV_CTRL_DEVICE_YUV422	= (0 << 5),
+	LCM_DEV_CTRL_DEVICE_YUV444	= (1 << 5),
+	LCM_DEV_CTRL_DEVICE_UNIPAC	= (4 << 5),
+	LCM_DEV_CTRL_DEVICE_SEIKO_EPSON	= (5 << 5),
+	LCM_DEV_CTRL_DEVICE_HIGH_COLOR	= (6 << 5),
+	LCM_DEV_CTRL_DEVICE_MPU		= (7 << 5)
+};
+
+#define LCM_DEV_CTRL_LCD_DDA		(8)
+#define LCM_DEV_CTRL_YUV2CCIR		(16)
+
+enum LCM_DEV_CTRL_LCD_SEL {
+	LCM_DEV_CTRL_LCD_SEL_RGB_GBR	= (0 << 17),
+	LCM_DEV_CTRL_LCD_SEL_BGR_RBG	= (1 << 17),
+	LCM_DEV_CTRL_LCD_SEL_GBR_RGB	= (2 << 17),
+	LCM_DEV_CTRL_LCD_SEL_RBG_BGR	= (3 << 17)
+};
+
+enum LCM_DEV_CTRL_FAL_D {
+	LCM_DEV_CTRL_FAL_D_FALLING	= (0 << 19),
+	LCM_DEV_CTRL_FAL_D_RISING	= (1 << 19),
+};
+
+enum LCM_DEV_CTRL_H_POL {
+	LCM_DEV_CTRL_H_POL_LOW		= (0 << 20),
+	LCM_DEV_CTRL_H_POL_HIGH		= (1 << 20),
+};
+
+enum LCM_DEV_CTRL_V_POL {
+	LCM_DEV_CTRL_V_POL_LOW		= (0 << 21),
+	LCM_DEV_CTRL_V_POL_HIGH		= (1 << 21),
+};
+
+enum LCM_DEV_CTRL_VR_LACE {
+	LCM_DEV_CTRL_VR_LACE_NINTERLACE	= (0 << 22),
+	LCM_DEV_CTRL_VR_LACE_INTERLACE	= (1 << 22),
+};
+
+enum LCM_DEV_CTRL_LACE {
+	LCM_DEV_CTRL_LACE_NINTERLACE	= (0 << 23),
+	LCM_DEV_CTRL_LACE_INTERLACE	= (1 << 23),
+};
+
+enum LCM_DEV_CTRL_RGB_SCALE {
+	LCM_DEV_CTRL_RGB_SCALE_4096 	= (0 << 24),
+	LCM_DEV_CTRL_RGB_SCALE_65536 	= (1 << 24),
+	LCM_DEV_CTRL_RGB_SCALE_262144 	= (2 << 24),
+	LCM_DEV_CTRL_RGB_SCALE_16777216 = (3 << 24),
+};
+
+enum LCM_DEV_CTRL_DBWORD {
+	LCM_DEV_CTRL_DBWORD_HALFWORD	= (0 << 26),
+	LCM_DEV_CTRL_DBWORD_FULLWORD	= (1 << 26),
+};
+
+enum LCM_DEV_CTRL_MPU68 {
+	LCM_DEV_CTRL_MPU68_80_SERIES	= (0 << 27),
+	LCM_DEV_CTRL_MPU68_68_SERIES	= (1 << 27),
+};
+
+enum LCM_DEV_CTRL_DE_POL {
+	LCM_DEV_CTRL_DE_POL_HIGH	= (0 << 28),
+	LCM_DEV_CTRL_DE_POL_LOW		= (1 << 28),
+};
+
+#define LCM_DEV_CTRL_CMD16		(29)
+#define LCM_DEV_CTRL_CM16t18		(30)
+#define LCM_DEV_CTRL_CMD_LOW		(31)
+
+/* MPU-Interface LCD Write Command */
+#define REG_LCM_MPU_CMD			(0x08)
+
+/* Interrupt Control/Status Register */
+#define REG_LCM_INT_CS			(0x0c)
+#define LCM_INT_CS_DISP_F_EN		(1 << 0)
+#define LCM_INT_CS_UNDERRUN_EN   	(1 << 1)
+#define LCM_INT_CS_BUS_ERROR_INT 	(1 << 28)
+#define LCM_INT_CS_UNDERRUN_INT  	(1 << 29)
+#define LCM_INT_CS_DISP_F_STATUS 	(1 << 30)
+#define LCM_INT_CS_DISP_F_INT		(1 << 31)
+
+/* CRTC Display Size Control Register */
+#define REG_LCM_CRTC_SIZE		(0x10)
+#define LCM_CRTC_SIZE_VTTVAL(x)		((x) << 16)
+#define LCM_CRTC_SIZE_HTTVAL(x)		((x) << 0)
+
+/* CRTC Display Enable End */
+#define REG_LCM_CRTC_DEND		(0x14)
+#define LCM_CRTC_DEND_VDENDVAL(x)	((x) << 16)
+#define LCM_CRTC_DEND_HDENDVAL(x)	((x) << 0)
+
+/* CRTC Internal Horizontal Retrace Control Register */
+#define REG_LCM_CRTC_HR			(0x18)
+#define LCM_CRTC_HR_EVAL(x)		((x) << 16)
+#define LCM_CRTC_HR_SVAL(x)		((x) << 0)
+
+/* CRTC Horizontal Sync Control Register */
+#define REG_LCM_CRTC_HSYNC		(0x1C)
+#define LCM_CRTC_HSYNC_SHIFTVAL(x)	((x) << 30)
+#define LCM_CRTC_HSYNC_EVAL(x)		((x) << 16)
+#define LCM_CRTC_HSYNC_SVAL(x)		((x) << 0)
+
+/* CRTC Internal Vertical Retrace Control Register */
+#define REG_LCM_CRTC_VR			(0x20)
+#define LCM_CRTC_VR_EVAL(x)		((x) << 16)
+#define LCM_CRTC_VR_SVAL(x)		((x) << 0)
+
+/* Video Stream Frame Buffer-0 Starting Address */
+#define REG_LCM_VA_BADDR0		(0x24)
+
+/* Video Stream Frame Buffer-1 Starting Address */
+#define REG_LCM_VA_BADDR1		(0x28)
+
+/* Video Stream Frame Buffer Control Register */
+#define REG_LCM_VA_FBCTRL		(0x2C)
+#define LCM_VA_FBCTRL_IO_REGION_HALF	(1 << 28)
+#define LCM_VA_FBCTRL_FIELD_DUAL  	(1 << 29)
+#define LCM_VA_FBCTRL_START_BUF 	(1 << 30)
+#define LCM_VA_FBCTRL_DB_EN		(1 << 31)
+
+/* Video Stream Scaling Control Register */
+#define REG_LCM_VA_SCALE		(0x30)
+#define LCM_VA_SCALE_XCOPY_INTERPOLATION (0 << 15)
+#define LCM_VA_SCALE_XCOPY_DUPLICATION	 (1 << 15)
+
+/* Image Stream Active Window Coordinates */
+#define REG_LCM_VA_WIN			(0x38)
+
+/* Image Stream Stuff Pixel */
+#define REG_LCM_VA_STUFF		(0x3C)
+
+/* OSD Window Starting Coordinates */
+#define REG_LCM_OSD_WINS		(0x40)
+
+/* OSD Window Ending Coordinates */
+#define REG_LCM_OSD_WINE		(0x44)
+
+/* OSD Stream Frame Buffer Starting Address */
+#define REG_LCM_OSD_BADDR		(0x48)
+
+/* OSD Stream Frame Buffer Control Register */
+#define REG_LCM_OSD_FBCTRL		(0x4c)
+
+/* OSD Overlay Control Register */
+#define REG_LCM_OSD_OVERLAY		(0x50)
+
+/* OSD Overlay Color-Key Pattern Register */
+#define REG_LCM_OSD_CKEY		(0x54)
+
+/* OSD Overlay Color-Key Mask Register */
+#define REG_LCM_OSD_CMASK		(0x58)
+
+/* OSD Window Skip1 Register */
+#define REG_LCM_OSD_SKIP1		(0x5C)
+
+/* OSD Window Skip2 Register */
+#define REG_LCM_OSD_SKIP2		(0x60)
+
+/* OSD horizontal up scaling control register */
+#define REG_LCM_OSD_SCALE		(0x64)
+
+/* MPU Vsync control register */
+#define REG_LCM_MPU_VSYNC		(0x68)
+
+/* Hardware cursor control Register */
+#define REG_LCM_HC_CTRL			(0x6C)
+
+/* Hardware cursot tip point potison on va picture */
+#define REG_LCM_HC_POS			(0x70)
+
+/* Hardware Cursor Window Buffer Control Register */
+#define REG_LCM_HC_WBCTRL		(0x74)
+
+/* Hardware cursor memory base address register */
+#define REG_LCM_HC_BADDR		(0x78)
+
+/* Hardware cursor color ram register mapped to bpp = 0 */
+#define REG_LCM_HC_COLOR0		(0x7C)
+
+/* Hardware cursor color ram register mapped to bpp = 1 */
+#define REG_LCM_HC_COLOR1		(0x80)
+
+/* Hardware cursor color ram register mapped to bpp = 2 */
+#define REG_LCM_HC_COLOR2		(0x84)
+
+/* Hardware cursor color ram register mapped to bpp = 3 */
+#define REG_LCM_HC_COLOR3		(0x88)
+
+#endif /* __ASM_ARM_NUC970_REGS_LCD_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-mtp.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-mtp.h
@@ -0,0 +1,61 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-clock.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_MTP_H
+#define __ASM_ARCH_REGS_MTP_H
+
+typedef struct
+{
+	u32  MTP_KEYEN;				/*!< Offset: 0x0000   MTP Key Enable                        */ 
+	u32  Reserved1[2];			/*!< Offset: 0x0004 ~ 0x0008  Reserved                      */
+	u32  MTP_USERDATA;			/*!< Offset: 0x000C   MTP user data (IBR option)            */ 
+	u32  MTP_KEY[8];			/*!< Offset: 0x0010 ~ 0x002C  MTP Key Value 0~7             */ 
+	u32  MTP_PCYCLE;			/*!< Offset: 0x0030   MTP Program Cycle Control register    */ 
+	u32  MTP_CTL;				/*!< Offset: 0x0034   MTP Control register                  */ 
+	u32  MTP_PSTART;			/*!< Offset: 0x0038   MTP Program Start register            */ 
+	u32  Reserved2;				/*!< Offset: 0x003C   Reserved                              */
+	u32  MTP_STATUS;			/*!< Offset: 0x0040   MTP Status register                   */ 
+	u32  Reserved3[3];			/*!< Offset: 0x0044 ~ 0x004C   Reserved                     */
+	u32  MTP_REGLCTL;			/*!< Offset: 0x0050   MTP Register Write-Protection Control Register  */ 
+} 	MTP_TypeDef;
+
+#define MTP           		        ((volatile MTP_TypeDef *) (NUC970_VA_MTP))
+
+#define MTP_KEY_PROG_COUNT		    ((MTP->MTP_STATUS >> 16) & 0xf)
+
+
+/********************* Bit definition of MTP_KEYEN  ************************/
+#define MTP_KEYEN_KEYEN				((u32)0x00000001)			/*!<MTP Key Enable */
+
+/********************* Bit definition of MTP_CTL  *************************/
+#define MTP_CTL_MODE_MASK			((u32)0x00000003)			/*!<MTP_CTL MODE control bits mask */
+#define MTP_CLT_MODE_IDLE			((u32)0x00000000)			/*!<MTP_CTL MTP idle mode          */
+#define MTP_CLT_MODE_PROG			((u32)0x00000002)			/*!<MTP_CTL program key mode       */
+#define MTP_CTL_MODE_LOCK			((u32)0x00000003)			/*!<MTP lock key mode              */
+
+/********************* Bit definition of MTP_PSTART  *************************/
+#define MTP_PSTART_PSTART			((u32)0x00000001)			/*!<MTP start program	 */
+
+/********************* Bit definition of MTP_STATUS  ************************/
+#define MTP_STATUS_MTPEN			((u32)0x00000001)			/*!<MTP enable status	        */
+#define MTP_STATUS_KEYVALID		    ((u32)0x00000002)			/*!<MTP key valid status        */
+#define MTP_STATUS_NONPRG			((u32)0x00000004)			/*!<MTP non-program status      */
+#define MTP_STATUS_LOCKED			((u32)0x00000008)			/*!<MTP key lock status	        */
+#define MTP_STATUS_PRGFAIL		    ((u32)0x00000010)			/*!<MTP program fail status	    */
+#define MTP_STATUS_BUSY				((u32)0x01000000)			/*!<MTP busy fail	            */
+
+#endif /*  __ASM_ARCH_REGS_MTP_H */
+
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-pwm.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-pwm.h
@@ -0,0 +1,38 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-pwm.h
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_PWM_H
+#define __ASM_ARCH_REGS_PWM_H
+
+/* PWM Registers */
+
+#define PWM_BA			NUC970_VA_PWM
+#define REG_PWM_PPR		(PWM_BA+0x00)
+#define REG_PWM_CSR		(PWM_BA+0x04)
+#define REG_PWM_PCR		(PWM_BA+0x08)
+#define REG_PWM_CNR0		(PWM_BA+0x0C)
+#define REG_PWM_CMR0		(PWM_BA+0x10)
+#define REG_PWM_PDR0		(PWM_BA+0x14)
+#define REG_PWM_CNR1		(PWM_BA+0x18)
+#define REG_PWM_CMR1		(PWM_BA+0x1C)
+#define REG_PWM_PDR1		(PWM_BA+0x20)
+#define REG_PWM_CNR2		(PWM_BA+0x24)
+#define REG_PWM_CMR2		(PWM_BA+0x28)
+#define REG_PWM_PDR2		(PWM_BA+0x2C)
+#define REG_PWM_CNR3		(PWM_BA+0x30)
+#define REG_PWM_CMR3		(PWM_BA+0x34)
+#define REG_PWM_PDR3		(PWM_BA+0x38)
+#define REG_PWM_PIER		(PWM_BA+0x3C)
+#define REG_PWM_PIIR		(PWM_BA+0x40)
+
+#endif /*  __ASM_ARCH_REGS_PWM_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-sc.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-sc.h
@@ -0,0 +1,241 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-sc.h
+ *
+ * Copyright (c) 2015 Nuvoton Technology Corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_SC_H
+#define __ASM_ARCH_REGS_SC_H
+
+/* SC Registers */
+
+#define SC0_BA			NUC970_VA_SC
+#define SC1_BA			(NUC970_VA_SC + 0x400)
+#define REG_SC_DAT		0x00
+#define REG_SC_CTL		0x04
+#define REG_SC_ALTCTL		0x08
+#define REG_SC_EGT		0x0C
+#define REG_SC_RXTOUT		0x10
+#define REG_SC_ETUCTL		0x14
+#define REG_SC_INTEN		0x18
+#define REG_SC_INTSTS		0x1C
+#define REG_SC_STATUS		0x20
+#define REG_SC_PINCTL		0x24
+#define REG_SC_TMRCTL0		0x28
+#define REG_SC_TMRCTL1		0x2C
+#define REG_SC_TMRCTL2		0x30
+#define REG_SC_UARTCTL		0x34
+
+#define SC_CTL_SYNC		0x40000000
+#define SC_CTL_CDLV		0x04000000
+#define SC_CTL_TXRTYEN		0x00800000
+#define SC_CTL_TXRTY		0x00700000
+#define SC_CTL_RXRTYEN		0x00080000
+#define SC_CTL_RXRTY		0x00070000
+#define SC_CTL_NSB		0x00008000
+#define SC_CTL_TMRSEL		0x00006000
+#define SC_CTL_BGT		0x00001F00
+#define SC_CTL_RXTRGLV		0x000000C0
+#define SC_CTL_AUTOCEN		0x00000008
+#define SC_CTL_TXOFF		0x00000004
+#define SC_CTL_RXOFF		0x00000002
+#define SC_CTL_SCEN		0x00000001
+
+#define SC_ALTCTL_ADACEN	0x00000800
+#define SC_ALTCTL_INITSEL	0x00000300
+#define SC_ALTCTL_CNTEN2	0x00000080
+#define SC_ALTCTL_CNTEN1	0x00000040
+#define SC_ALTCTL_CNTEN0	0x00000020
+#define SC_ALTCTL_WARSTEN	0x00000010
+#define SC_ALTCTL_ACTEN		0x00000008
+#define SC_ALTCTL_DACTEN	0x00000004
+#define SC_ALTCTL_RXRST		0x00000002
+#define SC_ALTCTL_TXRST		0x00000001
+
+#define SC_INTEN_ACERRIEN	0x00000400
+#define SC_INTEN_RXTOIEN	0x00000200
+#define SC_INTEN_INITIEN	0x00000100
+#define SC_INTEN_CDIEN		0x00000080
+#define SC_INTEN_TMR2IEN	0x00000020
+#define SC_INTEN_TMR1IEN	0x00000010
+#define SC_INTEN_TMR0IEN	0x00000008
+#define SC_INTEN_TERRIEN	0x00000004
+#define SC_INTEN_TBEIEN		0x00000002
+#define SC_INTEN_RDAIEN		0x00000001
+
+#define SC_INTSTS_ACERRIF	0x00000400
+#define SC_INTSTS_RXTOIF	0x00000200
+#define SC_INTSTS_INITIF	0x00000100
+#define SC_INTSTS_CDIF		0x00000080
+#define SC_INTSTS_TMR2IF	0x00000020
+#define SC_INTSTS_TMR1IF	0x00000010
+#define SC_INTSTS_TMR0IF	0x00000008
+#define SC_INTSTS_TERRIF	0x00000004
+#define SC_INTSTS_TBEIF		0x00000002
+#define SC_INTSTS_RDAIF		0x00000001
+
+#define SC_STATUS_TXOVERR	0x40000000
+#define SC_STATUS_TXRERR	0x20000000
+#define SC_STATUS_RXOVERR	0x00400000
+#define SC_STATUS_RXRERR	0x00200000
+#define SC_STATUS_CDPINSTS	0x00002000
+#define SC_STATUS_CINSERT	0x00001000
+#define SC_STATUS_CREMOVE	0x00000800
+#define SC_STATUS_TXFULL	0x00000400
+#define SC_STATUS_TXEMPTY	0x00000200
+#define SC_STATUS_TXOV		0x00000100
+#define SC_STATUS_BEF		0x00000040
+#define SC_STATUS_FEF		0x00000020
+#define SC_STATUS_PEF		0x00000010
+#define SC_STATUS_RXFULL	0x00000004
+#define SC_STATUS_RXEMPTY	0x00000002
+#define SC_STATUS_RXOV		0x00000001
+
+#define SC_PINCTL_SYNC		0x40000000
+#define SC_PINCTL_RSTSTS	0x00040000
+#define SC_PINCTL_PWRINV	0x00000800
+#define SC_PINCTL_SCDOUT	0x00000200
+#define SC_PINCTL_CLKKEEP	0x00000040
+#define SC_PINCTL_SCRST		0x00000002
+#define SC_PINCTL_PWREN		0x00000001
+
+
+
+/* Return values */
+#define ATR_OK		0	/* ATR could be parsed and data returned */
+#define ATR_NOT_FOUND	1	/* Data not present in ATR */
+#define ATR_MALFORMED	2	/* ATR could not be parsed */
+#define ATR_IO_ERROR	3	/* I/O stream error */
+
+/* Paramenters */
+#define ATR_MAX_SIZE 		33	/* Maximum size of ATR byte array */
+#define ATR_MAX_HISTORICAL	15	/* Maximum number of historical bytes */
+#define ATR_MAX_PROTOCOLS	7	/* Maximun number of protocols */
+#define ATR_MAX_IB		4	/* Maximum number of interface bytes per protocol */
+#define ATR_CONVENTION_DIRECT	0	/* Direct convention */
+#define ATR_CONVENTION_INVERSE	1	/* Inverse convention */
+#define ATR_PROTOCOL_TYPE_T0	0	/* Protocol type T=0 */
+#define ATR_PROTOCOL_TYPE_T1	1	/* Protocol type T=1 */
+#define ATR_PROTOCOL_TYPE_T2	2	/* Protocol type T=2 */
+#define ATR_PROTOCOL_TYPE_T3	3	/* Protocol type T=3 */
+#define ATR_PROTOCOL_TYPE_T14	14	/* Protocol type T=14 */
+#define ATR_INTERFACE_BYTE_TA	0	/* Interface byte TAi */
+#define ATR_INTERFACE_BYTE_TB	1	/* Interface byte TBi */
+#define ATR_INTERFACE_BYTE_TC	2	/* Interface byte TCi */
+#define ATR_INTERFACE_BYTE_TD	3	/* Interface byte TDi */
+#define ATR_PARAMETER_F		0	/* Parameter F */
+#define ATR_PARAMETER_D		1	/* Parameter D */
+#define ATR_PARAMETER_I		2	/* Parameter I */
+#define ATR_PARAMETER_P		3	/* Parameter P */
+#define ATR_PARAMETER_N		4	/* Parameter N */
+#define ATR_INTEGER_VALUE_FI	0	/* Integer value FI */
+#define ATR_INTEGER_VALUE_DI	1	/* Integer value DI */
+#define ATR_INTEGER_VALUE_II	2	/* Integer value II */
+#define ATR_INTEGER_VALUE_PI1	3	/* Integer value PI1 */
+#define ATR_INTEGER_VALUE_N	4	/* Integer value N */
+#define ATR_INTEGER_VALUE_PI2	5	/* Integer value PI2 */
+
+/* Default values for paramenters */
+#define ATR_DEFAULT_F	372
+#define ATR_DEFAULT_D	1
+#define ATR_DEFAULT_I 	50
+#define ATR_DEFAULT_N	0
+#define ATR_DEFAULT_P	5
+
+#define SC_INTF		2
+#define MAX_LEN		300 // This is larger than MAC T1 block size 271
+
+typedef struct {
+
+    unsigned char   IFSC;  ///< Current information field size that can be transmitted
+    unsigned char   IFSD;  ///< Current information field size we can receive
+    unsigned char   IBLOCK_REC; ///< Record if received I-block was sent correctly from ICC
+    unsigned char   RSN;  ///< The 'number' of received I-Blocks
+    unsigned char   SSN;  ///< The 'number' of sent I-Blocks as defined in ISO 7816-3
+    unsigned char   WTX;   ///< Waiting time extension requested by the smart card, This value should be used by the driver to extend block waiting time
+} T1_DATA;
+
+typedef struct {
+    unsigned int   Lc;    ///< Number of data bytes in this request
+    unsigned int   Le;    ///< Number of expected bytes from the card
+
+} T0_DATA;
+
+
+typedef struct
+{
+	unsigned int length;
+	char TS;
+	char T0;
+	struct
+	{
+		char value;
+		char present;
+	} ib[ATR_MAX_PROTOCOLS][ATR_MAX_IB], TCK;
+	unsigned int pn;
+	char hb[ATR_MAX_HISTORICAL];
+	unsigned int hbn;
+}ATR_t;
+
+struct nuc970_sc {
+	//spinlock_t lock;
+	struct mutex lock;
+	struct pinctrl *pinctrl;
+	struct clk *clk;
+	struct clk *eclk;
+	wait_queue_head_t wq;
+	int open;
+	int protocol;			// T0, T1
+	int intf;			// 0, 1
+	int minor;			// dynamic allocate device minor number
+	struct resource *res;
+	void __iomem * base;			// reg base
+	char rbuf[MAX_LEN];		// recv data from card
+	int rhead;			// last rx data
+	int rtail;			// first rx data
+	int rlen;			// expect receive length (from user application layer)
+	char tbuf[MAX_LEN];		// tx data to card
+	int tcnt;			// total tx data len
+	int toffset;			// current tx data offset
+	char atrbuf[ATR_MAX_SIZE];	// ATR from card
+	ATR_t atr;
+	int atrlen;			// ATR length
+	int act;			// Card activated
+	int err;			// Last error code. 0 means no error
+	int cdlvl;			// CD lvl
+	int pwrinv;			// power level inverse
+	int state;			// idle, read, write, atr, (removed?), (acted?)
+	int F;
+	int D;
+	int N;
+	int irq;			// IRQ number
+	/** T=0 specific data */
+	struct {
+		u8 WI;         ///< Waiting integer
+		u32 WT;        ///< Waiting time in ETU
+	} T0;
+
+	/** T=1 specific data */
+	struct {
+		u8 IFSC;       ///< Information field size of card
+		u8 CWI;        ///< Character waiting integer
+		u8 BWI;        ///< Block waiting integer
+		u8 EDC;        ///< Error detection code
+		u8 ChkSum;
+		u32 CWT;       ///< Character and block waiting time in ETU
+		u32 BWT;       ///< Character and block waiting time in ETU
+		u32 WTX;       ///< Block guarding time in micro seconds
+	} T1;
+
+	T0_DATA T0_dat;   ///< Data for T=0
+	T1_DATA T1_dat;   ///< Data for T=1
+};
+
+#endif /*  __ASM_ARCH_REGS_SC_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-sdh.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-sdh.h
@@ -0,0 +1,127 @@
+/* linux/include/asm-arm/arch-nuc900/nuc900_reg.h
+ *
+ * Copyright (c) 2008 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Changelog:
+ *
+ *   2006/08/26     vincen.zswan add this file for nuvoton nuc900 MCU ip REG.
+ */
+
+#ifndef __ASM_ARCH_REGS_SDH_H
+#define __ASM_ARCH_REGS_SDH_H
+
+#define SDH_BA              NUC970_VA_SDH /* SD/SDIO Host Controller */
+
+/* DMAC Control Registers*/
+#define REG_SDH_FB0         (SDH_BA+0x000)  /* DMAC Control and Status Register */
+#define REG_DMACCSR         (SDH_BA+0x400)  /* DMAC Control and Status Register */
+#define REG_DMACSAR2        (SDH_BA+0x408)  /* DMAC Transfer Starting Address Register */
+#define REG_DMACBCR         (SDH_BA+0x40C)  /* DMAC Transfer Byte Count Register */
+#define REG_DMACIER         (SDH_BA+0x410)  /* DMAC Interrupt Enable Register */
+#define REG_DMACISR         (SDH_BA+0x414)  /* DMAC Interrupt Status Register */
+
+#define REG_FMICSR          (SDH_BA+0x800)  /* Global Control and Status Register */
+#define REG_FMIIER          (SDH_BA+0x804)  /* Global Interrupt Control Register */
+#define REG_FMIISR          (SDH_BA+0x808)  /* Global Interrupt Status Register */
+
+/* Secure Digit Registers */
+#define REG_SDCSR           (SDH_BA+0x820)  /* SD control and status register */
+#define REG_SDARG           (SDH_BA+0x824)  /* SD command argument register */
+#define REG_SDIER           (SDH_BA+0x828)  /* SD interrupt enable register */
+#define REG_SDISR           (SDH_BA+0x82C)  /* SD interrupt status register */
+#define REG_SDRSP0          (SDH_BA+0x830)  /* SD receive response token register 0 */
+#define REG_SDRSP1          (SDH_BA+0x834)  /* SD receive response token register 1 */
+#define REG_SDBLEN          (SDH_BA+0x838)  /* SD block length register */
+#define REG_SDTMOUT         (SDH_BA+0x83C)  /* SD block length register */
+#define REG_SDECR           (SDH_BA+0x840)  /* SD extended control register */
+
+
+/* Flash buffer 0 registers */
+#define FB0_BASE_ADDR       (SDH_BA+0x000)
+#define FB0_SIZE            0x80
+
+#define DMA_BLOCK_SIZE      0x200
+#define SD_BLOCK_SIZE       0x200
+
+/* FMI Global Control and Status Register(FMICSR) */
+#define FMICSR_SW_RST       (1)
+#define FMICSR_SD_EN        (1<<1)
+
+/* FMI Global Interrupt Control Register(FMIIER) */
+#define FMIIER_DTA_IE       (1)
+
+/* FMI Global Interrupt Status Register (FMIISR) */
+#define FMIISR_DTA_IF       (1)
+
+/* SD Control and Status Register (SDCSR) */
+#define SDCSR_CO_EN         (1)
+#define SDCSR_RI_EN         (1<<1)
+#define SDCSR_DI_EN         (1<<2)
+#define SDCSR_DO_EN         (1<<3)
+#define SDCSR_R2_EN         (1<<4)
+#define SDCSR_CLK74_OE      (1<<5)
+#define SDCSR_CLK8_OE       (1<<6)
+#define SDCSR_CLK_KEEP0     (1<<7)
+#define SDCSR_SW_RST        (1<<14)
+#define SDCSR_DBW           (1<<15)
+#define SDCSR_CLK_KEEP1     (1<<31)
+
+/* SD Interrupt Control Register (SDIER) */
+#define SDIER_BLKD_IE       (1)
+#define SDIER_CRC_IE        (1<<1)
+#define SDIER_CD0_IE        (1<<8)
+#define SDIER_CD1_IE        (1<<9)
+#define SDIER_SDIO0_IE      (1<<10)
+#define SDIER_SDIO1_IE      (1<<11)
+#define SDIER_RITO_IE       (1<<12)
+#define SDIER_DITO_IE       (1<<13)
+#define SDIER_WKUP_EN       (1<<14)
+#define SDIER_CD0SRC        (1<<30)
+#define SDIER_CD1SRC        (1<<31)
+
+/* SD Interrupt Status Register (SDISR) */
+#define SDISR_BLKD_IF       (1)
+#define SDISR_CRC_IF        (1<<1)
+#define SDISR_CRC_7         (1<<2)
+#define SDISR_CRC_16        (1<<3)
+#define SDISR_SDDAT0        (1<<7)
+#define SDISR_CD0_IF        (1<<8)
+#define SDISR_CD1_IF        (1<<9)
+#define SDISR_SDIO0_IF      (1<<10)
+#define SDISR_SDIO1_IF      (1<<11)
+#define SDISR_RITO_IF       (1<<12)
+#define SDISR_DITO_IF       (1<<13)
+#define SDISR_CDPS0         (1<<16)
+#define SDISR_CDPS1         (1<<17)
+#define SDISR_SD0DAT1       (1<<18)
+#define SDISR_SD1DAT1       (1<<19)
+
+/* DMAC Control and Status Register (DMACCSR) */
+#define DMACCSR_DMACEN      (1)
+#define DMACCSR_SW_RST      (1<<1)
+#define DMACCSR_SG_EN1      (1<<2)
+#define DMACCSR_SG_EN2      (1<<3)
+#define DMACCSR_ATA_BUSY    (1<<8)
+#define DMACCSR_FMI_BUSY    (1<<9)
+
+/* DMAC Interrupt Enable Register (DMACIER) */
+#define DMACIER_TABORT_IE   (1)
+#define DMACIER_WEOT_IE     (1<<1)
+
+/* DMAC Interrupt Status Register (DMACISR) */
+#define DMACISR_TABORT_IF   (1)
+#define DMACISR_WEOT_IF     (1<<1)
+
+/* DMAC BIST Control and Status Register (DMACBIST) */
+#define DMACBIST_BIST_EN    (1)
+#define DMACBIST_FINISH     (1<<1)
+#define DMACBIST_FAILED     (1<<2)
+
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-serial.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-serial.h
@@ -0,0 +1,79 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-serial.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARM_REGS_SERIAL_H
+#define __ASM_ARM_REGS_SERIAL_H
+
+#define UART0_BA	NUC970_VA_UART
+#define UART1_BA	(NUC970_VA_UART+0x100)
+#define UART2_BA	(NUC970_VA_UART+0x200)
+#define UART3_BA	(NUC970_VA_UART+0x300)
+#define UART4_BA	(NUC970_VA_UART+0x400)
+#define UART5_BA	(NUC970_VA_UART+0x500)
+#define UART6_BA	(NUC970_VA_UART+0x600)
+#define UART7_BA	(NUC970_VA_UART+0x700)
+#define UART8_BA	(NUC970_VA_UART+0x800)
+#define UART9_BA	(NUC970_VA_UART+0x900)
+#define UART10_BA	(NUC970_VA_UART+0xA00)
+
+#define UART0_PA	NUC970_PA_UART
+#define UART1_PA	(NUC970_PA_UART+0x100)
+#define UART2_PA	(NUC970_PA_UART+0x200)
+#define UART3_PA	(NUC970_PA_UART+0x300)
+#define UART4_PA	(NUC970_PA_UART+0x400)
+#define UART5_PA	(NUC970_PA_UART+0x500)
+#define UART6_PA	(NUC970_PA_UART+0x600)
+#define UART7_PA	(NUC970_PA_UART+0x700)
+#define UART8_PA	(NUC970_PA_UART+0x800)
+#define UART9_PA	(NUC970_PA_UART+0x900)
+#define UART10_PA	(NUC970_PA_UART+0xA00)
+
+struct uart_port;
+struct plat_nuc970serial_port {
+	unsigned long	iobase;		/* io base address */
+	void __iomem	*membase;	/* ioremap cookie or NULL */
+	resource_size_t	mapbase;	/* resource base */
+	unsigned int	irq;		/* interrupt number */
+	unsigned int	uartclk;	/* UART clock rate */
+	void            *private_data;
+	unsigned int	(*serial_in)(struct uart_port *, int);
+	void		(*serial_out)(struct uart_port *, int, int);
+};
+
+#ifndef __ASSEMBLY__
+
+struct nuc970_uart_clksrc {
+	const char	*name;
+	unsigned int	divisor;
+	unsigned int	min_baud;
+	unsigned int	max_baud;
+};
+
+struct nuc970_uartcfg {
+	unsigned char	hwport;
+	unsigned char	unused;
+	unsigned short	flags;
+	unsigned long	uart_flags;
+
+	unsigned long	ucon;
+	unsigned long	ulcon;
+	unsigned long	ufcon;
+
+	struct nuc970_uart_clksrc *clocks;
+	unsigned int	clocks_size;
+};
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __ASM_ARM_REGS_SERIAL_H */
+
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-timer.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-timer.h
@@ -0,0 +1,45 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-timer.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_TIMER_H
+#define __ASM_ARCH_REGS_TIMER_H
+
+/* Timer Registers */
+
+#define TMR_BA			NUC970_VA_TIMER
+#define REG_TMR_TCSR0		(TMR_BA+0x00)
+#define REG_TMR_TICR0		(TMR_BA+0x04)
+#define REG_TMR_TDR0		(TMR_BA+0x08)
+
+
+#define REG_TMR_TCSR1		(TMR_BA+0x10)
+#define REG_TMR_TICR1		(TMR_BA+0x14)
+#define REG_TMR_TDR1		(TMR_BA+0x18)
+
+
+#define REG_TMR_TCSR2		(TMR_BA+0x20)
+#define REG_TMR_TICR2		(TMR_BA+0x24)
+#define REG_TMR_TDR2		(TMR_BA+0x28)
+
+#define REG_TMR_TCSR3		(TMR_BA+0x30)
+#define REG_TMR_TICR3		(TMR_BA+0x34)
+#define REG_TMR_TDR3		(TMR_BA+0x38)
+
+#define REG_TMR_TCSR4		(TMR_BA+0x40)
+#define REG_TMR_TICR4		(TMR_BA+0x44)
+#define REG_TMR_TDR4		(TMR_BA+0x48)
+
+#define REG_TMR_TISR		(TMR_BA+0x60)
+
+
+#endif /*  __ASM_ARCH_REGS_TIMER_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-vcap.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-vcap.h
@@ -0,0 +1,154 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-vcap.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef __ASM_ARCH_REGS_VCAP_H
+#define __ASM_ARCH_REGS_VCAP_H
+
+#define BIT0	0x00000001
+#define BIT1	0x00000002
+#define BIT2	0x00000004
+#define BIT3	0x00000008
+#define BIT4	0x00000010
+#define BIT5	0x00000020
+#define BIT6	0x00000040
+#define BIT7	0x00000080
+#define BIT8	0x00000100
+#define BIT9	0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+#include <mach/map.h>
+ 
+#define VIDEOIN_BASE	NUC970_VA_VIDEOIN	/* Videoin Control */
+/*
+ VideoIn Control Registers
+*/
+#define REG_VPECTL  		(VIDEOIN_BASE + 0x00)	// R/W: Video Pre-processor Control Register
+			#define VPRST		BIT24					// Video Pre-processor Reset.
+			#define UPDATE 		BIT20					// Video-In Update Register at New Frame	
+			#define CAPONE		BIT16					// Video-In One Shutter
+			#define VPRBIST		BIT8					// Video-In One Shutter
+			#define PKEN		BIT6					// Packet Output Enable
+			#define PNEN		BIT5					// Planar Output Enable
+			#define ADDRSW		BIT3					// Packet Buffer Address select
+			#define FBMODE		BIT2					// Packet Frame Buffer Control by FSC
+			#define VPEEN		BIT0					// Planar Output Enable	
+
+#define REG_VPEPAR		(VIDEOIN_BASE + 0x04)	// R/W: Video Pre-processor Parameter Register
+			#define VPEBFIN		BIT28					// BIST Finish [Read Only]
+			#define BFAIL		NVTBIT(27, 24)			// BIST Fail Flag [Read Only]
+			#define FLDID		BIT20					// Field ID [Read Only]
+			#define FLD1EN		BIT17					// Field 1 Input Enable
+			#define FLD0EN		BIT16					// Field 0 Input Enable
+			#define FLDDETP		BIT15					// Field Detect Position
+			#define FLDDETM 	BIT14					// Field Detect Mode (By HSYNC or input FIELD PIN)
+			#define FLDSWAP	BIT13					// Swap Input Field
+			#define VSP			BIT10					// Sensor Vsync Polarity.
+			#define HSP			BIT9					// Sensor Hsync Polarity
+			#define PCLKP		BIT8					// Sensor Pixel Clock Polarity	
+			#define PNFMT		BIT7					// Planar Output Format
+			#define RANGE		BIT6					// Scale Input YUV CCIR601 color range to full range
+			#define OUTFMT 	NVTBIT(5, 4)				// Image Data Format Output to System Memory.
+			#define PDORD		NVTBIT(3, 2)				// Sensor Output Type
+			#define SNRTYPE 	BIT1					// device is CCIR601 or CCIR656
+			#define INFMT 		BIT0					// Sensor Output Format
+
+
+#define REG_VPEINT  		(VIDEOIN_BASE + 0x08)	// R/W: Video Pre-processor Interrupt  Register
+			#define MDINTEN	BIT20					// Motion Detection Interrupt Enable
+			#define ADDRMEN  	BIT19					// Address Match Interrupt Enable.	
+			#define MEINTEN	BIT17					// System Memory Error Interrupt Enable.
+			#define VINTEN		BIT16					// Video Frame End Interrupt Enable.
+			#define MDINT		BIT4					// Motion Detection Output Finsish Interrupt		
+			#define ADDRMINT	BIT3					// Memory Address Match Interrupt Flag.
+			#define MEINT		BIT1					// System Memory Error Interrupt. If read this bit shows 1, 
+														// Memory Error occurs. Write 0 to clear it.
+			#define VINT		BIT0					// Video Frame End Interrupt. If read this bit shows 1, 
+														// received a frame complete. Write 0 to clear it.
+
+
+#define REG_VPEMD  		(VIDEOIN_BASE + 0x10)	// R/W: Motion Detection  Register
+			#define MDTHR	  	NVTBIT(20, 16)			// MD Differential Threshold	
+			#define MDDF		NVTBIT(11, 10)			// MD Detect Frequence
+			#define MDSM		BIT9					// MD Save Mode
+			#define MDBS		BIT8					// MD Block Size
+			#define MDEN		BIT0					// MD Enable
+			
+#define REG_MDADDR  		(VIDEOIN_BASE + 0x14)	// R/W: Motion Detection Output Address Register
+#define REG_MDYADDR  	(VIDEOIN_BASE + 0x18)	// R/W: Motion Detection Output Address Register
+
+#define REG_VPECWSP  	(VIDEOIN_BASE + 0x20)	// R/W:  Cropping Window Starting Address Register
+			#define CWSPV		NVTBIT(26, 16)			// Cropping Window Vertical Starting Address
+			#define CWSPH		NVTBIT(11, 0)			// Cropping Window Horizontal  Starting Address
+
+#define REG_VPECWS	 	(VIDEOIN_BASE + 0x24)	// R/W:  Cropping Window Size Register
+			#define CWSH			NVTBIT(26, 16)		// Cropping Image Window Height
+			#define CWSW		NVTBIT(11, 0)			// Cropping Image Window Width
+
+#define REG_VPEPKDS  		(VIDEOIN_BASE + 0x28)	// R/W  : Packet Scaling Vertical/Horizontal Factor Register
+#define REG_VPEPNDS 		(VIDEOIN_BASE + 0x2C)	// R?W  : Planar Scaling Vertical/Horizontal Factor Register	
+			#define DSVN		NVTBIT(31, 24)			// Scaling Vertical Factor N
+			#define DSVM		NVTBIT(23, 16)			// Scaling Vertical Factor M
+			#define DSHN		NVTBIT(15, 8)			// Scaling Horizontal Factor N
+			#define DSHM		NVTBIT(7, 0)				// Scaling Horizontal Factor M
+
+#define REG_VPEFRC  		(VIDEOIN_BASE + 0x30)	// R/W  : Scaling Frame Rate Factor Register
+			#define FRCN		NVTBIT(13, 8)			// Scaling Frame Rate Factor N
+			#define FRCM		NVTBIT(5, 0)				// Scaling Frame Rate Factor M
+		
+/*
+#define REG_VWIDTH  		(VIDEOIN_BASE + 0x34)	// R/W  : Frame Output Pixel Straight Width Register
+			#define PNOW		BIT(27, 16)				// Planar Frame Output Pixel Straight Width
+			#define PKOW		BIT(11, 0)				// Packet Frame Output Pixel Straight Width
+*/
+#define REG_VSTRIDE 		(VIDEOIN_BASE + 0x34)	// R/W  : Frame Stride Register
+			#define PNSTRIDE	NVTBIT(27, 16)			// Planar Frame Stride
+			#define PKSTRIDE	NVTBIT(11, 0)			// Packet Frame Stride
+
+#define REG_VFIFO 		(VIDEOIN_BASE + 0x3C)		// R/W  : FIFO threshold Register
+			#define FTHP		NVTBIT(27, 24)			// Packet FIFO Threshold 
+			#define PTHY		NVTBIT(19, 16)			// Planar Y FIFO Threshold 
+			#define PTHU		NVTBIT(10, 8)			// Planar U FIFO Threshold 
+			#define PTHV		NVTBIT(2, 0)				// Planar V FIFO Threshold 
+
+#define REG_CMPADDR 	(VIDEOIN_BASE + 0x40)		// R/W  : Current Packet System Memory Address Register
+#define REG_CURADDRP 	(VIDEOIN_BASE + 0x50)		// R/W  : FIFO threshold Register
+#define REG_CURADDRY 	(VIDEOIN_BASE + 0x54)		// R/W  : Current Planar Y System Memory Address Register
+#define REG_CURADDRU 	(VIDEOIN_BASE + 0x58)		// R/W  : Current Planar U System Memory Address Register
+#define REG_CURADDRV 	(VIDEOIN_BASE + 0x5C)		// R/W  : Current Planar V System Memory Address Register
+#define REG_PACBA0 	(VIDEOIN_BASE + 0x60)		// R/W  : System Memory Packet 0 Base Address Register
+#define REG_PACBA1 	(VIDEOIN_BASE + 0x64)		// R/W  : System Memory Packet 1 Base Address Register
+#define REG_YBA0 		(VIDEOIN_BASE + 0x80)		// R/W  : System Memory Planar Y Base Address Register
+#define REG_UBA0 		(VIDEOIN_BASE + 0x84)		// R/W  : System Memory Planar U Base Address Register
+#define REG_VBA0 		(VIDEOIN_BASE + 0x88)		// R/W  : System Memory Planar V Base Address Register
+
+#endif /*  __ASM_ARCH_REGS_VCAP_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-wdt.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-wdt.h
@@ -0,0 +1,24 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-wdt.h
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_WDT_H
+#define __ASM_ARCH_REGS_WDT_H
+
+/* WDT Registers */
+
+#define WDT_BA			NUC970_VA_WDT
+#define REG_WDT_CR		(WDT_BA+0x00)
+#define REG_WDT_CTALT		(WDT_BA+0x04)
+
+
+#endif /*  __ASM_ARCH_REGS_WDT_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-wwdt.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/regs-wwdt.h
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/regs-wwdt.h
+ *
+ * Copyright (c) 2014 Nuvoton Technology Corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_REGS_WWDT_H
+#define __ASM_ARCH_REGS_WWDT_H
+
+/* WWDT Registers */
+
+#define WWDT_BA			NUC970_VA_WWDT
+#define REG_WWDT_RLD		(WWDT_BA+0x00)
+#define REG_WWDT_CR		(WWDT_BA+0x04)
+#define REG_WWDT_SR		(WWDT_BA+0x08)
+#define REG_WWDT_CVR		(WWDT_BA+0x0C)
+
+
+#endif /*  __ASM_ARCH_REGS_WWDT_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/system.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/system.h
@@ -0,0 +1,34 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/system.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/io.h>
+#include <asm/proc-fns.h>
+#include <mach/map.h>
+
+
+static void arch_idle(void)
+{
+}
+
+static void arch_reset(char mode, const char *cmd)
+{
+	if (mode == 's') {
+		/* Jump into ROM at address 0 */
+		//cpu_reset(0);
+		while(1);
+	} else {
+		//__raw_writel(WTE | WTRE | WTCLK, WTCR);
+		while(1);
+	}
+}
+
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/timex.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/timex.h
@@ -0,0 +1,21 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/timex.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+/* CLOCK_TICK_RATE Now, I don't use it. */
+
+#define CLOCK_TICK_RATE 15000000
+
+#endif /* __ASM_ARCH_TIMEX_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/uncompress.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/uncompress.h
@@ -0,0 +1,46 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/uncompress.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+/* Defines for UART registers */
+
+#include <mach/regs-serial.h>
+#include <mach/map.h>
+#include <linux/serial_reg.h>
+
+#define arch_decomp_wdog()
+
+#define TX_DONE	(UART_LSR_TEMT | UART_LSR_THRE)
+static volatile u32 * uart_base = (u32 *)UART0_PA;
+
+static void putc(int ch)
+{
+	/* Check THRE and TEMT bits before we transmit the character.
+	 */
+	while ((uart_base[UART_LSR] & TX_DONE) != TX_DONE)
+		barrier();
+
+	*uart_base = ch;
+}
+
+static inline void flush(void)
+{
+}
+
+static void arch_decomp_setup(void)
+{
+}
+
+#endif/* __ASM_NUC970_UNCOMPRESS_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/include/mach/vmalloc.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/include/mach/vmalloc.h
@@ -0,0 +1,19 @@
+/*
+ * arch/arm/mach-nuc970/include/mach/vmalloc.h
+ *
+ * Copyright (c) 2012 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#define VMALLOC_END	  (0xe0000000UL)
+
+#endif /* __ASM_ARCH_VMALLOC_H */
Index: linux-4.4.92/arch/arm/mach-nuc970/irq.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/irq.c
@@ -0,0 +1,576 @@
+/*
+ * linux/arch/arm/mach-nuc970/irq.c
+ *
+ * based on linux/arch/arm/sa1100/irq.c
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/ioport.h>
+#include <linux/ptrace.h>
+#include <linux/device.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-aic.h>
+#include <mach/regs-gpio.h>
+#include <asm/gpio.h>
+#include <mach/gpio.h>
+
+static void nuc970_irq_mask(struct irq_data *d)
+{
+	if(d->irq < 32)
+		__raw_writel(1 << (d->irq), REG_AIC_MDCR);
+	else
+		__raw_writel(1 << (d->irq - 32), REG_AIC_MDCRH);	
+}
+
+
+static void nuc970_irq_ack(struct irq_data *d)
+{
+	__raw_writel(0x01, REG_AIC_EOSCR);
+}
+
+static void nuc970_irq_unmask(struct irq_data *d)
+{
+	if(d->irq < 32)
+		__raw_writel(1 << (d->irq), REG_AIC_MECR);
+	else
+		__raw_writel(1 << (d->irq - 32), REG_AIC_MECRH);	
+}
+
+static int nuc970_irq_set_wake(struct irq_data *d, unsigned int on)
+{
+	return 0;
+}
+
+
+static struct irq_chip nuc970_irq_chip = {
+	.irq_disable	= nuc970_irq_mask,
+	.irq_enable	= nuc970_irq_unmask,
+	.irq_ack	= nuc970_irq_ack,
+	.irq_mask	= nuc970_irq_mask,
+	.irq_unmask	= nuc970_irq_unmask,
+	.irq_set_wake	= nuc970_irq_set_wake,
+};
+
+#if defined(CONFIG_GPIO_NUC970)
+
+static const unsigned int Port[10]={
+				(unsigned int)REG_GPIOA_DIR,
+				(unsigned int)REG_GPIOB_DIR,
+				(unsigned int)REG_GPIOC_DIR,
+				(unsigned int)REG_GPIOD_DIR,
+				(unsigned int)REG_GPIOE_DIR,
+				(unsigned int)REG_GPIOF_DIR,
+				(unsigned int)REG_GPIOG_DIR,
+				(unsigned int)REG_GPIOH_DIR,
+				(unsigned int)REG_GPIOI_DIR,
+				(unsigned int)REG_GPIOJ_DIR};
+static unsigned short FType[10];
+static unsigned short RType[10];
+
+static void nuc970_irq_gpio_unmask(struct irq_data *d)
+{
+        unsigned int port,num,tmp;
+        port =(d->irq-IRQ_GPIO_START)/GPIO_OFFSET;
+        num  =(d->irq-IRQ_GPIO_START)%GPIO_OFFSET;
+        tmp = RType[port] & (0x1<<num);
+        __raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10))|tmp,(volatile unsigned int *)(Port[port]+0x10));
+        tmp = FType[port] & (0x1<<num);
+        __raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14))|tmp,(volatile unsigned int *)(Port[port]+0x14));
+}
+
+
+static void nuc970_irq_gpio_ack(struct irq_data *d)
+{
+	__raw_writel(0x01, REG_AIC_EOSCR);
+}
+
+static void nuc970_irq_gpio_mask(struct irq_data *d)
+{
+	unsigned int port,num;
+	port =(d->irq-IRQ_GPIO_START)/GPIO_OFFSET;
+	num  =(d->irq-IRQ_GPIO_START)%GPIO_OFFSET;
+        __raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10)) &~(0x1<<num),(volatile unsigned int *)(Port[port]+0x10));
+        __raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14)) &~(0x1<<num),(volatile unsigned int *)(Port[port]+0x14));
+}
+
+static int nuc970_irq_gpio_type(struct irq_data *d, unsigned int type)
+{
+	unsigned int port,num;
+	port =(d->irq-IRQ_GPIO_START)/GPIO_OFFSET;
+	num  =(d->irq-IRQ_GPIO_START)%GPIO_OFFSET;
+
+	if (type == IRQ_TYPE_PROBE) {
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10)) |(0x1<<num),(volatile unsigned int *)(Port[port]+0x10));
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14)) |(0x1<<num),(volatile unsigned int *)(Port[port]+0x14));
+                RType[port] |= (0x1<<num);
+                FType[port] |= (0x1<<num);
+		return 0;
+	}
+	if(type&IRQ_TYPE_LEVEL_MASK){
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x0C)) | (0x1<<num),(volatile unsigned int *)(Port[port]+0x0C));
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10)) &~(0x1<<num),(volatile unsigned int *)(Port[port]+0x10));
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14)) &~(0x1<<num),(volatile unsigned int *)(Port[port]+0x14));
+                RType[port] &= ~(0x1<<num);
+                FType[port] &= ~(0x1<<num);
+		if(type==IRQ_TYPE_LEVEL_HIGH){
+			__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10)) | (0x1<<num),(volatile unsigned int *)(Port[port]+0x10));
+                        RType[port] |= (0x1<<num);
+			return 0;
+		}
+		if(type==IRQ_TYPE_LEVEL_LOW){
+			__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14)) | (0x1<<num),(volatile unsigned int *)(Port[port]+0x14));
+                        FType[port] |= (0x1<<num);
+			return 0;
+		}
+	}else{
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x0C)) &~(0x1<<num),(volatile unsigned int *)(Port[port]+0x0C));
+		if (type & IRQ_TYPE_EDGE_RISING)
+		{
+			__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10)) | (0x1<<num),(volatile unsigned int *)(Port[port]+0x10));
+                        RType[port] |= (0x1<<num);
+		}else{
+			__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10)) &~(0x1<<num),(volatile unsigned int *)(Port[port]+0x10));
+                        RType[port] &= ~(0x1<<num);
+                }
+		if (type & IRQ_TYPE_EDGE_FALLING){
+			__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14)) | (0x1<<num),(volatile unsigned int *)(Port[port]+0x14));
+                        FType[port] |= (0x1<<num);
+		}else{
+			__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14)) &~(0x1<<num),(volatile unsigned int *)(Port[port]+0x14));
+                        FType[port] &= ~(0x1<<num);
+               }
+	}
+	return 0;
+}
+
+static struct irq_chip nuc970_irq_gpio = {
+	.name		= "GPIO-IRQ",
+	.irq_disable	= nuc970_irq_gpio_mask,
+	.irq_enable	= nuc970_irq_gpio_unmask,
+	.irq_ack	= nuc970_irq_gpio_ack,
+	.irq_mask	= nuc970_irq_gpio_mask,
+	.irq_unmask	= nuc970_irq_gpio_unmask,
+	.irq_set_type	= nuc970_irq_gpio_type,
+	.irq_set_wake	= nuc970_irq_set_wake,
+};
+
+static void nuc970_irq_demux_intgroup(/*unsigned int irq,*/
+			struct irq_desc *desc)
+{
+	unsigned int i,j,isr,sub_isr;
+	isr=__raw_readl(REG_GPIO_ISR);
+	for(i=0;i<10;i++)
+	{
+		if(isr & 0x1)
+		{
+			sub_isr=__raw_readl((volatile unsigned int *)(Port[i]+0x18));
+			for(j=0;j<16;j++)
+			{
+				if(sub_isr & 0x1)
+				{
+					generic_handle_irq(IRQ_GPIO_START+i*0x20+j);
+                                        __raw_writel((1<<j),(volatile unsigned int *)(Port[i]+0x18));
+				}
+				sub_isr=sub_isr>>1;
+			}
+		}
+		isr=isr>>1;
+	}
+}
+//------------------------------------------------------------------------------
+
+static const unsigned int EXT[16]={
+				(unsigned int)NUC970_PH0,
+				(unsigned int)NUC970_PH1,
+				(unsigned int)NUC970_PH2,
+				(unsigned int)NUC970_PH3,
+				(unsigned int)NUC970_PH4,
+				(unsigned int)NUC970_PH5,
+				(unsigned int)NUC970_PH6,
+				(unsigned int)NUC970_PH7,
+				(unsigned int)NUC970_PF11,
+				(unsigned int)NUC970_PF12,
+				(unsigned int)NUC970_PF13,
+				(unsigned int)NUC970_PF14,
+				(unsigned int)NUC970_PF15,
+				(unsigned int)NUC970_PG15,
+				(unsigned int)NUC970_PI1,
+				(unsigned int)NUC970_PI2,
+};
+
+static void nuc970_irq_ext_mask(struct irq_data *d)
+{
+	if(d->irq==IRQ_EXT0_H0 || d->irq==IRQ_EXT0_F11)
+		__raw_writel(1<<IRQ_EXT0, REG_AIC_MDCR);
+	else if(d->irq==IRQ_EXT1_H1 || d->irq==IRQ_EXT1_F12)
+		__raw_writel(1 <<IRQ_EXT1, REG_AIC_MDCR);
+	else if(d->irq==IRQ_EXT2_H2 || d->irq==IRQ_EXT2_F13)
+		__raw_writel(1 <<IRQ_EXT2, REG_AIC_MDCR);
+	else if(d->irq==IRQ_EXT3_H3 || d->irq==IRQ_EXT3_F14)
+		__raw_writel(1 <<IRQ_EXT3, REG_AIC_MDCR);
+	else if(d->irq==IRQ_EXT4_H4 || d->irq==IRQ_EXT4_F15)
+		__raw_writel(1 <<IRQ_EXT4, REG_AIC_MDCR);
+	else if(d->irq==IRQ_EXT5_H5 || d->irq==IRQ_EXT5_G15)
+		__raw_writel(1 <<IRQ_EXT5, REG_AIC_MDCR);
+	else if(d->irq==IRQ_EXT6_H6 || d->irq==IRQ_EXT6_I1)
+		__raw_writel(1 <<IRQ_EXT6, REG_AIC_MDCR);
+	else if(d->irq==IRQ_EXT7_H7 || d->irq==IRQ_EXT7_I2)
+		__raw_writel(1 <<IRQ_EXT7, REG_AIC_MDCR);
+}
+
+static void nuc970_irq_ext_ack(struct irq_data *d)
+{
+	__raw_writel(0x01, REG_AIC_EOSCR);
+}
+
+static void nuc970_irq_ext_unmask(struct irq_data *d)
+{
+	if(d->irq==IRQ_EXT0_H0 || d->irq==IRQ_EXT0_F11)
+		__raw_writel(1 <<IRQ_EXT0, REG_AIC_MECR);
+	else if(d->irq==IRQ_EXT1_H1 || d->irq==IRQ_EXT1_F12)
+		__raw_writel(1 <<IRQ_EXT1, REG_AIC_MECR);
+	else if(d->irq==IRQ_EXT2_H2 || d->irq==IRQ_EXT2_F13)
+		__raw_writel(1 <<IRQ_EXT2, REG_AIC_MECR);
+	else if(d->irq==IRQ_EXT3_H3 || d->irq==IRQ_EXT3_F14)
+		__raw_writel(1 <<IRQ_EXT3, REG_AIC_MECR);
+	else if(d->irq==IRQ_EXT4_H4 || d->irq==IRQ_EXT4_F15)
+		__raw_writel(1 <<IRQ_EXT4, REG_AIC_MECR);
+	else if(d->irq==IRQ_EXT5_H5 || d->irq==IRQ_EXT5_G15)
+		__raw_writel(1 <<IRQ_EXT5, REG_AIC_MECR);
+	else if(d->irq==IRQ_EXT6_H6 || d->irq==IRQ_EXT6_I1)
+		__raw_writel(1 <<IRQ_EXT6, REG_AIC_MECR);
+	else if(d->irq==IRQ_EXT7_H7 || d->irq==IRQ_EXT7_I2)
+		__raw_writel(1 <<IRQ_EXT7, REG_AIC_MECR);
+}
+
+static int nuc970_irq_ext_type(struct irq_data *d, unsigned int type)
+{
+	unsigned int port,num;
+	port =(EXT[d->irq-EXT0_BASE])/GPIO_OFFSET;
+	num  =(EXT[d->irq-EXT0_BASE])%GPIO_OFFSET;
+	if (type == IRQ_TYPE_PROBE) {
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10)) |(0x1<<num),(volatile unsigned int *)(Port[port]+0x10));
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14)) |(0x1<<num),(volatile unsigned int *)(Port[port]+0x14));
+		return 0;
+	}
+
+	if (type & IRQ_TYPE_EDGE_RISING)
+	{
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10)) | (0x1<<num),(volatile unsigned int *)(Port[port]+0x10));
+	}else
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x10)) & ~(0x1<<num),(volatile unsigned int *)(Port[port]+0x10));
+
+	if (type & IRQ_TYPE_EDGE_FALLING){
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14)) | (0x1<<num),(volatile unsigned int *)(Port[port]+0x14));
+	}else
+		__raw_writel(__raw_readl((volatile unsigned int *)(Port[port]+0x14)) & ~(0x1<<num),(volatile unsigned int *)(Port[port]+0x14));
+
+	return 0;
+}
+
+static struct irq_chip nuc970_irq_ext = {
+	.name		= "EXT-IRQ",
+	.irq_disable	= nuc970_irq_ext_mask,
+	.irq_enable	= nuc970_irq_ext_unmask,
+	.irq_ack	= nuc970_irq_ext_ack,
+	.irq_mask	= nuc970_irq_ext_mask,
+	.irq_unmask	= nuc970_irq_ext_unmask,
+	.irq_set_type	= nuc970_irq_ext_type,
+	.irq_set_wake	= nuc970_irq_set_wake,
+};
+
+static void nuc970_irq_demux_intgroup2(/*unsigned int irq,*/
+			struct irq_desc *desc)
+{
+	unsigned int port0,num0,port1,num1;
+
+	// in kernel 4.4.y
+	unsigned int irq = desc->irq_data.irq;
+
+	port0= EXT[irq-4]/GPIO_OFFSET;
+	num0 = EXT[irq-4]%GPIO_OFFSET;
+	port1= EXT[irq-4+8]/GPIO_OFFSET;
+	num1 = EXT[irq-4+8]%GPIO_OFFSET;
+	switch(irq)
+	{
+		case IRQ_EXT0:
+			if(__raw_readl((volatile unsigned int *)(Port[port0]+0x18)) & (1<<num0))
+			{
+				generic_handle_irq(IRQ_EXT0_H0);
+				__raw_writel(0x1<<num0,(volatile unsigned int *)(Port[port0]+0x18));
+			}
+			else if(__raw_readl((volatile unsigned int *)(Port[port1]+0x18)) & (1<<num1))
+			{
+				generic_handle_irq(IRQ_EXT0_F11);
+				__raw_writel(0x1<<num1,(volatile unsigned int *)(Port[port1]+0x18));
+			}
+			break;
+		case IRQ_EXT1:
+			if(__raw_readl((volatile unsigned int *)(Port[port0]+0x18)) & (1<<num0))
+			{
+				generic_handle_irq(IRQ_EXT1_H1);
+				__raw_writel(0x1<<num0,(volatile unsigned int *)(Port[port0]+0x18));
+			}
+			else if(__raw_readl((volatile unsigned int *)(Port[port1]+0x18)) & (1<<num1))
+			{
+				generic_handle_irq(IRQ_EXT1_F12);
+				__raw_writel(0x1<<num1,(volatile unsigned int *)(Port[port1]+0x18));
+			}
+			break;
+		case IRQ_EXT2:
+			if(__raw_readl((volatile unsigned int *)(Port[port0]+0x18)) & (1<<num0))
+			{
+				generic_handle_irq(IRQ_EXT2_H2);
+				__raw_writel(0x1<<num0,(volatile unsigned int *)(Port[port0]+0x18));
+			}
+			else if(__raw_readl((volatile unsigned int *)(Port[port1]+0x18)) & (1<<num1))
+			{
+				generic_handle_irq(IRQ_EXT2_F13);
+				__raw_writel(0x1<<num1,(volatile unsigned int *)(Port[port1]+0x18));
+			}
+			break;
+		case IRQ_EXT3:
+			if(__raw_readl((volatile unsigned int *)(Port[port0]+0x18)) & (1<<num0))
+			{
+				generic_handle_irq(IRQ_EXT3_H3);
+				__raw_writel(0x1<<num0,(volatile unsigned int *)(Port[port0]+0x18));
+			}
+			else if(__raw_readl((volatile unsigned int *)(Port[port1]+0x18)) & (1<<num1))
+			{
+				generic_handle_irq(IRQ_EXT3_F14);
+				__raw_writel(0x1<<num1,(volatile unsigned int *)(Port[port1]+0x18));
+			}
+			break;
+		case IRQ_EXT4:
+			if(__raw_readl((volatile unsigned int *)(Port[port0]+0x18)) & (1<<num0))
+			{
+				generic_handle_irq(IRQ_EXT4_H4);
+				__raw_writel(0x1<<num0,(volatile unsigned int *)(Port[port0]+0x18));
+			}
+			else if(__raw_readl((volatile unsigned int *)(Port[port1]+0x18)) & (1<<num1))
+			{
+				generic_handle_irq(IRQ_EXT4_F15);
+				__raw_writel(0x1<<num1,(volatile unsigned int *)(Port[port1]+0x18));
+			}
+			break;
+		case IRQ_EXT5:
+			if(__raw_readl((volatile unsigned int *)(Port[port0]+0x18)) & (1<<num0))
+			{
+				generic_handle_irq(IRQ_EXT5_H5);
+				__raw_writel(0x1<<num0,(volatile unsigned int *)(Port[port0]+0x18));
+			}
+			else if(__raw_readl((volatile unsigned int *)(Port[port1]+0x18)) & (1<<num1))
+			{
+				generic_handle_irq(IRQ_EXT5_G15);
+				__raw_writel(0x1<<num1,(volatile unsigned int *)(Port[port1]+0x18));
+			}
+			break;
+		case IRQ_EXT6:
+			if(__raw_readl((volatile unsigned int *)(Port[port0]+0x18)) & (1<<num0))
+			{
+				generic_handle_irq(IRQ_EXT6_H6);
+				__raw_writel(0x1<<num0,(volatile unsigned int *)(Port[port0]+0x18));
+			}
+			else if(__raw_readl((volatile unsigned int *)(Port[port1]+0x18)) & (1<<num1))
+			{
+				generic_handle_irq(IRQ_EXT6_I1);
+				__raw_writel(0x1<<num1,(volatile unsigned int *)(Port[port1]+0x18));
+			}
+			break;
+		case IRQ_EXT7:
+			if(__raw_readl((volatile unsigned int *)(Port[port0]+0x18)) & (1<<num0))
+			{
+				generic_handle_irq(IRQ_EXT7_H7);
+				__raw_writel(0x1<<num0,(volatile unsigned int *)(Port[port0]+0x18));
+			}
+			else if(__raw_readl((volatile unsigned int *)(Port[port1]+0x18)) & (1<<num1))
+			{
+				generic_handle_irq(IRQ_EXT7_I2);
+				__raw_writel(0x1<<num1,(volatile unsigned int *)(Port[port1]+0x18));
+			}
+			break;
+	}
+}
+#endif
+
+void __init nuc970_init_irq(void)
+{
+#if !defined(CONFIG_OF)
+
+	int irqno;
+
+	__raw_writel(0xFFFFFFFC, REG_AIC_MDCR);
+	__raw_writel(0xFFFFFFFF, REG_AIC_MDCRH);
+
+	for (irqno = IRQ_WDT; irqno < NR_IRQS-SPARE_IRQS; irqno++) {
+		irq_set_chip_and_handler(irqno, &nuc970_irq_chip, handle_level_irq);
+//		set_irq_flags(irqno, IRQF_VALID);
+        irq_clear_status_flags(irqno, IRQ_NOREQUEST);
+	}
+
+#if defined(CONFIG_GPIO_NUC970) 
+	/*
+	 * Install handler for GPIO edge detect interrupts
+	 */
+		irq_set_chip(IRQ_GPIO, &nuc970_irq_chip);
+		irq_set_chained_handler(IRQ_GPIO, nuc970_irq_demux_intgroup);
+
+		for (irqno = IRQ_GPIO_START; irqno < IRQ_GPIO_END; irqno++) {
+			irq_set_chip_and_handler(irqno, &nuc970_irq_gpio, handle_level_irq);
+//			set_irq_flags(irqno, IRQF_VALID);
+            irq_clear_status_flags(irqno, IRQ_NOREQUEST);
+		}
+
+	/*
+	 * Install handler for GPIO external interrupts
+	 */
+	for (irqno = IRQ_EXT0; irqno <= IRQ_EXT7; irqno++) {
+		//printk("registering irq %d (extended nuc970 irq)\n", irqno);
+		irq_set_chip(irqno, &nuc970_irq_chip);
+		irq_set_chained_handler(irqno, nuc970_irq_demux_intgroup2);
+	}
+
+	for (irqno = IRQ_EXT0_H0; irqno <= IRQ_EXT7_I2; irqno++) {
+			irq_set_chip_and_handler(irqno, &nuc970_irq_ext, handle_level_irq);
+//			set_irq_flags(irqno, IRQF_VALID);
+            irq_clear_status_flags(irqno, IRQ_NOREQUEST);
+	}
+#endif
+#endif
+}
+
+#ifdef CONFIG_OF
+
+static struct irq_domain *nuc970_aic_domain;
+
+static int nuc970_aic_irq_map(struct irq_domain *h, unsigned int virq,
+							irq_hw_number_t hw)
+{
+	//printk("nuc970_aic_irq_map: %d %d\n", virq, (int)hw);
+	
+	if ((IRQ_WDT <= hw) && (hw < NR_IRQS-SPARE_IRQS))
+	{
+		irq_set_chip_and_handler(virq, &nuc970_irq_chip, handle_level_irq);
+//		set_irq_flags(virq, IRQF_VALID | IRQF_PROBE);
+        irq_clear_status_flags(virq, IRQ_NOREQUEST | IRQ_NOPROBE);
+		
+#if defined(CONFIG_GPIO_NUC970) 
+
+		if(hw==IRQ_GPIO){
+			int irqno;
+			/*
+			 * Install handler for GPIO edge detect interrupts
+			 */
+				irq_set_chip(IRQ_GPIO, &nuc970_irq_chip);
+				irq_set_chained_handler(IRQ_GPIO, nuc970_irq_demux_intgroup);
+		
+				for (irqno = IRQ_GPIO_START; irqno < IRQ_GPIO_END; irqno++) {
+					irq_set_chip_and_handler(irqno, &nuc970_irq_gpio, handle_level_irq);
+//					set_irq_flags(irqno, IRQF_VALID);
+                    irq_clear_status_flags(irqno, IRQ_NOREQUEST);
+				}
+		
+			/*
+			 * Install handler for GPIO external interrupts
+			 */
+			for (irqno = IRQ_EXT0; irqno <= IRQ_EXT7; irqno++) {
+				//printk("registering irq %d (extended nuc970 irq)\n", irqno);
+				irq_set_chip(irqno, &nuc970_irq_chip);
+				irq_set_chained_handler(irqno, nuc970_irq_demux_intgroup2);
+			}
+		
+			for (irqno = IRQ_EXT0_H0; irqno <= IRQ_EXT7_I2; irqno++) {
+					irq_set_chip_and_handler(irqno, &nuc970_irq_ext, handle_level_irq);
+//					set_irq_flags(irqno, IRQF_VALID);
+                    irq_clear_status_flags(irqno, IRQ_NOREQUEST);
+
+			}
+		}
+#endif
+
+	}
+//	else if ((IRQ_GPIO_START <= hw) && (hw < NR_IRQS-IRQ_GPIO_END))
+//	{
+//		irq_set_chip_and_handler(virq, &nuc970_irq_gpio, handle_level_irq);
+//		set_irq_flags(virq, IRQF_VALID | IRQF_PROBE);
+//	}
+//	else if ((IRQ_GPIO_START <= hw) && (hw < NR_IRQS-IRQ_GPIO_END))
+//	{
+//		irq_set_chip_and_handler(virq, &nuc970_irq_chip, handle_level_irq);
+//		set_irq_flags(virq, IRQF_VALID | IRQF_PROBE);
+//	}
+	else 
+		return -EINVAL;
+
+	return 0;
+}
+
+static int nuc970_aic_irq_domain_xlate(struct irq_domain *d, struct device_node *ctrlr,
+				const u32 *intspec, unsigned int intsize,
+				irq_hw_number_t *out_hwirq, unsigned int *out_type)
+{
+	if (WARN_ON(intsize < 2))
+		return -EINVAL;
+	if (WARN_ON(intspec[0] >= NR_IRQS))
+		return -EINVAL;
+
+	*out_hwirq = intspec[0];
+	*out_type = IRQ_TYPE_NONE;
+
+	//printk("nuc970_aic_irq_domain_xlate: %d\n", intspec[0]);
+
+	return 0;
+}
+
+static struct irq_domain_ops nuc970_aic_irq_ops = {
+	.map    = nuc970_aic_irq_map,
+	.xlate	= nuc970_aic_irq_domain_xlate,
+};
+
+int __init nuc970_of_init_irq(struct device_node *node, struct device_node *parent)
+{
+	nuc970_aic_domain = irq_domain_add_linear(node, SPARE_IRQS,
+						&nuc970_aic_irq_ops, NULL);
+	if (!nuc970_aic_domain)
+		panic("Failed to add irq domain!!\n");
+
+	irq_set_default_host(nuc970_aic_domain);
+
+	__raw_writel(0xFFFFFFFC, REG_AIC_MDCR);
+	__raw_writel(0xFFFFFFFF, REG_AIC_MDCRH);
+
+	irq_set_chip_and_handler(IRQ_TMR0, &nuc970_irq_chip, handle_level_irq);
+//	set_irq_flags(IRQ_TMR0, IRQF_VALID);
+    irq_clear_status_flags(IRQ_TMR0, IRQ_NOREQUEST);
+
+	//irq_set_chip_and_handler(IRQ_UART0, &nuc970_irq_chip, handle_level_irq);
+	//set_irq_flags(IRQ_UART0, IRQF_VALID);
+
+	return 0;	
+}
+
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/mach-nuc970.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/mach-nuc970.c
@@ -0,0 +1,94 @@
+ /*
+ * linux/arch/arm/mach-nuc970/mach-nuc970.c
+ *
+ * Copyright (C) 2014 Nuvoton technology corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+#include <mach/map.h>
+#include <mach/mfp.h>
+
+#include <mach/irqs.h>
+#include <mach/regs-gcr.h>
+#include <mach/regs-aic.h>
+#include "cpu.h"
+#include "pm.h"
+
+/* Initial IO mappings */	//TODO: MAP ENABLED IP ONLY
+static struct map_desc nuc970_iodesc[] __initdata = {
+	IODESC_ENT(IRQ),
+	IODESC_ENT(GCR_CLK),
+	IODESC_ENT(EBI_SDIC),
+        IODESC_ENT(EMAC0),
+        IODESC_ENT(EMAC1),
+        IODESC_ENT(GDMA),
+        IODESC_ENT(EHCI),
+        IODESC_ENT(OHCI),
+        IODESC_ENT(USBDEV),
+        IODESC_ENT(LCD),
+        IODESC_ENT(ACTL),
+        IODESC_ENT(JPEG),
+        IODESC_ENT(GE),
+        IODESC_ENT(SDH),
+        IODESC_ENT(FMI),
+        IODESC_ENT(CAP),
+        IODESC_ENT(CRYPTO),
+        IODESC_ENT(UART),
+	IODESC_ENT(TIMER_ETIMER_WDT_WWDT),
+        IODESC_ENT(GPIO),
+        IODESC_ENT(RTC),
+        IODESC_ENT(SC),
+	IODESC_ENT(I2C_SPI),
+        IODESC_ENT(PWM),
+        IODESC_ENT(KPI),
+        IODESC_ENT(ADC),
+        IODESC_ENT(CAN),
+        IODESC_ENT(MTP),
+        IODESC_ENT(SRAM),
+};
+
+extern void nuc970_restart(/*char*/enum reboot_mode mode, const char *cmd);
+extern void nuc970_timer_init(void);
+static struct platform_device *nuc970_dev[] __initdata = {
+
+};
+
+void __init nuc970_map_io(void)
+{
+	iotable_init(nuc970_iodesc, ARRAY_SIZE(nuc970_iodesc));
+}
+#if 0
+static void __init nuc970_init(void)
+{
+	nuc970_platform_init(nuc970_dev, ARRAY_SIZE(nuc970_dev));
+}
+
+static void __init nuc970_init_late(void)
+{
+	nuc970_init_suspend();
+}
+
+MACHINE_START(NUC970, "NUC970")
+	.atag_offset	= 0x100,
+	.map_io		= nuc970_map_io,
+	.init_irq	= nuc970_init_irq,
+	.init_machine	= nuc970_init,
+	.init_time	= nuc970_timer_init,
+	.init_late	= nuc970_init_late,
+	.restart	= nuc970_restart,
+MACHINE_END
+#endif
Index: linux-4.4.92/arch/arm/mach-nuc970/mfp.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/mfp.c
@@ -0,0 +1,170 @@
+/*
+ * linux/arch/arm/mach-nuc970/mfp.c
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <mach/map.h>
+#include <mach/regs-gcr.h>
+
+static DEFINE_SPINLOCK(mfp_lock);
+
+// TODO: error checking...?
+
+void nuc970_mfp_set_port_a(u32 pin, u32 func)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&mfp_lock, flags);
+	if(pin < 8) {
+		pin *= 4;
+		__raw_writel((__raw_readl(REG_MFP_GPA_L) & ~(0xF << pin)) | (func << pin), REG_MFP_GPA_L);
+	} else {
+		pin = (pin - 8) * 4;
+		__raw_writel((__raw_readl(REG_MFP_GPA_H) & ~(0xF << pin)) | (func << pin), REG_MFP_GPA_H);
+	}
+	spin_unlock_irqrestore(&mfp_lock, flags);
+}
+EXPORT_SYMBOL(nuc970_mfp_set_port_a);
+
+void nuc970_mfp_set_port_b(u32 pin, u32 func)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&mfp_lock, flags);
+	if(pin < 8) {
+		pin *= 4;
+		__raw_writel((__raw_readl(REG_MFP_GPB_L) & ~(0xF << pin)) | (func << pin), REG_MFP_GPB_L);
+	} else {
+		pin = (pin - 8) * 4;
+		__raw_writel((__raw_readl(REG_MFP_GPB_H) & ~(0xF << pin)) | (func << pin), REG_MFP_GPB_H);
+	}
+	spin_unlock_irqrestore(&mfp_lock, flags);
+}
+EXPORT_SYMBOL(nuc970_mfp_set_port_b);
+
+void nuc970_mfp_set_port_c(u32 pin, u32 func)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&mfp_lock, flags);
+	if(pin < 8) {
+		pin *= 4;
+		__raw_writel((__raw_readl(REG_MFP_GPC_L) & ~(0xF << pin)) | (func << pin), REG_MFP_GPC_L);
+	} else {
+		pin = (pin - 8) * 4;
+		__raw_writel((__raw_readl(REG_MFP_GPC_H) & ~(0xF << pin)) | (func << pin), REG_MFP_GPC_H);
+	}
+	spin_unlock_irqrestore(&mfp_lock, flags);
+}
+EXPORT_SYMBOL(nuc970_mfp_set_port_c);
+
+void nuc970_mfp_set_port_d(u32 pin, u32 func)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&mfp_lock, flags);
+	if(pin < 8) {
+		pin *= 4;
+		__raw_writel((__raw_readl(REG_MFP_GPD_L) & ~(0xF << pin)) | (func << pin), REG_MFP_GPD_L);
+	} else {
+		pin = (pin - 8) * 4;
+		__raw_writel((__raw_readl(REG_MFP_GPD_H) & ~(0xF << pin)) | (func << pin), REG_MFP_GPD_H);
+	}
+	spin_unlock_irqrestore(&mfp_lock, flags);
+}
+EXPORT_SYMBOL(nuc970_mfp_set_port_d);
+
+void nuc970_mfp_set_port_e(u32 pin, u32 func)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&mfp_lock, flags);
+	if(pin < 8) {
+		pin *= 4;
+		__raw_writel((__raw_readl(REG_MFP_GPE_L) & ~(0xF << pin)) | (func << pin), REG_MFP_GPE_L);
+	} else {
+		pin = (pin - 8) * 4;
+		__raw_writel((__raw_readl(REG_MFP_GPE_H) & ~(0xF << pin)) | (func << pin), REG_MFP_GPE_H);
+	}
+	spin_unlock_irqrestore(&mfp_lock, flags);
+}
+EXPORT_SYMBOL(nuc970_mfp_set_port_e);
+
+void nuc970_mfp_set_port_f(u32 pin, u32 func)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&mfp_lock, flags);
+	if(pin < 8) {
+		pin *= 4;
+		__raw_writel((__raw_readl(REG_MFP_GPF_L) & ~(0xF << pin)) | (func << pin), REG_MFP_GPF_L);
+	} else {
+		pin = (pin - 8) * 4;
+		__raw_writel((__raw_readl(REG_MFP_GPF_H) & ~(0xF << pin)) | (func << pin), REG_MFP_GPF_H);
+	}
+	spin_unlock_irqrestore(&mfp_lock, flags);
+}
+EXPORT_SYMBOL(nuc970_mfp_set_port_f);
+
+
+void nuc970_mfp_set_port_g(u32 pin, u32 func)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&mfp_lock, flags);
+	if(pin < 8) {
+		pin *= 4;
+		__raw_writel((__raw_readl(REG_MFP_GPG_L) & ~(0xF << pin)) | (func << pin), REG_MFP_GPG_L);
+	} else {
+		pin = (pin - 8) * 4;
+		__raw_writel((__raw_readl(REG_MFP_GPG_H) & ~(0xF << pin)) | (func << pin), REG_MFP_GPG_H);
+	}
+	spin_unlock_irqrestore(&mfp_lock, flags);
+}
+EXPORT_SYMBOL(nuc970_mfp_set_port_g);
+
+void nuc970_mfp_set_port_h(u32 pin, u32 func)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&mfp_lock, flags);
+	if(pin < 8) {
+		pin *= 4;
+		__raw_writel((__raw_readl(REG_MFP_GPH_L) & ~(0xF << pin)) | (func << pin), REG_MFP_GPH_L);
+	} else {
+		pin = (pin - 8) * 4;
+		__raw_writel((__raw_readl(REG_MFP_GPH_H) & ~(0xF << pin)) | (func << pin), REG_MFP_GPH_H);
+	}
+	spin_unlock_irqrestore(&mfp_lock, flags);
+}
+EXPORT_SYMBOL(nuc970_mfp_set_port_h);
+
+void nuc970_mfp_set_port_i(u32 pin, u32 func)
+{
+        unsigned long flags;
+	spin_lock_irqsave(&mfp_lock, flags);
+	if(pin < 8) {
+		pin *= 4;
+		__raw_writel((__raw_readl(REG_MFP_GPI_L) & ~(0xF << pin)) | (func << pin), REG_MFP_GPI_L);
+	} else {
+		pin = (pin - 8) * 4;
+		__raw_writel((__raw_readl(REG_MFP_GPI_H) & ~(0xF << pin)) | (func << pin), REG_MFP_GPI_H);
+	}
+	spin_unlock_irqrestore(&mfp_lock, flags);
+}
+EXPORT_SYMBOL(nuc970_mfp_set_port_i);
+
+
Index: linux-4.4.92/arch/arm/mach-nuc970/pm.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/pm.c
@@ -0,0 +1,99 @@
+/* linux/arch/arm/mach-nuc970/pm.c
+ *
+ * Copyright (c) 2016 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/cpumask.h>
+#include <linux/delay.h>
+#include <linux/cpu_pm.h>
+#include <linux/suspend.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-aic.h>
+#include <mach/regs-gcr.h>
+#include <mach/map.h>
+
+#ifdef CONFIG_PM_SLEEP
+#define PM_FROM_SRAM
+
+#ifdef PM_FROM_SRAM
+#include <asm/cacheflush.h>
+
+#define SRAM_BASE	NUC970_VA_SRAM
+#define SRAM_LEN	NUC970_SZ_SRAM
+#define TEMP_SRAM_AREA  (SRAM_BASE+0x7000)
+/*
+ * Pointers used for sizing and copying suspend function data
+ */
+extern int nuc970_sys_suspend(void);
+extern int nuc970_sys_suspend_sz;
+#endif
+
+static int nuc970_suspend_enter(suspend_state_t state)
+{
+
+	#ifdef PM_FROM_SRAM
+	int (*nuc970_suspend_ptr) (void);
+	void *sram_swap_area;
+	#endif
+
+	if(state != PM_SUSPEND_MEM)
+		return -EINVAL;
+
+	__raw_writel(__raw_readl(REG_CLK_PMCON) & ~1, REG_CLK_PMCON);	// clear bit 0 so NUC970 enter pd mode instead of idle in next function call
+	#ifndef PM_FROM_SRAM
+		cpu_do_idle();
+	#else
+	/* Allocate some space for temporary SRAM storage */
+	sram_swap_area = kmalloc(nuc970_sys_suspend_sz, GFP_KERNEL);
+	if (!sram_swap_area) {
+		printk(KERN_ERR"PM Suspend: cannot allocate memory to save portion of SRAM\n");
+		return -ENOMEM;
+	}
+
+	__raw_writel(__raw_readl(REG_WKUPSER), REG_WKUPSSR);	// clear wake source flag
+
+	/* Backup a small area of SRAM used for the suspend code */
+	memcpy(sram_swap_area, (void *) TEMP_SRAM_AREA,nuc970_sys_suspend_sz);
+	/*
+	 * Copy code to suspend system into SRAM.
+	 * The suspend code needs to run from SRAM.
+	 */
+	memcpy(TEMP_SRAM_AREA, (void *) nuc970_sys_suspend,nuc970_sys_suspend_sz);
+	flush_icache_range((unsigned long)TEMP_SRAM_AREA,(unsigned long)(TEMP_SRAM_AREA) + nuc970_sys_suspend_sz);
+	nuc970_suspend_ptr = (void *) TEMP_SRAM_AREA;
+	flush_cache_all();
+	(void) nuc970_suspend_ptr();
+
+	/* Restore original SRAM contents */
+	memcpy((void *) TEMP_SRAM_AREA, sram_swap_area,nuc970_sys_suspend_sz);
+	#endif
+
+
+	return 0;
+}
+
+static const struct platform_suspend_ops nuc970_suspend_ops = {
+	.valid		= suspend_valid_only_mem,
+	.enter		= nuc970_suspend_enter,
+};
+
+
+
+void __init nuc970_init_suspend(void)
+{
+	__raw_writel(__raw_readl(REG_CLK_PMCON) & ~0xFF000000, REG_CLK_PMCON);	// reduce wake up delay time waiting for HXT stable
+	suspend_set_ops(&nuc970_suspend_ops);
+}
+#endif
+
Index: linux-4.4.92/arch/arm/mach-nuc970/pm.h
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/pm.h
@@ -0,0 +1,22 @@
+/* linux/arch/arm/mach-nuc970/pm.c
+ *
+ * Copyright (c) 2016 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _MACH_NUC970_PM_H_
+#define _MACH_NUC970_PM_H_
+
+#ifdef CONFIG_PM_SLEEP
+void nuc970_init_suspend(void);
+#else
+static inline void nuc970_init_suspend(void) {}
+#endif
+
+#endif /* _MACH_NUC970_PM_H_ */
Index: linux-4.4.92/arch/arm/mach-nuc970/suspend.S
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/suspend.S
@@ -0,0 +1,68 @@
+ /* arch/arm/mach-nuc970/suspend.S
+ *
+ * Copyright (c) 2016 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/map.h>
+
+        .text
+        .align  10
+ENTRY(nuc970_sys_suspend)
+
+        @ Enable DDR low frequency
+        mov       r1,#0xF0000000
+        add       r0,r1,#0x00001800             @ r0 = NUC970_VA_SDIC
+        ldr       r0,[r0,#0x0000]
+        orr       r0,r0,#0x00040000
+        add       r1,r1,#0x00001800
+        str       r0,[r1,#0x0000]
+
+        @ Save UPLL setting
+        mov       r1,#0xF8000000
+       	add       r0,r1,#0x00002000             @ r0 = NUC970_VA_GCR
+       	ldr       r5,[r0,#0x0264]
+
+        @ Set UPLL to 60MHz
+        mov       r0,#0xC0000005
+        mov       r1,#0xF8000000
+        add       r1,r1,#0x00002000             @ r1 = NUC970_VA_GCR
+        str       r0,[r1,#0x0264]
+
+        @ Enter CPU Idle mode#1
+        mov     r0, #0
+        mrc     p15, 0, r1, c1, c0, 0           @ Read control register
+        mcr     p15, 0, r0, c7, c10, 4          @ Drain write buffer
+        bic     r2, r1, #1 << 12
+        mrs     r3, cpsr                        @ Disable FIQs while Icache
+        orr     ip, r3, #PSR_F_BIT              @ is disabled
+        msr     cpsr_c, ip
+        mcr     p15, 0, r2, c1, c0, 0           @ Disable I cache
+        mcr     p15, 0, r0, c7, c0, 4           @ Wait for interrupt
+        mcr     p15, 0, r1, c1, c0, 0           @ Restore ICache enable
+        msr     cpsr_c, r3                      @ Restore FIQ state
+
+        @ Restore UPLL setting
+        mov       r1,#0xF8000000
+        add       r1,r1,#0x00002000             @ r1 = NUC970_VA_GCR
+        str       r5,[r1,#0x0264]
+
+        @ Disable DDR low frequency
+        mov       r1,#0xF0000000
+        add       r0,r1,#0x00001800             @ r0 = NUC970_VA_SDIC
+        ldr       r0,[r0,#0x0000]
+        bic       r0,#0x00040000
+        add       r1,r1,#0x00001800
+        str       r0,[r1,#0x0000]
+
+        @ Return nuc970_sys_suspend function 
+        mov    	pc, lr
+ENTRY(nuc970_sys_suspend_sz)
+	.word	. - nuc970_sys_suspend
Index: linux-4.4.92/arch/arm/mach-nuc970/time.c
===================================================================
--- /dev/null
+++ linux-4.4.92/arch/arm/mach-nuc970/time.c
@@ -0,0 +1,326 @@
+/*
+ * linux/arch/arm/mach-nuc970/time.c
+ *
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/leds.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+
+
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/clkdev.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+
+#include <mach/mfp.h>
+#include <mach/map.h>
+#include <mach/regs-timer.h>
+#include <mach/hardware.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-aic.h>
+
+#define RESETINT	0x1f
+#define PERIOD		(0x01 << 27)
+#define ONESHOT		(0x00 << 27)
+#define COUNTEN		(0x01 << 30)
+#define INTEN		(0x01 << 29)
+
+#define TICKS_PER_SEC	100
+#define PRESCALE	0x63 /* Divider = prescale + 1 */
+
+#define	TDR_SHIFT	24
+#define	TDR_MASK	((1 << TDR_SHIFT) - 1)
+
+static unsigned int timer0_load;
+
+enum clock_event_mode {
+  CLOCK_EVT_MODE_UNUSED = 0,
+  CLOCK_EVT_MODE_SHUTDOWN,
+  CLOCK_EVT_MODE_PERIODIC,
+  CLOCK_EVT_MODE_ONESHOT,
+  CLOCK_EVT_MODE_RESUME,
+};
+
+static void nuc970_clockevent_setmode(enum clock_event_mode mode,
+		struct clock_event_device *clk)
+{
+	unsigned int val;
+
+	val = __raw_readl(REG_TMR_TCSR0);
+	val &= ~(0x03 << 27);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		__raw_writel(timer0_load, REG_TMR_TICR0);
+		val |= (PERIOD | COUNTEN | INTEN | PRESCALE);
+		break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		val |= (ONESHOT | COUNTEN | INTEN | PRESCALE);
+		break;
+
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_RESUME:
+		break;
+	}
+
+	__raw_writel(val, REG_TMR_TCSR0);
+}
+
+static int nuc970_clockevent_shutdown(struct clock_event_device *evt)
+{
+  nuc970_clockevent_setmode(CLOCK_EVT_MODE_SHUTDOWN, evt);
+  return 0;
+}
+
+static int nuc970_clockevent_set_oneshot(struct clock_event_device *evt)
+{
+  nuc970_clockevent_setmode(CLOCK_EVT_MODE_ONESHOT, evt);
+  return 0;
+}
+
+static int nuc970_clockevent_set_periodic(struct clock_event_device *evt)
+{
+  nuc970_clockevent_setmode(CLOCK_EVT_MODE_PERIODIC, evt);
+  return 0;
+}
+
+static int nuc970_clockevent_setnextevent(unsigned long evt,
+		struct clock_event_device *clk)
+{
+	unsigned int tcsr, tdelta;
+
+    tcsr = __raw_readl(REG_TMR_TCSR0);
+    tdelta = __raw_readl(REG_TMR_TICR0) - __raw_readl(REG_TMR_TDR0);
+
+	__raw_writel(evt, REG_TMR_TICR0);
+    if(!(tcsr & COUNTEN) && ((tdelta > 2) || (tdelta == 0)))
+        __raw_writel(__raw_readl(REG_TMR_TCSR0) | COUNTEN, REG_TMR_TCSR0);
+
+	return 0;
+}
+#ifdef CONFIG_PM
+static int tmr0_msk;
+static void nuc970_clockevent_suspend(struct clock_event_device *clk)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if(__raw_readl(REG_AIC_IMR) & (1 << 16)) {
+		tmr0_msk = 1;
+		__raw_writel(0x10000, REG_AIC_MDCR);  //timer0
+	} else
+		tmr0_msk = 0;
+
+	local_irq_restore(flags);
+
+	printk("clk event suspend\n");
+}
+
+static void nuc970_clockevent_resume(struct clock_event_device *clk)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if(tmr0_msk == 1)
+		__raw_writel(0x10000, REG_AIC_MECR);  //timer0
+	local_irq_restore(flags);
+
+	printk("clk event resume\n");
+}
+#endif
+
+static struct clock_event_device nuc970_clockevent_device = {
+	.name		= "nuc970-timer0",
+	.shift		= 32,
+	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+//	.set_mode	= nuc970_clockevent_setmode,
+    .set_state_shutdown = nuc970_clockevent_shutdown,
+	.set_state_periodic = nuc970_clockevent_set_periodic,
+	.set_state_oneshot  = nuc970_clockevent_set_oneshot,
+	.set_next_event	    = nuc970_clockevent_setnextevent,
+#ifdef CONFIG_PM
+	.suspend	= nuc970_clockevent_suspend,
+	.resume		= nuc970_clockevent_resume,
+#endif
+	.rating		= 300,
+};
+
+/*IRQ handler for the timer*/
+
+static irqreturn_t nuc970_timer0_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &nuc970_clockevent_device;
+
+	__raw_writel(0x01, REG_TMR_TISR); /* clear TIF0 */
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction nuc970_timer0_irq = {
+	.name		= "nuc970-timer0",
+	.flags		= /*IRQF_DISABLED | */IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= nuc970_timer0_interrupt,
+};
+
+static void __init nuc970_clockevents_init(void)
+{
+	unsigned int rate;
+	struct clk *clk = clk_get(NULL, "timer0");
+
+	BUG_ON(IS_ERR(clk));
+
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	__raw_writel(0x00, REG_TMR_TCSR0);
+
+	rate = clk_get_rate(clk) / (PRESCALE + 1);
+
+	timer0_load = (rate / TICKS_PER_SEC) - 1;
+
+	__raw_writel(RESETINT, REG_TMR_TISR);
+	setup_irq(IRQ_TMR0, &nuc970_timer0_irq);
+
+	nuc970_clockevent_device.mult = div_sc(rate, NSEC_PER_SEC,
+					nuc970_clockevent_device.shift);
+	nuc970_clockevent_device.max_delta_ns = clockevent_delta2ns(0xffffffff,
+					&nuc970_clockevent_device);
+	nuc970_clockevent_device.min_delta_ns = clockevent_delta2ns(0xf,
+					&nuc970_clockevent_device);
+	nuc970_clockevent_device.cpumask = cpumask_of(0);
+
+	clockevents_register_device(&nuc970_clockevent_device);
+}
+
+static cycle_t nuc970_get_cycles(struct clocksource *cs)
+{
+	return (__raw_readl(REG_TMR_TDR1)) & TDR_MASK;
+}
+#ifdef CONFIG_PM
+static int tmr1_msk;
+static void nuc970_clocksource_suspend(struct clocksource *cs)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if(__raw_readl(REG_AIC_IMR) & (1 << 17)) {
+		tmr1_msk = 1;
+		__raw_writel(0x20000, REG_AIC_MDCR);  //timer1
+	} else
+		tmr1_msk = 0;
+
+	local_irq_restore(flags);
+
+	printk("clk source suspend\n");
+}
+
+static void nuc970_clocksource_resume(struct clocksource *cs)
+{
+	unsigned long flags;
+
+
+	local_irq_save(flags);
+	if(tmr1_msk == 1)
+		__raw_writel(0x20000, REG_AIC_MECR);  //timer1
+	local_irq_restore(flags);
+
+	printk("clk source resume\n");
+}
+#endif
+static struct clocksource clocksource_nuc970 = {
+	.name	= "nuc970-timer1",
+	.rating	= 200,
+	.read	= nuc970_get_cycles,
+	.mask	= CLOCKSOURCE_MASK(TDR_SHIFT),
+	.shift	= 10,
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+#ifdef CONFIG_PM
+	.suspend	= nuc970_clocksource_suspend,
+	.resume		= nuc970_clocksource_resume,
+#endif
+};
+
+static void __init nuc970_clocksource_init(void)
+{
+	unsigned int val;
+	unsigned int rate = 0;
+	struct clk *clk = clk_get(NULL, "timer1");
+
+	BUG_ON(IS_ERR(clk));
+
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	__raw_writel(0x00, REG_TMR_TCSR1);
+
+
+	rate = clk_get_rate(clk) / (PRESCALE + 1);
+
+	__raw_writel(0xffffffff, REG_TMR_TICR1);
+
+	val = __raw_readl(REG_TMR_TCSR1);
+	val |= (COUNTEN | PERIOD | PRESCALE);
+	__raw_writel(val, REG_TMR_TCSR1);
+
+	clocksource_nuc970.mult =
+		clocksource_khz2mult((rate / 1000), clocksource_nuc970.shift);
+//	clocksource_register(&clocksource_nuc970);
+	__clocksource_register(&clocksource_nuc970);
+}
+
+void __init nuc970_setup_default_serial_console(void)
+{
+	struct clk *clk = clk_get(NULL, "uart0");
+
+	BUG_ON(IS_ERR(clk));
+
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	/* GPE0, GPE1 */
+	nuc970_mfp_set_port_e(0, 0x9);
+	nuc970_mfp_set_port_e(1, 0x9);
+}
+
+extern int nuc970_init_clocks(void);
+void __init nuc970_timer_init(void)
+{
+	nuc970_init_clocks();
+	nuc970_clocksource_init();
+	nuc970_clockevents_init();
+	nuc970_setup_default_serial_console();
+}
Index: linux-4.4.92/drivers/gpio/Kconfig
===================================================================
--- linux-4.4.92.orig/drivers/gpio/Kconfig
+++ linux-4.4.92/drivers/gpio/Kconfig
@@ -97,6 +97,19 @@ config GPIO_MAX730X
 
 menu "Memory mapped GPIO drivers"
 
+config GPIO_NUC970
+	tristate "NUC970 GPIO support"
+	depends on GPIOLIB
+	select NEED_MACH_GPIO_H
+	help
+	  Say yes here to support GPIO functionality of NUC970 chip
+config GPIO_NUC970_EINT_WKUP
+	tristate "NUC970 external I/O wake-up support"
+	depends on GPIO_NUC970
+	default no
+	help
+	  Say yes here to support GPIO wakeup functionality of NUC970 chip
+
 config GPIO_74XX_MMIO
 	tristate "GPIO driver for 74xx-ICs with MMIO access"
 	depends on OF_GPIO
Index: linux-4.4.92/drivers/gpio/Makefile
===================================================================
--- linux-4.4.92.orig/drivers/gpio/Makefile
+++ linux-4.4.92/drivers/gpio/Makefile
@@ -119,3 +119,4 @@ obj-$(CONFIG_GPIO_XTENSA)	+= gpio-xtensa
 obj-$(CONFIG_GPIO_ZEVIO)	+= gpio-zevio.o
 obj-$(CONFIG_GPIO_ZYNQ)		+= gpio-zynq.o
 obj-$(CONFIG_GPIO_ZX)		+= gpio-zx.o
+obj-$(CONFIG_GPIO_NUC970)       += gpio-nuc970.o
Index: linux-4.4.92/drivers/gpio/gpio-nuc970.c
===================================================================
--- /dev/null
+++ linux-4.4.92/drivers/gpio/gpio-nuc970.c
@@ -0,0 +1,1104 @@
+/*
+ *  linux/drivers/drivers/gpio/nuc970-gpio.c - Nuvoton NUC970 GPIO Drive
+ *
+ *  Copyright (c) 2010 CompuLab Ltd
+ *  Author: shanchun
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, 	write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  /gpio-tc3589x.c/
+ */
+
+
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <linux/acpi.h>
+#include <linux/platform_device.h>
+#include <mach/gpio.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+#include <mach/map.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gcr.h>
+
+#include <mach/irqs.h>
+
+#include <mach/gpio.h>
+#include <linux/gpio.h>
+
+#include <linux/platform_data/keypad-nuc970.h>
+
+//#define GPIO_DEBUG_ENABLE_ENTER_LEAVE
+#ifdef GPIO_DEBUG_ENABLE_ENTER_LEAVE
+#define ENTRY()					printk("[%-20s] : Enter...\n", __FUNCTION__)
+#define LEAVE()					printk("[%-20s] : Leave...\n", __FUNCTION__)
+#else
+#define ENTRY()
+#define LEAVE()
+#endif
+
+
+static DEFINE_SPINLOCK(gpio_lock);
+
+static unsigned short gpio_ba;
+
+struct gpio_port {
+	volatile unsigned int * dir;
+	volatile unsigned int * out;
+	volatile unsigned int * in;
+};
+
+static const struct gpio_port port_class[] = {
+	{(volatile unsigned int *)REG_GPIOA_DIR, (volatile unsigned int *)REG_GPIOA_DATAOUT,
+	 (volatile unsigned int *)REG_GPIOA_DATAIN},
+	{(volatile unsigned int *)REG_GPIOB_DIR, (volatile unsigned int *)REG_GPIOB_DATAOUT,
+	 (volatile unsigned int *)REG_GPIOB_DATAIN},
+	{(volatile unsigned int *)REG_GPIOC_DIR, (volatile unsigned int *)REG_GPIOC_DATAOUT,
+	 (volatile unsigned int *)REG_GPIOC_DATAIN},
+	{(volatile unsigned int *)REG_GPIOD_DIR, (volatile unsigned int *)REG_GPIOD_DATAOUT,
+	 (volatile unsigned int *)REG_GPIOD_DATAIN},
+	{(volatile unsigned int *)REG_GPIOE_DIR, (volatile unsigned int *)REG_GPIOE_DATAOUT,
+	 (volatile unsigned int *)REG_GPIOE_DATAIN},
+	{(volatile unsigned int *)REG_GPIOF_DIR, (volatile unsigned int *)REG_GPIOF_DATAOUT,
+	 (volatile unsigned int *)REG_GPIOF_DATAIN},
+	{(volatile unsigned int *)REG_GPIOG_DIR, (volatile unsigned int *)REG_GPIOG_DATAOUT,
+	 (volatile unsigned int *)REG_GPIOG_DATAIN},
+	{(volatile unsigned int *)REG_GPIOH_DIR, (volatile unsigned int *)REG_GPIOH_DATAOUT,
+	 (volatile unsigned int *)REG_GPIOH_DATAIN},
+	{(volatile unsigned int *)REG_GPIOI_DIR, (volatile unsigned int *)REG_GPIOI_DATAOUT,
+	 (volatile unsigned int *)REG_GPIOI_DATAIN},
+	{(volatile unsigned int *)REG_GPIOJ_DIR, (volatile unsigned int *)REG_GPIOJ_DATAOUT,
+         (volatile unsigned int *)REG_GPIOJ_DATAIN},
+	{},
+};
+
+static const struct gpio_port *nuc970_gpio_cla_port(unsigned gpio_num,
+						    unsigned *num)
+{
+	int group;
+	group = gpio_num / GPIO_OFFSET;
+	*num = gpio_num % GPIO_OFFSET;
+	return &port_class[group];
+}
+
+static int nuc970_gpio_core_direction_in(struct gpio_chip *gc,
+					 unsigned gpio_num)
+{
+	int port_num;
+	unsigned long value;
+	const struct gpio_port *port =
+	    nuc970_gpio_cla_port(gpio_num, &port_num);
+
+	spin_lock(&gpio_lock);
+	value = __raw_readl(port->dir);
+	value &= ~(1 << port_num);
+	__raw_writel(value, port->dir);
+	spin_unlock(&gpio_lock);
+
+	return 0;
+}
+
+static int nuc970_gpio_core_get(struct gpio_chip *gc, unsigned gpio_num)
+{
+	int port_num, value;
+	const struct gpio_port *port;
+	port = nuc970_gpio_cla_port(gpio_num, &port_num);
+	value = 0;
+
+	if ((__raw_readl(port->dir) & (1 << port_num))) {	//GPIO OUT
+		value = (__raw_readl(port->out) >> port_num) & 0x1;
+
+	} else {		//GPIO IN
+		value = (__raw_readl(port->in) >> port_num) & 0x1;
+		__raw_writel(value, port->in);
+	}
+	return value;
+}
+
+static void nuc970_gpio_core_set(struct gpio_chip *gc, unsigned gpio_num,
+				 int val)
+{
+	int port_num, value;
+	const struct gpio_port *port =
+	    nuc970_gpio_cla_port(gpio_num, &port_num);
+	spin_lock(&gpio_lock);
+
+	if ((__raw_readl(port->dir) & (1 << port_num))) {	//GPIO OUT
+		value = __raw_readl(port->out);
+		if (val)
+			value |= (1 << port_num);
+		else
+			value &= ~(1 << port_num);
+		__raw_writel(value, port->out);
+
+	} else {		//GPIO IN
+		value = __raw_readl(port->in);
+		if (val)
+			value |= (1 << port_num);
+		else
+			value &= ~(1 << port_num);
+		__raw_writel(value, port->in);;
+	}
+
+	spin_unlock(&gpio_lock);
+}
+
+static int nuc970_gpio_core_direction_out(struct gpio_chip *gc,
+					  unsigned gpio_num, int val)
+{
+	int port_num;
+	unsigned long value;
+	const struct gpio_port *port =
+	    nuc970_gpio_cla_port(gpio_num, &port_num);
+
+	spin_lock(&gpio_lock);
+	value = __raw_readl(port->dir);
+	value |= (1 << port_num);
+	__raw_writel(value, port->dir);
+	spin_unlock(&gpio_lock);
+	nuc970_gpio_core_set(gc, gpio_num, val);
+
+	return 0;
+}
+
+static int nuc970_gpio_core_to_request(struct gpio_chip *chip, unsigned offset)
+{
+	unsigned int group,num1,num,reg,value;
+	group = offset / GPIO_OFFSET;
+	num1  = num = offset % GPIO_OFFSET;
+	reg   = (unsigned int)REG_MFP_GPA_L+(group* 0x08);
+	if(num>7)
+	{
+		num -= 8;
+		reg = reg + 0x04 ;
+	}
+
+	value =	( __raw_readl((volatile unsigned int *)reg) & (0xf<<(num*4)))>>(num*4);
+	if(value>0 && value<0xf)
+	{
+			printk(KERN_ERR "Please Check GPIO%c%02d's multi-function = 0x%x \n",(char)(65+group),num1,value);
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static void nuc970_gpio_core_to_free(struct gpio_chip *chip, unsigned offset)
+{
+}
+
+static int nuc970_gpio_core_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	unsigned int irqno= IRQ_GPIO_START+offset;
+	switch(offset)
+	{
+		case NUC970_PH0:
+			if((__raw_readl(REG_MFP_GPH_L) & (0xf<<0))==(0xf<<0))
+				irqno = IRQ_EXT0_H0;
+		break;
+
+		case NUC970_PH1:
+			if((__raw_readl(REG_MFP_GPH_L) & (0xf<<4))==(0xf<<4))
+				irqno = IRQ_EXT1_H1;
+		break;
+		case NUC970_PH2:
+			if((__raw_readl(REG_MFP_GPH_L) & (0xf<<8))==(0xf<<8))
+				irqno = IRQ_EXT2_H2;
+		break;
+		case NUC970_PH3:
+			if((__raw_readl(REG_MFP_GPH_L) & (0xf<<12))==(0xf<<12))
+				irqno = IRQ_EXT3_H3;
+		break;
+		case NUC970_PH4:
+			if((__raw_readl(REG_MFP_GPH_L) & (0xf<<16))==(0xf<<16))
+				irqno = IRQ_EXT4_H4;
+		break;
+		case NUC970_PH5:
+			if((__raw_readl(REG_MFP_GPH_L) & (0xf<<20))==(0xf<<20))
+				irqno = IRQ_EXT5_H5;
+		break;
+		case NUC970_PH6:
+			if((__raw_readl(REG_MFP_GPH_L) & (0xf<<24))==(0xf<<24))
+				irqno = IRQ_EXT6_H6;
+		break;
+		case NUC970_PH7:
+			if((__raw_readl(REG_MFP_GPH_L) & (0xf<<28))==(0xf<<28))
+				irqno = IRQ_EXT7_H7;
+		break;
+
+		case NUC970_PF11:
+			if((__raw_readl(REG_MFP_GPF_H) & (0xf<<12))==(0xf<<12))
+				irqno = IRQ_EXT0_F11;
+		break;
+		case NUC970_PF12:
+			if((__raw_readl(REG_MFP_GPF_H) & (0xf<<16))==(0xf<<16))
+				irqno = IRQ_EXT1_F12;
+		break;
+		case NUC970_PF13:
+			if((__raw_readl(REG_MFP_GPF_H) & (0xf<<20))==(0xf<<20))
+				irqno = IRQ_EXT2_F13;
+		break;
+		case NUC970_PF14:
+			if((__raw_readl(REG_MFP_GPF_H) & (0xf<<24))==(0xf<<24))
+				irqno = IRQ_EXT3_F14;
+		break;
+		case NUC970_PF15:
+			if((__raw_readl(REG_MFP_GPF_H) & (0xf<<28))==(0xf<<28))
+				irqno = IRQ_EXT4_F15;
+		break;
+		case NUC970_PG15:
+			if((__raw_readl(REG_MFP_GPG_H) & (0xf<<28))==(0xf<<28))
+				irqno = IRQ_EXT5_G15;
+		break;
+		case NUC970_PI1:
+			if((__raw_readl(REG_MFP_GPI_L) & (0xf<<4))==(0xf<<4))
+				irqno = IRQ_EXT6_I1;
+		break;
+		case NUC970_PI2:
+			if((__raw_readl(REG_MFP_GPI_L) & (0xf<<8))==(0xf<<8))
+				irqno = IRQ_EXT7_I2;
+		break;
+		default:
+			irqno = IRQ_GPIO_START+offset;
+		break;
+	}
+	return irqno;
+}
+
+static struct gpio_chip nuc970_gpio_port = {
+	.label = "nuc970_gpio_port",
+	.owner = THIS_MODULE,
+	.direction_input = nuc970_gpio_core_direction_in,
+	.get = nuc970_gpio_core_get,
+	.direction_output = nuc970_gpio_core_direction_out,
+	.set = nuc970_gpio_core_set,
+	.request = nuc970_gpio_core_to_request,
+	.free = nuc970_gpio_core_to_free,
+	.to_irq = nuc970_gpio_core_to_irq,
+	.base = 0,
+	.ngpio = NUMGPIO,
+};
+
+
+#ifndef CONFIG_OF
+/*
+ * @brief       External Interrupt 0 Handler
+ * @details     This function will be used by EINT0,
+ *              when enable IRQ_EXT0_H0 or IRQ_EXT0_F11 in eint0
+ */
+/*
+static irqreturn_t nuc970_eint0_interrupt(int irq, void *dev_id){
+	printk("@0\n");
+	return IRQ_HANDLED;
+}
+*/
+
+/* If enable IRQ_EXT0_H0 or IRQ_EXT0_F11 , linux will enable EINT0
+ * User can modify trigger tiypes as below :
+ * IRQF_TRIGGER_FALLING / IRQF_TRIGGER_RISING / IRQF_TRIGGER_HIGH / IRQF_TRIGGER_LOW
+ */
+struct nuc970_eint_pins eint0[]={
+//{IRQ_EXT0_H0, nuc970_eint0_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint0"},
+//{IRQ_EXT0_F11,nuc970_eint0_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint0"},
+{0,0,0,0}
+};
+
+/*
+ * @brief       External Interrupt 0 Handler
+ * @details     This function will be used by EINT1,
+ *              when enable IRQ_EXT1_H1 or IRQ_EXT1_F12 in eint1
+ */
+/*
+static irqreturn_t nuc970_eint1_interrupt(int irq, void *dev_id){
+	printk("@1\n");
+	return IRQ_HANDLED;
+}
+*/
+
+/* If enable IRQ_EXT1_H1 or IRQ_EXT1_F12 , linux will enable EINT1
+ * User can modify trigger tiypes as below :
+ * IRQF_TRIGGER_FALLING / IRQF_TRIGGER_RISING / IRQF_TRIGGER_HIGH / IRQF_TRIGGER_LOW
+ */
+struct nuc970_eint_pins eint1[]={
+//{IRQ_EXT1_H1, nuc970_eint1_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint1"},
+//{IRQ_EXT1_F12,nuc970_eint1_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint1"},
+{0,0,0,0}
+};
+
+/*
+ * @brief       External Interrupt 2 Handler
+ * @details     This function will be used by EINT2,
+ *              when enable IRQ_EXT2_H2 or IRQ_EXT2_F13 in eint2
+ */
+/*
+static irqreturn_t nuc970_eint2_interrupt(int irq, void *dev_id){
+	printk("@2\n");
+	return IRQ_HANDLED;
+}
+*/
+
+/* If enable IRQ_EXT2_H2 or IRQ_EXT2_F13 , linux will enable EINT2
+ * User can modify trigger tiypes as below :
+ * IRQF_TRIGGER_FALLING / IRQF_TRIGGER_RISING / IRQF_TRIGGER_HIGH / IRQF_TRIGGER_LOW
+ */
+struct nuc970_eint_pins eint2[]={
+//{IRQ_EXT2_H2, nuc970_eint2_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint2"},
+//{IRQ_EXT2_F13,nuc970_eint2_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint2"},
+{0,0,0,0}
+};
+
+/*
+ * @brief       External Interrupt 3 Handler
+ * @details     This function will be used by EINT3,
+ *              when enable IRQ_EXT3_H3 or IRQ_EXT3_F14 in eint3
+ */
+/*
+static irqreturn_t nuc970_eint3_interrupt(int irq, void *dev_id){
+	printk("@3\n");
+	return IRQ_HANDLED;
+}
+*/
+
+/* If enable IRQ_EXT3_H3 or IRQ_EXT3_F14 , linux will enable EINT31
+ * User can modify trigger tiypes as below :
+ * IRQF_TRIGGER_FALLING / IRQF_TRIGGER_RISING / IRQF_TRIGGER_HIGH / IRQF_TRIGGER_LOW
+ */
+struct nuc970_eint_pins eint3[]={
+//{IRQ_EXT3_H3, nuc970_eint3_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint3"},
+//{IRQ_EXT3_F14,nuc970_eint3_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint3"},
+{0,0,0,0}
+};
+
+/*
+ * @brief       External Interrupt 3 Handler
+ * @details     This function will be used by EINT3,
+ *              when enable IRQ_EXT4_H4 or IRQ_EXT4_F15 in eint4
+ */
+/*
+static irqreturn_t nuc970_eint4_interrupt(int irq, void *dev_id){
+	printk("@4\n");
+	return IRQ_HANDLED;
+}
+*/
+
+/* If enable IRQ_EXT4_H4 or IRQ_EXT4_F15 , linux will enable EINT4
+ * User can modify trigger tiypes as below :
+ * IRQF_TRIGGER_FALLING / IRQF_TRIGGER_RISING / IRQF_TRIGGER_HIGH / IRQF_TRIGGER_LOW
+ */
+struct nuc970_eint_pins eint4[]={
+//{IRQ_EXT4_H4, nuc970_eint4_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint4"},
+//{IRQ_EXT4_F15,nuc970_eint4_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint4"},
+{0,0,0,0}
+};
+
+/*
+ * @brief       External Interrupt 4 Handler
+ * @details     This function will be used by EINT4,
+ *              when enable IRQ_EXT5_H5 or IRQ_EXT5_G15 in eint5
+ */
+/*
+static irqreturn_t nuc970_eint5_interrupt(int irq, void *dev_id){
+	printk("@5\n");
+	return IRQ_HANDLED;
+}
+*/
+
+/* If enable IRQ_EXT5_H5 or IRQ_EXT5_G15 , linux will enable EINT5
+ * User can modify trigger tiypes as below :
+ * IRQF_TRIGGER_FALLING / IRQF_TRIGGER_RISING / IRQF_TRIGGER_HIGH / IRQF_TRIGGER_LOW
+ */
+struct nuc970_eint_pins eint5[]={
+//{IRQ_EXT5_H5, nuc970_eint5_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint5"},
+//{IRQ_EXT5_G15,nuc970_eint5_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint5"},
+{0,0,0,0}
+};
+
+/*
+ * @brief       External Interrupt 6 Handler
+ * @details     This function will be used by EINT5,
+ *              when enable IRQ_EXT6_H6 or IRQ_EXT6_I1 in eint6
+ */
+/*
+static irqreturn_t nuc970_eint6_interrupt(int irq, void *dev_id){
+	printk("@6\n");
+	return IRQ_HANDLED;
+}
+
+*/
+/* If enable IRQ_EXT6_H6 or IRQ_EXT6_I1 , linux will enable EINT6
+ * User can modify trigger tiypes as below :
+ * IRQF_TRIGGER_FALLING / IRQF_TRIGGER_RISING / IRQF_TRIGGER_HIGH / IRQF_TRIGGER_LOW
+ */
+struct nuc970_eint_pins eint6[]={
+//{IRQ_EXT6_H6,nuc970_eint6_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint6"},
+//{IRQ_EXT6_I1,nuc970_eint6_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint6"},
+{0,0,0,0}
+};
+
+/*
+ * @brief       External Interrupt 7 Handler
+ * @details     This function will be used by EINT1,
+ *              when enable IRQ_EXT7_H7 or IRQ_EXT7_I2 in eint7
+ */
+/*
+static irqreturn_t nuc970_eint7_interrupt(int irq, void *dev_id){
+	printk("@7\n");
+	return IRQ_HANDLED;
+}
+
+*/
+/* If enable IRQ_EXT7_H7 or IRQ_EXT7_I2 , linux will enable EINT7
+ * User can modify trigger tiypes as below :
+ * IRQF_TRIGGER_FALLING / IRQF_TRIGGER_RISING / IRQF_TRIGGER_HIGH / IRQF_TRIGGER_LOW
+ */
+struct nuc970_eint_pins eint7[]={
+//{IRQ_EXT7_H7,nuc970_eint7_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint7"},
+//{IRQ_EXT7_I2,nuc970_eint7_interrupt,IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,"eint7"},
+{0,0,0,0}
+};
+
+static int nuc970_enable_eint(uint32_t flag,struct platform_device *pdev){
+	int err;
+	struct nuc970_eint_pins *peint;
+	struct pinctrl *p = NULL;
+	switch(pdev->id)
+	{
+		case 1:
+			peint=eint0;
+			while(peint->pin!=(u32)0){
+				if ((err = request_irq(peint->pin,peint->handler, peint->trigger|IRQF_NO_SUSPEND, peint->name, 0)) != 0) {
+					printk("register %s irq failed %d\n",peint->name ,err);
+				}
+				if(flag==1){
+					__raw_writel((1<<0) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(peint->pin);
+				}
+				switch(peint->pin){
+					case IRQ_EXT0_H0:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint0-PH");
+					break;
+					case IRQ_EXT0_F11:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint0-PF");
+					break;
+				}
+				if (IS_ERR(p))
+				{
+					dev_err(&pdev->dev, "unable to reserve pin\n");
+					return PTR_ERR(p);
+				}
+				peint++;
+		}
+		break;
+		case 2:
+			peint=eint1;
+			while(peint->pin!=(u32)0){
+				if ((err = request_irq(peint->pin,peint->handler, peint->trigger|IRQF_NO_SUSPEND, peint->name, 0)) != 0) {
+					printk("register %s irq failed %d\n",peint->name ,err);
+				}
+				if(flag==1){
+					__raw_writel((1<<1) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(peint->pin);
+				}
+				switch(peint->pin){
+					case IRQ_EXT1_H1:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint1-PH");
+					break;
+					case IRQ_EXT1_F12:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint1-PF");
+					break;
+				}
+				if (IS_ERR(p))
+				{
+					dev_err(&pdev->dev, "unable to reserve pin\n");
+					return PTR_ERR(p);
+				}
+				peint++;
+		}
+		break;
+		case 3:
+			peint=eint2;
+			while(peint->pin!=(u32)0){
+				if ((err = request_irq(peint->pin,peint->handler, peint->trigger|IRQF_NO_SUSPEND, peint->name, 0)) != 0) {
+					printk("register %s irq failed %d\n",peint->name ,err);
+				}
+				if(flag==1){
+					__raw_writel((1<<2) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(peint->pin);
+				}
+				switch(peint->pin){
+					case IRQ_EXT2_H2:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint2-PH");
+					break;
+					case IRQ_EXT2_F13:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint2-PF");
+					break;
+				}
+				if (IS_ERR(p))
+				{
+					dev_err(&pdev->dev, "unable to reserve pin\n");
+					return PTR_ERR(p);
+				}
+				peint++;
+		}
+		break;
+		case 4:
+			peint=eint3;
+			while(peint->pin!=(u32)0){
+				if ((err = request_irq(peint->pin,peint->handler, peint->trigger|IRQF_NO_SUSPEND, peint->name, 0)) != 0) {
+					printk("register %s irq failed %d\n",peint->name ,err);
+				}
+				if(flag==1){
+					__raw_writel((1<<3) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(peint->pin);
+				}
+				switch(peint->pin){
+					case IRQ_EXT3_H3:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint3-PH");
+					break;
+					case IRQ_EXT3_F14:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint3-PF");
+					break;
+				}
+				if (IS_ERR(p))
+				{
+					dev_err(&pdev->dev, "unable to reserve pin\n");
+					return PTR_ERR(p);
+				}
+				peint++;
+		}
+		break;
+		case 5:
+			peint=eint4;
+			while(peint->pin!=(u32)0){
+				if ((err = request_irq(peint->pin,peint->handler, peint->trigger|IRQF_NO_SUSPEND, peint->name, 0)) != 0) {
+					printk("register %s irq failed %d\n",peint->name ,err);
+				}
+				if(flag==1){
+					__raw_writel((1<<4) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(peint->pin);
+				}
+				switch(peint->pin){
+					case IRQ_EXT4_H4:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint4-PH");
+					break;
+					case IRQ_EXT4_F15:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint4-PF");
+					break;
+				}
+				if (IS_ERR(p))
+				{
+					dev_err(&pdev->dev, "unable to reserve pin\n");
+					return PTR_ERR(p);
+				}
+				peint++;
+		}
+		break;
+		case 6:
+			peint=eint5;
+			while(peint->pin!=(u32)0){
+				if ((err = request_irq(peint->pin,peint->handler, peint->trigger|IRQF_NO_SUSPEND, peint->name, 0)) != 0) {
+					printk("register %s irq failed %d\n",peint->name ,err);
+				}
+				if(flag==1){
+					__raw_writel((1<<5) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(peint->pin);
+				}
+				switch(peint->pin){
+					case IRQ_EXT5_H5:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint5-PH");
+					break;
+					case IRQ_EXT5_G15:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint5-PG");
+					break;
+				}
+				if (IS_ERR(p))
+				{
+					dev_err(&pdev->dev, "unable to reserve pin\n");
+					return PTR_ERR(p);
+				}
+				peint++;
+		}
+		break;
+		case 7:
+			peint=eint6;
+			while(peint->pin!=(u32)0){
+				if ((err = request_irq(peint->pin,peint->handler, peint->trigger|IRQF_NO_SUSPEND, peint->name, 0)) != 0) {
+					printk("register %s irq failed %d\n",peint->name ,err);
+				}
+				if(flag==1){
+					__raw_writel((1<<6) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(peint->pin);
+				}
+				switch(peint->pin){
+					case IRQ_EXT6_H6:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint6-PH");
+					break;
+					case IRQ_EXT6_I1:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint6-PI");
+					break;
+				}
+				if (IS_ERR(p))
+				{
+					dev_err(&pdev->dev, "unable to reserve pin\n");
+					return PTR_ERR(p);
+				}
+				peint++;
+		}
+		break;
+		case 8:
+			peint=eint7;
+			while(peint->pin!=(u32)0){
+				if ((err = request_irq(peint->pin,peint->handler, peint->trigger|IRQF_NO_SUSPEND, peint->name, 0)) != 0) {
+					printk("register %s irq failed %d\n",peint->name ,err);
+				}
+				if(flag==1){
+					__raw_writel((1<<7) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(IRQ_EXT7_H7);
+				}
+				switch(peint->pin){
+					case IRQ_EXT7_H7:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint7-PH");
+					break;
+					case IRQ_EXT7_I2:
+						p = devm_pinctrl_get_select(&pdev->dev, "eint7-PI");
+					break;
+				}
+				if (IS_ERR(p))
+				{
+					dev_err(&pdev->dev, "unable to reserve pin\n");
+					return PTR_ERR(p);
+				}
+				peint++;
+		}
+		break;
+	}
+	return 0;
+}
+#else
+
+static irqreturn_t nuc970_eint0_interrupt(int irq, void *dev_id){
+	printk("@0\n");
+	return IRQ_HANDLED;
+}
+__attribute__ ((unused)) static irqreturn_t nuc970_eint1_interrupt(int irq, void *dev_id){
+	printk("@1\n");
+	return IRQ_HANDLED;
+}
+__attribute__ ((unused)) static irqreturn_t nuc970_eint2_interrupt(int irq, void *dev_id){
+	printk("@2\n");
+	return IRQ_HANDLED;
+}
+__attribute__ ((unused)) static irqreturn_t nuc970_eint3_interrupt(int irq, void *dev_id){
+	printk("@3\n");
+	return IRQ_HANDLED;
+}
+__attribute__ ((unused)) static irqreturn_t nuc970_eint4_interrupt(int irq, void *dev_id){
+	printk("@4\n");
+	return IRQ_HANDLED;
+}
+__attribute__ ((unused)) static irqreturn_t nuc970_eint5_interrupt(int irq, void *dev_id){
+	printk("@5\n");
+	return IRQ_HANDLED;
+}
+__attribute__ ((unused)) static irqreturn_t nuc970_eint6_interrupt(int irq, void *dev_id){
+	printk("@6\n");
+	return IRQ_HANDLED;
+}
+__attribute__ ((unused)) static irqreturn_t nuc970_eint7_interrupt(int irq, void *dev_id){
+	printk("@7\n");
+	return IRQ_HANDLED;
+}
+
+u32 trigger_type[5]={	(IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),
+												IRQF_TRIGGER_RISING,
+												IRQF_TRIGGER_FALLING,
+												IRQF_TRIGGER_HIGH,
+												IRQF_TRIGGER_LOW};
+
+static int nuc970_enable_eint(uint32_t flag,struct platform_device *pdev){
+	int err;
+	u32	val32[3];
+	u32 irqnum,irqflag;
+	
+	//eint 0 
+	if (of_property_read_u32_array(pdev->dev.of_node, "eint0-config", val32, 3) != 0){
+		printk("%s - eint0 can not get port-number!\n", __func__);
+		return -EINVAL;
+	}
+	if(val32[0]==1)
+	{
+		irqnum=(val32[1]==0)?(IRQ_EXT0_H0):(IRQ_EXT0_F11);
+		irqflag=trigger_type[val32[2]]|IRQF_NO_SUSPEND;
+		if(flag==1){
+					__raw_writel((1<<0) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(irqnum);
+		}
+		if ((err = request_irq(irqnum,nuc970_eint0_interrupt,irqflag, "eint0", 0)) != 0) {
+			printk("%s - eint0 can not get irq!\n", __func__);
+			return -EINVAL;
+		}
+	}
+	
+	//eint 1 
+	if (of_property_read_u32_array(pdev->dev.of_node, "eint1-config", val32, 3) != 0){
+		printk("%s - eint1 can not get port-number!\n", __func__);
+		return -EINVAL;
+	}
+	if(val32[0]==1)
+	{
+		irqnum=(val32[1]==0)?(IRQ_EXT1_H1):(IRQ_EXT1_F12);
+		irqflag=trigger_type[val32[2]]|IRQF_NO_SUSPEND;
+		if(flag==1){
+					__raw_writel((1<<1) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(irqnum);
+		}
+		if ((err = request_irq(irqnum,nuc970_eint1_interrupt,irqflag, "eint1", 0)) != 0) {
+			printk("%s - eint1 can not get irq!\n", __func__);
+			return -EINVAL;
+		}
+	}
+	
+	//eint 2 
+	if (of_property_read_u32_array(pdev->dev.of_node, "eint2-config", val32, 3) != 0){
+		printk("%s - eint2 can not get port-number!\n", __func__);
+		return -EINVAL;
+	}
+	if(val32[0]==1)
+	{
+		irqnum=(val32[1]==0)?(IRQ_EXT2_H2):(IRQ_EXT2_F13);
+		irqflag=trigger_type[val32[2]]|IRQF_NO_SUSPEND;
+		if(flag==1){
+					__raw_writel((1<<2) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(irqnum);
+		}
+		if ((err = request_irq(irqnum,nuc970_eint2_interrupt,irqflag, "eint2", 0)) != 0) {
+			printk("%s - eint2 can not get irq!\n", __func__);
+			return -EINVAL;
+		}
+	}
+	
+	//eint 3 
+	if (of_property_read_u32_array(pdev->dev.of_node, "eint3-config", val32, 3) != 0){
+		printk("%s - eint3 can not get port-number!\n", __func__);
+		return -EINVAL;
+	}
+	if(val32[0]==1)
+	{
+		irqnum=(val32[1]==0)?(IRQ_EXT3_H3):(IRQ_EXT3_F14);
+		irqflag=trigger_type[val32[2]]|IRQF_NO_SUSPEND;
+		if(flag==3){
+					__raw_writel((1<<30) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(irqnum);
+		}
+		if ((err = request_irq(irqnum,nuc970_eint3_interrupt,irqflag, "eint3", 0)) != 0) {
+			printk("%s - eint3 can not get irq!\n", __func__);
+			return -EINVAL;
+		}
+	}
+	
+	//eint 4 
+	if (of_property_read_u32_array(pdev->dev.of_node, "eint4-config", val32, 3) != 0){
+		printk("%s - eint4 can not get port-number!\n", __func__);
+		return -EINVAL;
+	}
+	if(val32[0]==1)
+	{	 	
+		irqnum=(val32[1]==0)?(IRQ_EXT4_H4):(IRQ_EXT4_F15);
+		irqflag=trigger_type[val32[2]]|IRQF_NO_SUSPEND;
+		if(flag==1){
+					__raw_writel((1<<4) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(irqnum);
+		}
+		if(flag==1){
+					__raw_writel((1<<4) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(irqnum);
+		}
+		if ((err = request_irq(irqnum,nuc970_eint4_interrupt,irqflag, "eint4", 0)) != 0) {
+			printk("%s - eint4 can not get irq!\n", __func__);
+			return -EINVAL;
+		}
+	}
+	
+	//eint 5 
+	if (of_property_read_u32_array(pdev->dev.of_node, "eint5-config", val32, 3) != 0){
+		printk("%s - eint5 can not get port-number!\n", __func__);
+		return -EINVAL;
+	} 	
+	if(val32[0]==1)
+	{
+		irqnum=(val32[1]==0)?(IRQ_EXT5_H5):(IRQ_EXT5_G15);
+		irqflag=trigger_type[val32[2]]|IRQF_NO_SUSPEND;
+		if(flag==1){
+					__raw_writel((1<<5) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(irqnum);
+		}
+		if ((err = request_irq(irqnum,nuc970_eint5_interrupt,irqflag, "eint5", 0)) != 0) {
+			printk("%s - eint5 can not get irq!\n", __func__);
+			return -EINVAL;
+		}
+	}
+	
+	//eint 6 
+	if (of_property_read_u32_array(pdev->dev.of_node, "eint6-config", val32, 3) != 0){
+		printk("%s - eint6 can not get port-number!\n", __func__);
+		return -EINVAL;
+	} 	
+	if(val32[0]==1)
+	{
+		irqnum=(val32[1]==0)?(IRQ_EXT6_H6):(IRQ_EXT6_I1);
+		irqflag=trigger_type[val32[2]]|IRQF_NO_SUSPEND;
+		if(flag==1){
+					__raw_writel((1<<6) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(irqnum);
+		}
+		if ((err = request_irq(irqnum,nuc970_eint6_interrupt,irqflag, "eint6", 0)) != 0) {
+			printk("%s - eint6 can not get irq!\n", __func__);
+			return -EINVAL;
+		}
+	}
+	
+	//eint 7 	
+	if (of_property_read_u32_array(pdev->dev.of_node, "eint7-config", val32, 3) != 0){
+		printk("%s - eint7 can not get port-number!\n", __func__);
+		return -EINVAL;
+	} 	
+	if(val32[0]==1)
+	{
+		irqnum=(val32[1]==0)?(IRQ_EXT7_H7):(IRQ_EXT7_I2);
+		irqflag=trigger_type[val32[2]]|IRQF_NO_SUSPEND;
+		if(flag==1){
+					__raw_writel((1<<7) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+					enable_irq_wake(irqnum);
+		}
+		if ((err = request_irq(irqnum,nuc970_eint7_interrupt,irqflag, "eint7", 0)) != 0) {
+			printk("%s - eint7 can not get irq!\n", __func__);
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+#endif
+
+static int nuc970_gpio_probe(struct platform_device *pdev)
+{
+	int err;
+	struct clk *clk;	
+	
+	//printk("%s - pdev = %s\n", __func__, pdev->name);
+#ifndef CONFIG_OF
+	if(pdev->id == 0)
+#endif
+	{
+
+		/* Enable GPIO clock */
+		clk = clk_get(NULL, "gpio");
+	        if (IS_ERR(clk)) {
+			printk(KERN_ERR "nuc970-gpio:failed to get gpio clock source\n");
+			err = PTR_ERR(clk);
+			return err;
+		}
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "gpio_eclk");
+	        if (IS_ERR(clk)) {
+			printk(KERN_ERR "nuc970-gpio:failed to get gpio clock source\n");
+			err = PTR_ERR(clk);
+			return err;
+		}
+
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		nuc970_gpio_port.dev = &pdev->dev;
+		err = gpiochip_add(&nuc970_gpio_port);
+		if (err < 0) {
+			goto err_nuc970_gpio_port;
+		}
+
+	}
+
+#ifdef CONFIG_OF
+	{
+		struct pinctrl *pinctrl;
+		pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+		if (IS_ERR(pinctrl)) {
+			return PTR_ERR(pinctrl);
+		}
+	}
+#endif
+	#ifdef CONFIG_GPIO_NUC970_EINT_WKUP
+		nuc970_enable_eint(1,pdev);
+	#else
+		nuc970_enable_eint(0,pdev);
+	#endif
+
+	return 0;
+
+ err_nuc970_gpio_port:
+	gpio_ba = 0;
+	return err;
+}
+
+static int nuc970_gpio_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+
+        struct clk *clk;
+
+        /* Disable GPIO clock */
+        clk = clk_get(NULL, "gpio");
+        if (IS_ERR(clk)) {
+                int err;
+
+		printk(KERN_ERR "nuc970-gpio:failed to get gpio clock source\n");
+                err = PTR_ERR(clk);
+                return err;
+        }
+
+        clk_disable(clk);
+
+	if (gpio_ba) {
+//		int err;
+
+		/*err = */gpiochip_remove(&nuc970_gpio_port);
+#if 0
+		if (err)
+			dev_err(&pdev->dev, "%s failed, %d\n",
+				"gpiochip_remove()", err);
+#endif 
+		res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+		release_region(res->start, resource_size(res));
+		gpio_ba = 0;
+		return /*err*/0;
+	}
+
+	return 0;
+}
+
+#if defined CONFIG_NUC970_KEYPAD_PH
+static int kpi_suspend_flag = 0;
+static int kpi_resume_flag = 0;
+#endif
+
+static int nuc970_gpio_resume(struct platform_device *pdev){
+#if defined CONFIG_NUC970_KEYPAD_PH
+	int i;
+#endif
+
+	ENTRY();
+
+#if defined CONFIG_NUC970_KEYPAD_PH
+	if(kpi_resume_flag == 0)
+	{
+		__raw_writel(__raw_readl(REG_WKUPSER)& ~(1 << 25),REG_WKUPSER);
+
+		for(i = 0; i < NUC970_KPD_ROW_NUMBER; i++)
+		{
+			disable_irq_nosync(gpio_to_irq(NUC970_PH4+i));
+		}
+
+		// Set Column
+		writel(readl(REG_GPIOH_DIR) & ~( ((1 << NUC970_KPD_COL_NUMBER) - 1) << 8), REG_GPIOH_DIR); // input
+		writel(readl(REG_GPIOH_PUEN) | ( ((1 << NUC970_KPD_COL_NUMBER) - 1) << 8), REG_GPIOH_PUEN); // pull-up
+
+		// Set Row
+		writel(readl(REG_GPIOH_DIR) | ( ((1 << NUC970_KPD_ROW_NUMBER) - 1) << 4), REG_GPIOH_DIR);  // output
+		writel(readl(REG_GPIOH_PUEN) | ( ((1 << NUC970_KPD_ROW_NUMBER) - 1) << 4), REG_GPIOH_PUEN); // pull up
+		writel(readl(REG_GPIOH_DATAOUT) & ~( ((1 << NUC970_KPD_ROW_NUMBER) - 1) << 4), REG_GPIOH_DATAOUT); // low
+
+		// clear ISR
+		writel(readl(REG_GPIOH_ISR), REG_GPIOH_ISR);
+
+		for(i = 0; i < NUC970_KPD_COL_NUMBER; i++)
+		{
+			enable_irq(gpio_to_irq(NUC970_PH8+i));
+		}
+
+		kpi_suspend_flag = 0;
+		kpi_resume_flag = 1;
+	}
+    
+#endif
+	LEAVE();
+	return 0;
+}
+
+static int nuc970_gpio_suspend(struct platform_device *pdev,pm_message_t state){
+#if defined CONFIG_NUC970_KEYPAD_PH
+	int i;
+#endif
+	ENTRY();
+#if defined CONFIG_NUC970_KEYPAD_PH
+	if(kpi_suspend_flag == 0)
+	{
+		for(i = 0; i < NUC970_KPD_COL_NUMBER; i++)
+		{
+			disable_irq_nosync(gpio_to_irq(NUC970_PH8+i));
+		}
+
+		// Set Row
+		writel(readl(REG_GPIOH_DIR) & ~( ((1 << NUC970_KPD_COL_NUMBER) - 1) << 4), REG_GPIOH_DIR); // input
+		writel(readl(REG_GPIOH_PUEN) | ( ((1 << NUC970_KPD_COL_NUMBER) - 1) << 4), REG_GPIOH_PUEN); // pull-up
+
+		// Set Column
+		writel(readl(REG_GPIOH_DIR) | ( ((1 << NUC970_KPD_ROW_NUMBER) - 1) << 8), REG_GPIOH_DIR);  // output
+		writel(readl(REG_GPIOH_PUEN) | ( ((1 << NUC970_KPD_ROW_NUMBER) - 1) << 8), REG_GPIOH_PUEN); // pull up
+		writel(readl(REG_GPIOH_DATAOUT) & ~( ((1 << NUC970_KPD_ROW_NUMBER) - 1) << 8), REG_GPIOH_DATAOUT); // low
+
+		// clear ISR
+		writel(readl(REG_GPIOH_ISR), REG_GPIOH_ISR);
+
+		__raw_writel(__raw_readl(REG_WKUPSER)| (1 << 25),REG_WKUPSER);
+
+		for(i = 0; i < NUC970_KPD_ROW_NUMBER; i++)
+		{
+			enable_irq(gpio_to_irq(NUC970_PH4+i));
+		}
+
+		kpi_suspend_flag = 1;
+		kpi_resume_flag = 0;
+	}
+#endif
+	LEAVE();
+	return 0;
+}
+
+static const struct of_device_id nuc970_gpio_of_match[] = {
+	{ .compatible = "nuvoton,nuc970-gpio" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nuc970_gpio_of_match);
+
+static struct platform_driver nuc970_gpio_driver = {
+	.probe		= nuc970_gpio_probe,
+	.remove		= nuc970_gpio_remove,
+	.resume		= nuc970_gpio_resume,
+	.suspend	= nuc970_gpio_suspend,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(nuc970_gpio_of_match),
+	},
+};
+module_platform_driver(nuc970_gpio_driver);
+
+MODULE_AUTHOR("shan chun <SCChung@nuvoton.com>");
+MODULE_DESCRIPTION("GPIO interface for Nuvoton NUC970 GPIO Drive");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nuc970_gpio");
Index: linux-4.4.92/drivers/net/ethernet/nuvoton/Kconfig
===================================================================
--- linux-4.4.92.orig/drivers/net/ethernet/nuvoton/Kconfig
+++ linux-4.4.92/drivers/net/ethernet/nuvoton/Kconfig
@@ -5,7 +5,7 @@
 config NET_VENDOR_NUVOTON
 	bool "Nuvoton devices"
 	default y
-	depends on ARM && ARCH_W90X900
+	depends on ARM && (ARCH_W90X900 || ARCH_NUC970)
 	---help---
 	  If you have a network (Ethernet) card belonging to this class, say Y.
 
@@ -25,4 +25,24 @@ config W90P910_ETH
 	  Say Y here if you want to use built-in Ethernet ports
 	  on w90p910 processor.
 
+config NUC970_ETH0
+	tristate "Nuvoton NUC970 Ethernet MAC 0"
+	depends on ARM && ARCH_NUC970
+	select PHYLIB
+	select NET_CORE
+	select MII
+	---help---
+	  Say Y here if you want to use built-in Ethernet MAC 0
+	  on NUC970 MCU.
+
+config NUC970_ETH1
+	tristate "Nuvoton NUC970 Ethernet MAC 1"
+	depends on ARM && ARCH_NUC970
+	select PHYLIB
+	select NET_CORE
+	select MII
+	---help---
+	  Say Y here if you want to use built-in Ethernet MAC 1
+	  on NUC970 MCU.
+
 endif # NET_VENDOR_NUVOTON
Index: linux-4.4.92/drivers/net/ethernet/nuvoton/Makefile
===================================================================
--- linux-4.4.92.orig/drivers/net/ethernet/nuvoton/Makefile
+++ linux-4.4.92/drivers/net/ethernet/nuvoton/Makefile
@@ -3,3 +3,5 @@
 #
 
 obj-$(CONFIG_W90P910_ETH) += w90p910_ether.o
+obj-$(CONFIG_NUC970_ETH0) += nuc970_ether0.o
+obj-$(CONFIG_NUC970_ETH1) += nuc970_ether1.o
Index: linux-4.4.92/drivers/net/ethernet/nuvoton/nuc970_ether0.c
===================================================================
--- /dev/null
+++ linux-4.4.92/drivers/net/ethernet/nuvoton/nuc970_ether0.c
@@ -0,0 +1,1375 @@
+/*
+ * Copyright (c) 2014-2016 Nuvoton Technology Corporation.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/gfp.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/ctype.h>
+#include <linux/net_tstamp.h>
+
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gcr.h>
+
+#define DRV_MODULE_NAME		"nuc970-emc0"
+#define DRV_MODULE_VERSION	"1.0"
+
+/* Ethernet MAC0 Registers */
+#define REG_CAMCMR		(void __iomem *)0xF0002000
+#define REG_CAMEN		(void __iomem *)0xF0002004
+#define REG_CAMM_BASE	(void __iomem *)0xF0002008
+#define REG_CAML_BASE	(void __iomem *)0xF000200c
+#define REG_TXDLSA		(void __iomem *)0xF0002088
+#define REG_RXDLSA		(void __iomem *)0xF000208C
+#define REG_MCMDR		(void __iomem *)0xF0002090
+#define REG_MIID		(void __iomem *)0xF0002094
+#define REG_MIIDA		(void __iomem *)0xF0002098
+#define REG_FFTCR		(void __iomem *)0xF000209C
+#define REG_TSDR		(void __iomem *)0xF00020a0
+#define REG_RSDR		(void __iomem *)0xF00020a4
+#define REG_DMARFC		(void __iomem *)0xF00020a8
+#define REG_MIEN		(void __iomem *)0xF00020ac
+#define REG_MISTA		(void __iomem *)0xF00020b0
+#define REG_CTXDSA		(void __iomem *)0xF00020cc
+#define REG_CTXBSA		(void __iomem *)0xF00020d0
+#define REG_CRXDSA		(void __iomem *)0xF00020d4
+#define REG_CRXBSA		(void __iomem *)0xF00020d8
+
+/* mac controller bit */
+#define MCMDR_RXON		0x01
+#define MCMDR_ACP		(0x01 << 3)
+#define MCMDR_SPCRC		(0x01 << 5)
+#define MCMDR_MGPWAKE		(0x01 << 6)
+#define MCMDR_TXON		(0x01 << 8)
+#define MCMDR_FDUP		(0x01 << 18)
+//#define MCMDR_ENMDC		(0x01 << 19)
+#define MCMDR_OPMOD		(0x01 << 20)
+#define SWR				(0x01 << 24)
+
+/* cam command register */
+#define CAMCMR_AUP		0x01
+#define CAMCMR_AMP		(0x01 << 1)
+#define CAMCMR_ABP		(0x01 << 2)
+#define CAMCMR_CCAM		(0x01 << 3)
+#define CAMCMR_ECMP		(0x01 << 4)
+#define CAM0EN			0x01
+
+/* mac mii controller bit */
+#define MDCON			(0x01 << 19)
+//#define PHYAD			(0x01 << 8)
+#define PHYWR			(0x01 << 16)
+#define PHYBUSY			(0x01 << 17)
+#define CAM_ENTRY_SIZE		0x08
+
+/* rx and tx status */
+#define TXDS_TXCP		(0x01 << 19)
+#define RXDS_CRCE		(0x01 << 17)
+#define RXDS_PTLE		(0x01 << 19)
+#define RXDS_RXGD		(0x01 << 20)
+#define RXDS_ALIE		(0x01 << 21)
+#define RXDS_RP			(0x01 << 22)
+
+/* mac interrupt status*/
+#define MISTA_EXDEF		(0x01 << 19)
+#define MISTA_TXBERR		(0x01 << 24)
+#define MISTA_TDU		(0x01 << 23)
+#define MISTA_RDU		(0x01 << 10)
+#define MISTA_RXBERR		(0x01 << 11)
+#define MISTA_WOL		(0x01 << 15)
+#define MISTA_RXGD		(0x01 << 4)
+
+
+
+#define ENSTART			0x01
+#define ENRXINTR		0x01
+#define ENRXGD			(0x01 << 4)
+#define ENRDU			(0x01 << 10)
+#define ENRXBERR		(0x01 << 11)
+#define ENWOL			(0x01 << 15)
+#define ENTXINTR		(0x01 << 16)
+#define ENTXCP			(0x01 << 18)
+#define ENTXABT			(0x01 << 21)
+#define ENTXBERR		(0x01 << 24)
+//#define ENMDC			(0x01 << 19)
+#define PHYBUSY			(0x01 << 17)
+//#define MDCCR_VAL		0xa00000
+
+/* rx and tx owner bit */
+#define RX_OWEN_DMA		(0x01 << 31)
+#define RX_OWEN_CPU		(~(0x03 << 30))
+#define TX_OWEN_DMA		(0x01 << 31)
+#define TX_OWEN_CPU		(~(0x01 << 31))
+
+/* tx frame desc controller bit */
+#define MACTXINTEN		0x04
+#define CRCMODE			0x02
+#define PADDINGMODE		0x01
+
+/* fftcr controller bit */
+#define TXTHD 			(0x03 << 8)
+#define BLENGTH			(0x01 << 20)
+
+/* global setting for driver */
+#define RX_DESC_SIZE	32
+#define TX_DESC_SIZE	32
+#define MAX_RBUFF_SZ	0x600
+#define MAX_TBUFF_SZ	0x600
+#define TX_TIMEOUT	50
+#define DELAY		1000
+#define CAM0		0x0
+
+#define MII_TIMEOUT	100
+
+#define ETH_TRIGGER_RX	do{__raw_writel(ENSTART, REG_RSDR);}while(0)
+#define ETH_TRIGGER_TX	do{__raw_writel(ENSTART, REG_TSDR);}while(0)
+#define ETH_ENABLE_TX	do{__raw_writel(__raw_readl( REG_MCMDR) | MCMDR_TXON, REG_MCMDR);}while(0)
+#define ETH_ENABLE_RX	do{__raw_writel(__raw_readl( REG_MCMDR) | MCMDR_RXON, REG_MCMDR);}while(0)
+#define ETH_DISABLE_TX	do{__raw_writel(__raw_readl( REG_MCMDR) & ~MCMDR_TXON, REG_MCMDR);}while(0)
+#define ETH_DISABLE_RX	do{__raw_writel(__raw_readl( REG_MCMDR) & ~MCMDR_RXON, REG_MCMDR);}while(0)
+
+struct nuc970_rxbd {
+	unsigned int sl;
+	unsigned int buffer;
+	unsigned int reserved;
+	unsigned int next;
+};
+
+struct nuc970_txbd {
+	unsigned int mode;
+	unsigned int buffer;
+	unsigned int sl;
+	unsigned int next;
+};
+
+u8 nuc970_mac0[6] = { 0x08, 0x00, 0x27, 0x00, 0x01, 0x92 };
+
+static struct sk_buff *rx_skb[RX_DESC_SIZE];
+static struct sk_buff *tx_skb[TX_DESC_SIZE];
+
+struct  nuc970_ether {
+	spinlock_t lock;
+	struct nuc970_rxbd *rdesc;
+	struct nuc970_txbd *tdesc;
+	dma_addr_t rdesc_phys;
+	dma_addr_t tdesc_phys;
+	struct net_device_stats stats;
+	struct platform_device *pdev;
+	struct net_device *ndev;
+	struct resource *res;
+	//struct sk_buff *skb;
+	struct clk *clk;
+	struct clk *eclk;
+	unsigned int msg_enable;
+	struct mii_bus *mii_bus;
+	struct phy_device *phy_dev;
+	struct napi_struct napi;
+	int rxirq;
+	int txirq;
+	unsigned int cur_tx;
+	unsigned int cur_rx;
+	unsigned int finish_tx;
+	//unsigned int rx_packets;
+	//unsigned int rx_bytes;
+	unsigned int start_tx_ptr;
+	unsigned int start_rx_ptr;
+	int link;
+	int speed;
+	int duplex;
+	int wol;
+};
+
+
+static __init int setup_macaddr(char *str)
+{
+	u8 mac[6] = {0, 0, 0, 0, 0, 0};
+	char *c = str;
+	int i, j;
+
+	if (!str)
+		goto err;
+
+	for(i = 0; i < 6; i++) {
+		for(j = 0; j < 2; j++) {
+			mac[i] <<= 4;
+			if(isdigit(*c))
+				mac[i] += *c - '0';
+			else if(isxdigit(*c))
+				mac[i] += toupper(*c) - 'A' + 10;
+			else {
+				goto err;
+			}
+			c++;
+		}
+
+		if(i != 5)
+			if(*c != ':') {
+				goto err;
+			}
+
+		c++;
+	}
+
+	// all good
+	for(i = 0; i < 6; i++) {
+		nuc970_mac0[i] = mac[i];
+
+	}
+	return 0;
+
+err:
+	return -EINVAL;
+}
+early_param("ethaddr0", setup_macaddr);
+
+static void adjust_link(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct phy_device *phydev = ether->phy_dev;
+	unsigned int val;
+	bool status_change = false;
+	unsigned long flags;
+
+	// clear GPIO interrupt status which indicates PHY status change?
+
+	spin_lock_irqsave(&ether->lock, flags);
+
+	if (phydev->link) {
+		if ((ether->speed != phydev->speed) ||
+		    (ether->duplex != phydev->duplex)) {
+			ether->speed = phydev->speed;
+			ether->duplex = phydev->duplex;
+			status_change = true;
+		}
+	} else {
+		// disable tx/rx
+		__raw_writel(__raw_readl( REG_MCMDR) & ~(MCMDR_RXON | MCMDR_TXON), REG_MCMDR);
+		ether->speed = 0;
+		ether->duplex = -1;
+	}
+
+	if (phydev->link != ether->link) {
+
+		ether->link = phydev->link;
+		if(phydev->link)
+			status_change = true;
+	}
+
+	spin_unlock_irqrestore(&ether->lock, flags);
+
+	if (status_change) {
+
+		val = __raw_readl( REG_MCMDR) | MCMDR_RXON | MCMDR_TXON;
+
+		if (ether->speed == 100) {
+			val |= MCMDR_OPMOD;
+		} else {
+			val &= ~MCMDR_OPMOD;
+		}
+
+		if(ether->duplex == DUPLEX_FULL) {
+			val |= MCMDR_FDUP;
+		} else {
+			val &= ~MCMDR_FDUP;
+		}
+
+		__raw_writel(val,  REG_MCMDR);
+		ETH_TRIGGER_TX; // in case some packets queued in descriptor
+	}
+}
+
+
+
+static void nuc970_write_cam(struct net_device *dev,
+				unsigned int x, unsigned char *pval)
+{
+	unsigned int msw, lsw;
+
+	msw = (pval[0] << 24) | (pval[1] << 16) | (pval[2] << 8) | pval[3];
+
+	lsw = (pval[4] << 24) | (pval[5] << 16);
+
+	__raw_writel(lsw,  REG_CAML_BASE + x * CAM_ENTRY_SIZE);
+	__raw_writel(msw,  REG_CAMM_BASE + x * CAM_ENTRY_SIZE);
+}
+
+
+static struct sk_buff * get_new_skb(struct net_device *dev, u32 i) {
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct sk_buff *skb = dev_alloc_skb(2048);
+
+	if (skb == NULL)
+		return NULL;
+
+	skb->dev = dev;
+
+	(ether->rdesc + i)->buffer = dma_map_single(&dev->dev, skb->data,
+							2048, DMA_FROM_DEVICE);
+	rx_skb[i] = skb;
+
+	return skb;
+}
+
+static int nuc970_init_desc(struct net_device *dev)
+{
+	struct nuc970_ether *ether;
+	struct nuc970_txbd  *tdesc;
+	struct nuc970_rxbd  *rdesc;
+	struct platform_device *pdev;
+	unsigned int i;
+
+	ether = netdev_priv(dev);
+	pdev = ether->pdev;
+
+	ether->tdesc = (struct nuc970_txbd *)
+			dma_alloc_coherent(&pdev->dev, sizeof(struct nuc970_txbd) * TX_DESC_SIZE,
+						&ether->tdesc_phys, GFP_KERNEL);
+
+	if (!ether->tdesc) {
+		dev_err(&pdev->dev, "Failed to allocate memory for tx desc\n");
+		return -ENOMEM;
+	}
+
+	ether->rdesc = (struct nuc970_rxbd *)
+			dma_alloc_coherent(&pdev->dev, sizeof(struct nuc970_rxbd) * RX_DESC_SIZE,
+						&ether->rdesc_phys, GFP_KERNEL);
+
+	if (!ether->rdesc) {
+		dev_err(&pdev->dev, "Failed to allocate memory for rx desc\n");
+		dma_free_coherent(&pdev->dev, sizeof(struct nuc970_txbd) * TX_DESC_SIZE,
+						ether->tdesc, ether->tdesc_phys);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < TX_DESC_SIZE; i++) {
+		unsigned int offset;
+
+		tx_skb[i] = NULL;
+		tdesc = (ether->tdesc + i);
+
+		if (i == TX_DESC_SIZE - 1)
+			offset = 0;
+		else
+			offset = sizeof(struct nuc970_txbd) * (i + 1);
+
+		tdesc->next = ether->tdesc_phys + offset;
+		tdesc->buffer = (unsigned int)NULL;
+		tdesc->sl = 0;
+		tdesc->mode = PADDINGMODE | CRCMODE | MACTXINTEN;
+	}
+
+	ether->start_tx_ptr = ether->tdesc_phys;
+
+	for (i = 0; i < RX_DESC_SIZE; i++) {
+		unsigned int offset;
+
+		rdesc = (ether->rdesc + i);
+
+		if (i == RX_DESC_SIZE - 1)
+			offset = 0;
+		else
+			offset = sizeof(struct nuc970_rxbd) * (i + 1);
+
+		rdesc->next = ether->rdesc_phys + offset;
+		rdesc->sl = RX_OWEN_DMA;
+		if(get_new_skb(dev, i) == NULL) {
+			dma_free_coherent(&pdev->dev, sizeof(struct nuc970_txbd) * TX_DESC_SIZE,
+						ether->tdesc, ether->tdesc_phys);
+			dma_free_coherent(&pdev->dev, sizeof(struct nuc970_rxbd) * RX_DESC_SIZE,
+						ether->rdesc, ether->rdesc_phys);
+
+			for(; i != 0; i--) {
+				dma_unmap_single(&dev->dev, (dma_addr_t)((ether->rdesc + i)->buffer),
+							2048, DMA_FROM_DEVICE);
+				dev_kfree_skb_any(rx_skb[i]);
+			}
+			return -ENOMEM;
+		}
+	}
+
+	ether->start_rx_ptr = ether->rdesc_phys;
+
+	return 0;
+}
+
+// This API must call with Tx/Rx stopped
+static void nuc970_free_desc(struct net_device *dev)
+{
+	struct sk_buff *skb;
+	u32 i;
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct platform_device *pdev = ether->pdev;
+
+	for (i = 0; i < TX_DESC_SIZE; i++) {
+		skb = tx_skb[i];
+		if(skb != NULL) {
+			dma_unmap_single(&dev->dev, (dma_addr_t)((ether->tdesc + i)->buffer), skb->len, DMA_TO_DEVICE);
+			dev_kfree_skb_any(skb);
+		}
+	}
+
+	for (i = 0; i < RX_DESC_SIZE; i++) {
+		skb = rx_skb[i];
+		if(skb != NULL) {
+			dma_unmap_single(&dev->dev, (dma_addr_t)((ether->rdesc + i)->buffer), 2048, DMA_FROM_DEVICE);
+			dev_kfree_skb_any(skb);
+		}
+	}
+
+	dma_free_coherent(&pdev->dev, sizeof(struct nuc970_txbd) * TX_DESC_SIZE,
+				ether->tdesc, ether->tdesc_phys);
+	dma_free_coherent(&pdev->dev, sizeof(struct nuc970_rxbd) * RX_DESC_SIZE,
+				ether->rdesc, ether->rdesc_phys);
+
+}
+
+static void nuc970_set_fifo_threshold(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = TXTHD | BLENGTH;
+	__raw_writel(val,  REG_FFTCR);
+}
+
+static void nuc970_return_default_idle(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = __raw_readl( REG_MCMDR);
+	val |= SWR;
+	__raw_writel(val,  REG_MCMDR);
+}
+
+
+static void nuc970_enable_mac_interrupt(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = ENTXINTR | ENRXINTR | ENRXGD | ENTXCP | ENRDU;
+	val |= ENTXBERR | ENRXBERR | ENTXABT | ENWOL;
+
+	__raw_writel(val,  REG_MIEN);
+}
+
+static void nuc970_get_and_clear_int(struct net_device *dev,
+							unsigned int *val, unsigned int mask)
+{
+	*val = __raw_readl( REG_MISTA) & mask;
+	__raw_writel(*val,  REG_MISTA);
+}
+
+static void nuc970_set_global_maccmd(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = __raw_readl( REG_MCMDR);
+	val |= MCMDR_SPCRC | /*MCMDR_ENMDC |*/ MCMDR_ACP /*| ENMDC*/;
+	__raw_writel(val,  REG_MCMDR);
+}
+
+static void nuc970_enable_cam(struct net_device *dev)
+{
+	unsigned int val;
+
+	nuc970_write_cam(dev, CAM0, dev->dev_addr);
+
+	val = __raw_readl( REG_CAMEN);
+	val |= CAM0EN;
+	__raw_writel(val,  REG_CAMEN);
+}
+
+static void nuc970_enable_cam_command(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = CAMCMR_ECMP | CAMCMR_ABP | CAMCMR_AMP;
+	__raw_writel(val,  REG_CAMCMR);
+}
+
+
+static void nuc970_set_curdest(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	__raw_writel(ether->start_rx_ptr,  REG_RXDLSA);
+	__raw_writel(ether->start_tx_ptr,  REG_TXDLSA);
+}
+
+static void nuc970_reset_mac(struct net_device *dev, int need_free)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	ETH_DISABLE_TX;
+	ETH_DISABLE_RX;;
+
+	nuc970_return_default_idle(dev);
+	nuc970_set_fifo_threshold(dev);
+
+	if (!netif_queue_stopped(dev))
+		netif_stop_queue(dev);
+
+	if(need_free)
+		nuc970_free_desc(dev);
+	nuc970_init_desc(dev);
+
+	//dev->trans_start = jiffies; /* prevent tx timeout */
+	ether->cur_tx = 0x0;
+	ether->finish_tx = 0x0;
+	ether->cur_rx = 0x0;
+
+	nuc970_set_curdest(dev);
+	nuc970_enable_cam(dev);
+	nuc970_enable_cam_command(dev);
+	nuc970_enable_mac_interrupt(dev);
+	ETH_ENABLE_TX;
+	ETH_ENABLE_RX;
+
+	ETH_TRIGGER_RX;
+
+	dev->trans_start = jiffies; /* prevent tx timeout */
+
+	if (netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+}
+
+static int nuc970_mdio_write(struct mii_bus *bus, int phy_id, int regnum,
+		u16 value)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(MII_TIMEOUT * 100);
+
+	__raw_writel(value,  REG_MIID);
+	__raw_writel((phy_id << 0x08) | regnum | PHYBUSY | MDCON | PHYWR,  REG_MIIDA);
+
+
+	/* Wait for completion */
+	while (__raw_readl( REG_MIIDA) & PHYBUSY) {
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		cpu_relax();
+	}
+
+	return 0;
+
+}
+
+static int nuc970_mdio_read(struct mii_bus *bus, int phy_id, int regnum)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(MII_TIMEOUT * 100);
+
+
+	__raw_writel((phy_id << 0x08) | regnum | PHYBUSY | MDCON,  REG_MIIDA);
+
+	/* Wait for completion */
+	while (__raw_readl( REG_MIIDA) & PHYBUSY) {
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		cpu_relax();
+	}
+
+	return __raw_readl(REG_MIID);
+}
+
+static int nuc970_mdio_reset(struct mii_bus *bus)
+{
+
+	// reser ENAC engine??
+	return 0;
+}
+
+static int nuc970_set_mac_address(struct net_device *dev, void *addr)
+{
+	struct sockaddr *address = addr;
+
+	if (!is_valid_ether_addr(address->sa_data))
+		return -EADDRNOTAVAIL;
+
+	memcpy(dev->dev_addr, address->sa_data, dev->addr_len);
+	nuc970_write_cam(dev, CAM0, dev->dev_addr);
+
+	return 0;
+}
+
+static int nuc970_ether_close(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct platform_device *pdev;
+
+	pdev = ether->pdev;
+
+	ETH_DISABLE_TX;
+	ETH_DISABLE_RX;
+	netif_stop_queue(dev);
+	napi_disable(&ether->napi);
+	free_irq(ether->txirq, dev);
+	free_irq(ether->rxirq, dev);
+
+	nuc970_return_default_idle(dev);
+	nuc970_free_desc(dev);
+
+	if (ether->phy_dev)
+		phy_stop(ether->phy_dev);
+
+	return 0;
+}
+
+static struct net_device_stats *nuc970_ether_stats(struct net_device *dev)
+{
+	struct nuc970_ether *ether;
+
+	ether = netdev_priv(dev);
+
+	return &ether->stats;
+}
+
+
+static int nuc970_ether_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct nuc970_txbd *txbd;
+
+	txbd = ether->tdesc + ether->cur_tx;
+	if(txbd->mode & TX_OWEN_DMA) {
+		netif_stop_queue(dev);
+		return NETDEV_TX_BUSY;
+	}
+
+	txbd->buffer = dma_map_single(&dev->dev, skb->data,
+					skb->len, DMA_TO_DEVICE);
+
+	tx_skb[ether->cur_tx]  = skb;
+	txbd->sl = skb->len > 1514 ? 1514 : skb->len;
+	wmb();	// This is dummy function for ARM9
+	txbd->mode |= TX_OWEN_DMA;
+	wmb();	// This is dummy function for ARM9
+
+	ETH_TRIGGER_TX;
+
+	if (++ether->cur_tx >= TX_DESC_SIZE)
+		ether->cur_tx = 0;
+	txbd = ether->tdesc + ether->cur_tx;
+	if(txbd->mode & TX_OWEN_DMA) {
+		netif_stop_queue(dev);
+		//return NETDEV_TX_BUSY;
+	}
+	return NETDEV_TX_OK;
+}
+
+static irqreturn_t nuc970_tx_interrupt(int irq, void *dev_id)
+{
+	struct nuc970_ether *ether;
+	struct platform_device *pdev;
+	struct net_device *dev;
+	unsigned int status;
+	struct sk_buff *s;
+	struct nuc970_txbd *txbd;
+
+	dev = dev_id;
+	ether = netdev_priv(dev);
+	pdev = ether->pdev;
+
+	nuc970_get_and_clear_int(dev, &status, 0xFFFF0000);
+
+	txbd = ether->tdesc + ether->finish_tx;
+	while((txbd->mode & TX_OWEN_DMA) != TX_OWEN_DMA) {
+		if((s = tx_skb[ether->finish_tx]) != NULL) {
+			dma_unmap_single(&dev->dev, txbd->buffer, s->len, DMA_TO_DEVICE);
+			dev_kfree_skb_irq(s);
+			tx_skb[ether->finish_tx] = NULL;
+			if (txbd->sl & TXDS_TXCP) {
+				ether->stats.tx_packets++;
+				ether->stats.tx_bytes += (txbd->sl & 0xFFFF);
+			} else {
+				ether->stats.tx_errors++;
+			}
+		} else
+			break;
+		ether->finish_tx = (ether->finish_tx + 1) % TX_DESC_SIZE;
+		txbd = ether->tdesc + ether->finish_tx;	
+	}
+
+	if (status & MISTA_EXDEF) {
+		dev_err(&pdev->dev, "emc defer exceed interrupt\n");
+	} else if (status & MISTA_TXBERR) {
+		dev_err(&pdev->dev, "emc bus error interrupt\n");
+		nuc970_reset_mac(dev, 1);
+	}
+
+	if (netif_queue_stopped(dev)) {
+		netif_wake_queue(dev);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int nuc970_poll(struct napi_struct *napi, int budget)
+{
+	struct nuc970_ether *ether = container_of(napi, struct nuc970_ether, napi);
+	struct nuc970_rxbd *rxbd;
+	struct net_device *dev = ether->ndev;
+	struct sk_buff *skb, *s;
+	unsigned int length, status;
+	int rx_cnt = 0;
+	int complete = 0;
+
+	rxbd = (ether->rdesc + ether->cur_rx);
+
+	while(rx_cnt < budget) {
+
+		if((rxbd->sl & RX_OWEN_DMA) == RX_OWEN_DMA) {
+			complete = 1;
+			break;
+		}
+
+		s = rx_skb[ether->cur_rx];
+		status = rxbd->sl;
+		length = status & 0xFFFF;
+
+		if (likely((status & RXDS_RXGD) && (length <= 1514))) {
+
+			skb = dev_alloc_skb(2048);
+			if (!skb) {
+				struct platform_device *pdev = ether->pdev;
+				dev_err(&pdev->dev, "get skb buffer error\n");
+				ether->stats.rx_dropped++;
+				goto rx_out;
+			}
+			dma_unmap_single(&dev->dev, (dma_addr_t)rxbd->buffer, 2048, DMA_FROM_DEVICE);
+
+			skb_put(s, length);
+			s->protocol = eth_type_trans(s, dev);
+			netif_receive_skb(s);
+			ether->stats.rx_packets++;
+			ether->stats.rx_bytes += length;
+
+			skb->dev = dev;
+
+			rxbd->buffer = dma_map_single(&dev->dev, skb->data,
+							2048, DMA_FROM_DEVICE);
+
+			rx_skb[ether->cur_rx] = skb;
+			rx_cnt++;
+
+		} else {
+			ether->stats.rx_errors++;
+
+			if (status & RXDS_RP) {
+				ether->stats.rx_length_errors++;
+			} else if (status & RXDS_CRCE) {
+				ether->stats.rx_crc_errors++;
+			} else if (status & RXDS_ALIE) {
+				ether->stats.rx_frame_errors++;
+			} else if (status & RXDS_PTLE) {
+				ether->stats.rx_over_errors++;
+			}
+		}
+
+		wmb();	// This is dummy function for ARM9
+		rxbd->sl = RX_OWEN_DMA;
+
+		if (++ether->cur_rx >= RX_DESC_SIZE)
+			ether->cur_rx = 0;
+
+		rxbd = (ether->rdesc + ether->cur_rx);
+
+	}
+
+	if(complete) {
+		napi_complete(napi); //changed from __napi_complete(napi); by tanshi li for ifconfig eth0 down error
+		__raw_writel(__raw_readl(REG_MIEN) | ENRXINTR,  REG_MIEN);
+	}
+
+rx_out:
+
+	ETH_TRIGGER_RX;
+	return(rx_cnt);
+}
+
+static irqreturn_t nuc970_rx_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct nuc970_ether *ether = netdev_priv(dev);
+	unsigned int status;
+
+	nuc970_get_and_clear_int(dev, &status, 0xFFFF);
+
+	if (unlikely(status & MISTA_RXBERR)) {
+		struct platform_device *pdev = ether->pdev;
+
+		dev_err(&pdev->dev, "emc rx bus error\n");
+		nuc970_reset_mac(dev, 1);
+
+	} else {
+		if(status & MISTA_WOL) {
+
+		}
+
+		if(status & MISTA_RXGD) {
+			__raw_writel(__raw_readl(REG_MIEN) & ~ENRXINTR,  REG_MIEN);
+			napi_schedule(&ether->napi);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+
+static int nuc970_ether_open(struct net_device *dev)
+{
+	struct nuc970_ether *ether;
+	struct platform_device *pdev;
+
+	ether = netdev_priv(dev);
+	pdev = ether->pdev;
+
+	nuc970_reset_mac(dev, 0);
+	nuc970_set_fifo_threshold(dev);
+	nuc970_set_curdest(dev);
+	nuc970_enable_cam(dev);
+	nuc970_enable_cam_command(dev);
+	nuc970_enable_mac_interrupt(dev);
+	nuc970_set_global_maccmd(dev);
+	ETH_ENABLE_RX;
+
+
+	if (request_irq(ether->txirq, nuc970_tx_interrupt,
+						0x0, pdev->name, dev)) {
+		dev_err(&pdev->dev, "register irq tx failed\n");
+		return -EAGAIN;
+	}
+
+	if (request_irq(ether->rxirq, nuc970_rx_interrupt,
+						IRQF_NO_SUSPEND, pdev->name, dev)) {
+		dev_err(&pdev->dev, "register irq rx failed\n");
+		free_irq(ether->txirq, dev);
+		return -EAGAIN;
+	}
+
+	phy_start(ether->phy_dev);
+	netif_start_queue(dev);
+	napi_enable(&ether->napi);
+
+	ETH_TRIGGER_RX;
+
+	dev_info(&pdev->dev, "%s is OPENED\n", dev->name);
+
+	return 0;
+}
+
+static void nuc970_ether_set_multicast_list(struct net_device *dev)
+{
+	struct nuc970_ether *ether;
+	unsigned int rx_mode;
+
+	ether = netdev_priv(dev);
+
+	if (dev->flags & IFF_PROMISC)
+		rx_mode = CAMCMR_AUP | CAMCMR_AMP | CAMCMR_ABP | CAMCMR_ECMP;
+	else if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev))
+		rx_mode = CAMCMR_AMP | CAMCMR_ABP | CAMCMR_ECMP;
+	else
+		rx_mode = CAMCMR_ECMP | CAMCMR_ABP;
+	__raw_writel(rx_mode,  REG_CAMCMR);
+}
+
+static int nuc970_ether_ioctl(struct net_device *dev,
+						struct ifreq *ifr, int cmd)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct phy_device *phydev = ether->phy_dev;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;;
+
+	return phy_mii_ioctl(phydev, ifr, cmd);
+}
+
+static void nuc970_get_drvinfo(struct net_device *dev,
+					struct ethtool_drvinfo *info)
+{
+	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
+	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
+	strlcpy(info->fw_version, "N/A", sizeof(info->fw_version));
+	strlcpy(info->bus_info, "N/A", sizeof(info->bus_info));
+}
+
+static int nuc970_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct phy_device *phydev = ether->phy_dev;
+
+	if (NULL == phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int nuc970_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct phy_device *phydev = ether->phy_dev;
+
+	if (NULL == phydev)
+		return -ENODEV;
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static u32 nuc970_get_msglevel(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	return ether->msg_enable;
+}
+
+static void nuc970_set_msglevel(struct net_device *dev, u32 level)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	ether->msg_enable = level;
+}
+
+static int nuc970_get_eee(struct net_device *dev, struct ethtool_eee *edata)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nuc970_set_eee(struct net_device *dev, struct ethtool_eee *edata)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nuc970_get_regs_len(struct net_device *dev)
+{
+	return 76 * sizeof(u32);
+}
+
+static void nuc970_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)
+{
+
+	regs->version = 0;
+	memcpy(p, REG_CAMCMR, 76 * sizeof(u32));
+}
+
+#ifdef CONFIG_PM
+static void nuc970_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	wol->supported = WAKE_MAGIC;
+	wol->wolopts = ether->wol ? WAKE_MAGIC : 0;
+
+}
+
+static int nuc970_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	if (wol->wolopts & ~WAKE_MAGIC)
+		return -EINVAL;
+
+	ether->wol = wol->wolopts & WAKE_MAGIC ? 1 : 0;
+
+	device_set_wakeup_capable(&dev->dev, wol->wolopts & WAKE_MAGIC);
+	device_set_wakeup_enable(&dev->dev, wol->wolopts & WAKE_MAGIC);
+
+	return 0;
+}
+#endif
+
+static int nuc970_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)
+{
+	info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
+				SOF_TIMESTAMPING_RX_HARDWARE |
+				SOF_TIMESTAMPING_RAW_HARDWARE;
+	info->phc_index = 0;
+	info->tx_types = (1 << HWTSTAMP_TX_OFF) |
+			 (1 << HWTSTAMP_TX_ON);
+	info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+			   (1 << HWTSTAMP_FILTER_ALL);
+	return 0;
+}
+
+static const struct ethtool_ops nuc970_ether_ethtool_ops = {
+	.get_settings	= nuc970_get_settings,
+	.set_settings	= nuc970_set_settings,
+	.get_drvinfo	= nuc970_get_drvinfo,
+	.get_msglevel	= nuc970_get_msglevel,
+	.set_msglevel	= nuc970_set_msglevel,
+	.get_link 	= ethtool_op_get_link,
+	.get_eee	= nuc970_get_eee,
+	.set_eee	= nuc970_set_eee,
+	.get_regs_len	= nuc970_get_regs_len,
+	.get_regs	= nuc970_get_regs,
+#ifdef CONFIG_PM
+	.get_wol 	= nuc970_get_wol,
+	.set_wol 	= nuc970_set_wol,
+#endif
+	.get_ts_info	= nuc970_get_ts_info,
+};
+
+static const struct net_device_ops nuc970_ether_netdev_ops = {
+	.ndo_open		= nuc970_ether_open,
+	.ndo_stop		= nuc970_ether_close,
+	.ndo_start_xmit		= nuc970_ether_start_xmit,
+	.ndo_get_stats		= nuc970_ether_stats,
+	.ndo_set_rx_mode	= nuc970_ether_set_multicast_list,
+	.ndo_set_mac_address	= nuc970_set_mac_address,
+	.ndo_do_ioctl		= nuc970_ether_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
+static void __init get_mac_address(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct platform_device *pdev;
+
+	pdev = ether->pdev;
+
+	if (is_valid_ether_addr(nuc970_mac0))
+		memcpy(dev->dev_addr, &nuc970_mac0[0], 0x06);
+	else
+		dev_err(&pdev->dev, "invalid mac address\n");
+}
+
+
+static int nuc970_mii_setup(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct platform_device *pdev;
+	struct phy_device *phydev;
+	int i, err = 0;
+
+	pdev = ether->pdev;
+
+	ether->mii_bus = mdiobus_alloc();
+	if (!ether->mii_bus) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev, "mdiobus_alloc() failed\n");
+		goto out0;
+	}
+
+	ether->mii_bus->name = "nuc970_rmii0";
+	ether->mii_bus->read = &nuc970_mdio_read;
+	ether->mii_bus->write = &nuc970_mdio_write;
+	ether->mii_bus->reset = &nuc970_mdio_reset;
+	snprintf(ether->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
+		 ether->pdev->name, ether->pdev->id);
+	ether->mii_bus->priv = ether;
+	ether->mii_bus->parent = &ether->pdev->dev;
+
+	ether->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	if (!ether->mii_bus->irq) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev, "kmalloc() failed\n");
+		goto out1;
+
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		ether->mii_bus->irq[i] = PHY_POLL;
+	//ether->mii_bus->irq[1] = ??   write me after the irq number is known
+
+	if (mdiobus_register(ether->mii_bus)) {
+		dev_err(&pdev->dev, "mdiobus_register() failed\n");
+		goto out2;
+	}
+
+	phydev = phy_find_first(ether->mii_bus);
+	if(phydev == NULL) {
+		err = -ENODEV;
+		dev_err(&pdev->dev, "phy_find_first() failed\n");
+		goto out3;
+	}
+
+	phydev = phy_connect(dev, dev_name(&phydev->dev),
+			     &adjust_link,
+			     PHY_INTERFACE_MODE_RMII);
+
+	if(IS_ERR(phydev)) {
+		err = PTR_ERR(phydev);
+		dev_err(&pdev->dev, "phy_connect() failed\n");
+		goto out3;
+	}
+
+	phydev->supported &= PHY_BASIC_FEATURES;
+	phydev->advertising = phydev->supported;
+	ether->phy_dev = phydev;
+	ether->wol = 0;
+
+	return 0;
+
+out3:
+	mdiobus_unregister(ether->mii_bus);
+out2:
+	kfree(ether->mii_bus->irq);
+out1:
+	mdiobus_free(ether->mii_bus);
+out0:
+
+	return err;
+}
+
+static int nuc970_ether_probe(struct platform_device *pdev)
+{
+	struct nuc970_ether *ether;
+	struct net_device *dev;
+	int error;
+#ifdef CONFIG_OF
+	struct pinctrl *pinctrl;
+#endif
+
+	dev = alloc_etherdev(sizeof(struct nuc970_ether));
+	if (!dev)
+		return -ENOMEM;
+
+	ether = netdev_priv(dev);
+
+	ether->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (ether->res == NULL) {
+		dev_err(&pdev->dev, "failed to get I/O memory\n");
+		error = -ENXIO;
+		goto err0;
+	}
+
+#ifdef CONFIG_OF
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		return PTR_ERR(pinctrl);
+	}
+#endif
+
+	ether->txirq = platform_get_irq(pdev, 0);
+	if (ether->txirq < 0) {
+		dev_err(&pdev->dev, "failed to get ether tx irq\n");
+		error = -ENXIO;
+		goto err0;
+	}
+
+	ether->rxirq = platform_get_irq(pdev, 1);
+	if (ether->rxirq < 0) {
+		dev_err(&pdev->dev, "failed to get ether rx irq\n");
+		error = -ENXIO;
+		goto err0;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	platform_set_drvdata(pdev, dev);
+	ether->ndev = dev;
+
+	ether->eclk = clk_get(NULL, "emac0_eclk");
+	if (IS_ERR(ether->eclk)) {
+		dev_err(&pdev->dev, "failed to get emac0_eclk clock\n");
+		error = PTR_ERR(ether->eclk);
+		goto err1;
+	}
+
+	// Set MDC to 1M
+	clk_set_rate(ether->eclk, 1000000);
+
+	clk_prepare(ether->eclk);
+	clk_enable(ether->eclk);
+
+	ether->clk = clk_get(NULL, "emac0_hclk");
+	if (IS_ERR(ether->clk)) {
+		dev_err(&pdev->dev, "failed to get emac0_hclk clock\n");
+		error = PTR_ERR(ether->clk);
+		goto err1;
+	}
+
+	clk_prepare(ether->clk);
+	clk_enable(ether->clk);
+
+	ether->pdev = pdev;
+	ether->msg_enable = NETIF_MSG_LINK;
+
+	dev->netdev_ops = &nuc970_ether_netdev_ops;
+	dev->ethtool_ops = &nuc970_ether_ethtool_ops;
+
+	dev->tx_queue_len = 32;//16;
+	dev->dma = 0x0;
+	dev->watchdog_timeo = TX_TIMEOUT;
+
+	get_mac_address(dev);
+
+	ether->cur_tx = 0x0;
+	ether->cur_rx = 0x0;
+	ether->finish_tx = 0x0;
+	ether->link = 0;
+	ether->speed = 100;
+	ether->duplex = DUPLEX_FULL;
+	spin_lock_init(&ether->lock);
+
+	netif_napi_add(dev, &ether->napi, nuc970_poll, /*16*/32);
+
+	ether_setup(dev);
+
+	if((error = nuc970_mii_setup(dev)) < 0) {
+		dev_err(&pdev->dev, "nuc970_mii_setup err\n");
+		goto err2;
+	}
+	netif_carrier_off(dev);
+	error = register_netdev(dev);
+	if (error != 0) {
+		dev_err(&pdev->dev, "register_netdev() failed\n");
+		error = -ENODEV;
+		goto err2;
+	}
+
+	return 0;
+
+err2:
+	clk_disable(ether->clk);
+	clk_put(ether->clk);
+err1:
+	platform_set_drvdata(pdev, NULL);
+err0:
+	free_netdev(dev);
+
+	return error;
+}
+
+static int nuc970_ether_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	unregister_netdev(dev);
+
+	clk_disable(ether->clk);
+	clk_put(ether->clk);
+
+	clk_disable(ether->eclk);
+	clk_put(ether->eclk);
+
+	free_irq(ether->txirq, dev);
+	free_irq(ether->rxirq, dev);
+	phy_disconnect(ether->phy_dev);
+
+	mdiobus_unregister(ether->mii_bus);
+	kfree(ether->mii_bus->irq);
+	mdiobus_free(ether->mii_bus);
+
+	platform_set_drvdata(pdev, NULL);
+
+	free_netdev(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int nuc970_ether_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	netif_device_detach(dev);
+
+	if(netif_running(dev)) {
+		ETH_DISABLE_TX;
+		ETH_DISABLE_RX;
+
+		napi_disable(&ether->napi);
+
+		if(ether->wol) {  // enable wakeup from magic packet
+			__raw_writel(__raw_readl(REG_MCMDR) | MCMDR_MGPWAKE, REG_MCMDR);
+			__raw_writel(__raw_readl(REG_WKUPSER) | (1 << 16), REG_WKUPSER);
+		} else {
+			phy_stop(ether->phy_dev);
+		}
+
+	}
+
+	return 0;
+
+}
+
+static int nuc970_ether_resume(struct platform_device *pdev)
+{
+
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	if (netif_running(dev)) {
+
+		if(ether->wol) {  // enable wakeup from magic packet
+			__raw_writel(__raw_readl(REG_WKUPSER) & ~(1 << 16), REG_WKUPSER);
+			__raw_writel(__raw_readl(REG_MCMDR) & ~MCMDR_MGPWAKE, REG_MCMDR);
+		} else {
+
+			phy_start(ether->phy_dev);
+		}
+
+		napi_enable(&ether->napi);
+
+		ETH_ENABLE_TX;
+		ETH_ENABLE_RX;
+
+	}
+
+	netif_device_attach(dev);
+	return 0;
+
+}
+
+#else
+#define nuc970_ether_suspend NULL
+#define nuc970_ether_resume NULL
+#endif
+
+static const struct of_device_id nuc970_emac0_of_match[] = {
+	{ .compatible = "nuvoton,nuc970-emac0" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nuc970_emac0_of_match);
+
+static struct platform_driver nuc970_ether_driver = {
+	.probe		= nuc970_ether_probe,
+	.remove		= nuc970_ether_remove,
+	.suspend 	= nuc970_ether_suspend,
+	.resume 	= nuc970_ether_resume,
+	.driver		= {
+		.name	= "nuc970-emac0",
+	    .of_match_table = of_match_ptr(nuc970_emac0_of_match),
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init nuc970_ether_init(void)
+{
+
+	return platform_driver_register(&nuc970_ether_driver);
+}
+
+static void __exit nuc970_ether_exit(void)
+{
+	platform_driver_unregister(&nuc970_ether_driver);
+}
+
+module_init(nuc970_ether_init);
+module_exit(nuc970_ether_exit);
+
+MODULE_AUTHOR("Nuvoton Technology Corp.");
+MODULE_DESCRIPTION("NUC970 MAC0 driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nuc970-emac0");
+
Index: linux-4.4.92/drivers/net/ethernet/nuvoton/nuc970_ether1.c
===================================================================
--- /dev/null
+++ linux-4.4.92/drivers/net/ethernet/nuvoton/nuc970_ether1.c
@@ -0,0 +1,1375 @@
+/*
+ * Copyright (c) 2014-2016 Nuvoton Technology Corporation.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/gfp.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/ctype.h>
+#include <linux/net_tstamp.h>
+
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gcr.h>
+
+#define DRV_MODULE_NAME		"nuc970-emc1"
+#define DRV_MODULE_VERSION	"1.0"
+
+/* Ethernet MAC1 Registers */
+#define REG_CAMCMR		(void __iomem *)0xF0003000
+#define REG_CAMEN		(void __iomem *)0xF0003004
+#define REG_CAMM_BASE	(void __iomem *)0xF0003008
+#define REG_CAML_BASE	(void __iomem *)0xF000300c
+#define REG_TXDLSA		(void __iomem *)0xF0003088
+#define REG_RXDLSA		(void __iomem *)0xF000308C
+#define REG_MCMDR		(void __iomem *)0xF0003090
+#define REG_MIID		(void __iomem *)0xF0003094
+#define REG_MIIDA		(void __iomem *)0xF0003098
+#define REG_FFTCR		(void __iomem *)0xF000309C
+#define REG_TSDR		(void __iomem *)0xF00030a0
+#define REG_RSDR		(void __iomem *)0xF00030a4
+#define REG_DMARFC		(void __iomem *)0xF00030a8
+#define REG_MIEN		(void __iomem *)0xF00030ac
+#define REG_MISTA		(void __iomem *)0xF00030b0
+#define REG_CTXDSA		(void __iomem *)0xF00030cc
+#define REG_CTXBSA		(void __iomem *)0xF00030d0
+#define REG_CRXDSA		(void __iomem *)0xF00030d4
+#define REG_CRXBSA		(void __iomem *)0xF00030d8
+
+/* mac controller bit */
+#define MCMDR_RXON		0x01
+#define MCMDR_ACP		(0x01 << 3)
+#define MCMDR_SPCRC		(0x01 << 5)
+#define MCMDR_MGPWAKE		(0x01 << 6)
+#define MCMDR_TXON		(0x01 << 8)
+#define MCMDR_FDUP		(0x01 << 18)
+//#define MCMDR_ENMDC		(0x01 << 19)
+#define MCMDR_OPMOD		(0x01 << 20)
+#define SWR				(0x01 << 24)
+
+/* cam command register */
+#define CAMCMR_AUP		0x01
+#define CAMCMR_AMP		(0x01 << 1)
+#define CAMCMR_ABP		(0x01 << 2)
+#define CAMCMR_CCAM		(0x01 << 3)
+#define CAMCMR_ECMP		(0x01 << 4)
+#define CAM0EN			0x01
+
+/* mac mii controller bit */
+#define MDCON			(0x01 << 19)
+//#define PHYAD			(0x01 << 8)
+#define PHYWR			(0x01 << 16)
+#define PHYBUSY			(0x01 << 17)
+#define CAM_ENTRY_SIZE		0x08
+
+/* rx and tx status */
+#define TXDS_TXCP		(0x01 << 19)
+#define RXDS_CRCE		(0x01 << 17)
+#define RXDS_PTLE		(0x01 << 19)
+#define RXDS_RXGD		(0x01 << 20)
+#define RXDS_ALIE		(0x01 << 21)
+#define RXDS_RP			(0x01 << 22)
+
+/* mac interrupt status*/
+#define MISTA_EXDEF		(0x01 << 19)
+#define MISTA_TXBERR		(0x01 << 24)
+#define MISTA_TDU		(0x01 << 23)
+#define MISTA_RDU		(0x01 << 10)
+#define MISTA_RXBERR		(0x01 << 11)
+#define MISTA_WOL		(0x01 << 15)
+#define MISTA_RXGD		(0x01 << 4)
+
+
+
+#define ENSTART			0x01
+#define ENRXINTR		0x01
+#define ENRXGD			(0x01 << 4)
+#define ENRDU			(0x01 << 10)
+#define ENRXBERR		(0x01 << 11)
+#define ENWOL			(0x01 << 15)
+#define ENTXINTR		(0x01 << 16)
+#define ENTXCP			(0x01 << 18)
+#define ENTXABT			(0x01 << 21)
+#define ENTXBERR		(0x01 << 24)
+//#define ENMDC			(0x01 << 19)
+#define PHYBUSY			(0x01 << 17)
+//#define MDCCR_VAL		0xa00000
+
+/* rx and tx owner bit */
+#define RX_OWEN_DMA		(0x01 << 31)
+#define RX_OWEN_CPU		(~(0x03 << 30))
+#define TX_OWEN_DMA		(0x01 << 31)
+#define TX_OWEN_CPU		(~(0x01 << 31))
+
+/* tx frame desc controller bit */
+#define MACTXINTEN		0x04
+#define CRCMODE			0x02
+#define PADDINGMODE		0x01
+
+/* fftcr controller bit */
+#define TXTHD 			(0x03 << 8)
+#define BLENGTH			(0x01 << 20)
+
+/* global setting for driver */
+#define RX_DESC_SIZE	32
+#define TX_DESC_SIZE	32
+#define MAX_RBUFF_SZ	0x600
+#define MAX_TBUFF_SZ	0x600
+#define TX_TIMEOUT	50
+#define DELAY		1000
+#define CAM0		0x0
+
+#define MII_TIMEOUT	100
+
+#define ETH_TRIGGER_RX	do{__raw_writel(ENSTART, REG_RSDR);}while(0)
+#define ETH_TRIGGER_TX	do{__raw_writel(ENSTART, REG_TSDR);}while(0)
+#define ETH_ENABLE_TX	do{__raw_writel(__raw_readl( REG_MCMDR) | MCMDR_TXON, REG_MCMDR);}while(0)
+#define ETH_ENABLE_RX	do{__raw_writel(__raw_readl( REG_MCMDR) | MCMDR_RXON, REG_MCMDR);}while(0)
+#define ETH_DISABLE_TX	do{__raw_writel(__raw_readl( REG_MCMDR) & ~MCMDR_TXON, REG_MCMDR);}while(0)
+#define ETH_DISABLE_RX	do{__raw_writel(__raw_readl( REG_MCMDR) & ~MCMDR_RXON, REG_MCMDR);}while(0)
+
+struct nuc970_rxbd {
+	unsigned int sl;
+	unsigned int buffer;
+	unsigned int reserved;
+	unsigned int next;
+};
+
+struct nuc970_txbd {
+	unsigned int mode;
+	unsigned int buffer;
+	unsigned int sl;
+	unsigned int next;
+};
+
+u8 nuc970_mac1[6] = { 0x08, 0x00, 0x27, 0x00, 0x01, 0x93 };
+
+static struct sk_buff *rx_skb[RX_DESC_SIZE];
+static struct sk_buff *tx_skb[TX_DESC_SIZE];
+
+struct  nuc970_ether {
+	spinlock_t lock;
+	struct nuc970_rxbd *rdesc;
+	struct nuc970_txbd *tdesc;
+	dma_addr_t rdesc_phys;
+	dma_addr_t tdesc_phys;
+	struct net_device_stats stats;
+	struct platform_device *pdev;
+	struct net_device *ndev;
+	struct resource *res;
+	//struct sk_buff *skb;
+	struct clk *clk;
+	struct clk *eclk;
+	unsigned int msg_enable;
+	struct mii_bus *mii_bus;
+	struct phy_device *phy_dev;
+	struct napi_struct napi;
+	int rxirq;
+	int txirq;
+	unsigned int cur_tx;
+	unsigned int cur_rx;
+	unsigned int finish_tx;
+	//unsigned int rx_packets;
+	//unsigned int rx_bytes;
+	unsigned int start_tx_ptr;
+	unsigned int start_rx_ptr;
+	int link;
+	int speed;
+	int duplex;
+	int wol;
+};
+
+
+static __init int setup_macaddr(char *str)
+{
+	u8 mac[6] = {0, 0, 0, 0, 0, 0};
+	char *c = str;
+	int i, j;
+
+	if (!str)
+		goto err;
+
+	for(i = 0; i < 6; i++) {
+		for(j = 0; j < 2; j++) {
+			mac[i] <<= 4;
+			if(isdigit(*c))
+				mac[i] += *c - '0';
+			else if(isxdigit(*c))
+				mac[i] += toupper(*c) - 'A' + 10;
+			else {
+				goto err;
+			}
+			c++;
+		}
+
+		if(i != 5)
+			if(*c != ':') {
+				goto err;
+			}
+
+		c++;
+	}
+
+	// all good
+	for(i = 0; i < 6; i++) {
+		nuc970_mac1[i] = mac[i];
+
+	}
+	return 0;
+
+err:
+	return -EINVAL;
+}
+early_param("ethaddr1", setup_macaddr);
+
+static void adjust_link(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct phy_device *phydev = ether->phy_dev;
+	unsigned int val;
+	bool status_change = false;
+	unsigned long flags;
+
+	// clear GPIO interrupt status which indicates PHY status change?
+
+	spin_lock_irqsave(&ether->lock, flags);
+
+	if (phydev->link) {
+		if ((ether->speed != phydev->speed) ||
+		    (ether->duplex != phydev->duplex)) {
+			ether->speed = phydev->speed;
+			ether->duplex = phydev->duplex;
+			status_change = true;
+		}
+	} else {
+		// disable tx/rx
+		__raw_writel(__raw_readl( REG_MCMDR) & ~(MCMDR_RXON | MCMDR_TXON), REG_MCMDR);
+		ether->speed = 0;
+		ether->duplex = -1;
+	}
+
+	if (phydev->link != ether->link) {
+
+		ether->link = phydev->link;
+		if(phydev->link)
+			status_change = true;
+	}
+
+	spin_unlock_irqrestore(&ether->lock, flags);
+
+	if (status_change) {
+
+		val = __raw_readl( REG_MCMDR) | MCMDR_RXON | MCMDR_TXON;
+
+		if (ether->speed == 100) {
+			val |= MCMDR_OPMOD;
+		} else {
+			val &= ~MCMDR_OPMOD;
+		}
+
+		if(ether->duplex == DUPLEX_FULL) {
+			val |= MCMDR_FDUP;
+		} else {
+			val &= ~MCMDR_FDUP;
+		}
+
+		__raw_writel(val,  REG_MCMDR);
+		ETH_TRIGGER_TX; // in case some packets queued in descriptor
+	}
+}
+
+
+
+static void nuc970_write_cam(struct net_device *dev,
+				unsigned int x, unsigned char *pval)
+{
+	unsigned int msw, lsw;
+
+	msw = (pval[0] << 24) | (pval[1] << 16) | (pval[2] << 8) | pval[3];
+
+	lsw = (pval[4] << 24) | (pval[5] << 16);
+
+	__raw_writel(lsw,  REG_CAML_BASE + x * CAM_ENTRY_SIZE);
+	__raw_writel(msw,  REG_CAMM_BASE + x * CAM_ENTRY_SIZE);
+}
+
+
+static struct sk_buff * get_new_skb(struct net_device *dev, u32 i) {
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct sk_buff *skb = dev_alloc_skb(2048);
+
+	if (skb == NULL)
+		return NULL;
+
+	skb->dev = dev;
+
+	(ether->rdesc + i)->buffer = dma_map_single(&dev->dev, skb->data,
+							2048, DMA_FROM_DEVICE);
+	rx_skb[i] = skb;
+
+	return skb;
+}
+
+static int nuc970_init_desc(struct net_device *dev)
+{
+	struct nuc970_ether *ether;
+	struct nuc970_txbd  *tdesc;
+	struct nuc970_rxbd  *rdesc;
+	struct platform_device *pdev;
+	unsigned int i;
+
+	ether = netdev_priv(dev);
+	pdev = ether->pdev;
+
+	ether->tdesc = (struct nuc970_txbd *)
+			dma_alloc_coherent(&pdev->dev, sizeof(struct nuc970_txbd) * TX_DESC_SIZE,
+						&ether->tdesc_phys, GFP_KERNEL);
+
+	if (!ether->tdesc) {
+		dev_err(&pdev->dev, "Failed to allocate memory for tx desc\n");
+		return -ENOMEM;
+	}
+
+	ether->rdesc = (struct nuc970_rxbd *)
+			dma_alloc_coherent(&pdev->dev, sizeof(struct nuc970_rxbd) * RX_DESC_SIZE,
+						&ether->rdesc_phys, GFP_KERNEL);
+
+	if (!ether->rdesc) {
+		dev_err(&pdev->dev, "Failed to allocate memory for rx desc\n");
+		dma_free_coherent(&pdev->dev, sizeof(struct nuc970_txbd) * TX_DESC_SIZE,
+						ether->tdesc, ether->tdesc_phys);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < TX_DESC_SIZE; i++) {
+		unsigned int offset;
+
+		tx_skb[i] = NULL;
+		tdesc = (ether->tdesc + i);
+
+		if (i == TX_DESC_SIZE - 1)
+			offset = 0;
+		else
+			offset = sizeof(struct nuc970_txbd) * (i + 1);
+
+		tdesc->next = ether->tdesc_phys + offset;
+		tdesc->buffer = (unsigned int)NULL;
+		tdesc->sl = 0;
+		tdesc->mode = PADDINGMODE | CRCMODE | MACTXINTEN;
+	}
+
+	ether->start_tx_ptr = ether->tdesc_phys;
+
+	for (i = 0; i < RX_DESC_SIZE; i++) {
+		unsigned int offset;
+
+		rdesc = (ether->rdesc + i);
+
+		if (i == RX_DESC_SIZE - 1)
+			offset = 0;
+		else
+			offset = sizeof(struct nuc970_rxbd) * (i + 1);
+
+		rdesc->next = ether->rdesc_phys + offset;
+		rdesc->sl = RX_OWEN_DMA;
+		if(get_new_skb(dev, i) == NULL) {
+			dma_free_coherent(&pdev->dev, sizeof(struct nuc970_txbd) * TX_DESC_SIZE,
+						ether->tdesc, ether->tdesc_phys);
+			dma_free_coherent(&pdev->dev, sizeof(struct nuc970_rxbd) * RX_DESC_SIZE,
+						ether->rdesc, ether->rdesc_phys);
+
+			for(; i != 0; i--) {
+				dma_unmap_single(&dev->dev, (dma_addr_t)((ether->rdesc + i)->buffer),
+							2048, DMA_FROM_DEVICE);
+				dev_kfree_skb_any(rx_skb[i]);
+			}
+			return -ENOMEM;
+		}
+	}
+
+	ether->start_rx_ptr = ether->rdesc_phys;
+
+	return 0;
+}
+
+// This API must call with Tx/Rx stopped
+static void nuc970_free_desc(struct net_device *dev)
+{
+	struct sk_buff *skb;
+	u32 i;
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct platform_device *pdev = ether->pdev;
+
+	for (i = 0; i < TX_DESC_SIZE; i++) {
+		skb = tx_skb[i];
+		if(skb != NULL) {
+			dma_unmap_single(&dev->dev, (dma_addr_t)((ether->tdesc + i)->buffer), skb->len, DMA_TO_DEVICE);
+			dev_kfree_skb_any(skb);
+		}
+	}
+
+	for (i = 0; i < RX_DESC_SIZE; i++) {
+		skb = rx_skb[i];
+		if(skb != NULL) {
+			dma_unmap_single(&dev->dev, (dma_addr_t)((ether->rdesc + i)->buffer), 2048, DMA_FROM_DEVICE);
+			dev_kfree_skb_any(skb);
+		}
+	}
+
+	dma_free_coherent(&pdev->dev, sizeof(struct nuc970_txbd) * TX_DESC_SIZE,
+				ether->tdesc, ether->tdesc_phys);
+	dma_free_coherent(&pdev->dev, sizeof(struct nuc970_rxbd) * RX_DESC_SIZE,
+				ether->rdesc, ether->rdesc_phys);
+
+}
+
+static void nuc970_set_fifo_threshold(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = TXTHD | BLENGTH;
+	__raw_writel(val,  REG_FFTCR);
+}
+
+static void nuc970_return_default_idle(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = __raw_readl( REG_MCMDR);
+	val |= SWR;
+	__raw_writel(val,  REG_MCMDR);
+}
+
+
+static void nuc970_enable_mac_interrupt(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = ENTXINTR | ENRXINTR | ENRXGD | ENTXCP | ENRDU;
+	val |= ENTXBERR | ENRXBERR | ENTXABT | ENWOL;
+
+	__raw_writel(val,  REG_MIEN);
+}
+
+static void nuc970_get_and_clear_int(struct net_device *dev,
+							unsigned int *val, unsigned int mask)
+{
+	*val = __raw_readl( REG_MISTA) & mask;
+	__raw_writel(*val,  REG_MISTA);
+}
+
+static void nuc970_set_global_maccmd(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = __raw_readl( REG_MCMDR);
+	val |= MCMDR_SPCRC | /*MCMDR_ENMDC |*/ MCMDR_ACP /*| ENMDC*/;
+	__raw_writel(val,  REG_MCMDR);
+}
+
+static void nuc970_enable_cam(struct net_device *dev)
+{
+	unsigned int val;
+
+	nuc970_write_cam(dev, CAM0, dev->dev_addr);
+
+	val = __raw_readl( REG_CAMEN);
+	val |= CAM0EN;
+	__raw_writel(val,  REG_CAMEN);
+}
+
+static void nuc970_enable_cam_command(struct net_device *dev)
+{
+	unsigned int val;
+
+	val = CAMCMR_ECMP | CAMCMR_ABP | CAMCMR_AMP;
+	__raw_writel(val,  REG_CAMCMR);
+}
+
+
+static void nuc970_set_curdest(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	__raw_writel(ether->start_rx_ptr,  REG_RXDLSA);
+	__raw_writel(ether->start_tx_ptr,  REG_TXDLSA);
+}
+
+static void nuc970_reset_mac(struct net_device *dev, int need_free)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	ETH_DISABLE_TX;
+	ETH_DISABLE_RX;;
+
+	nuc970_return_default_idle(dev);
+	nuc970_set_fifo_threshold(dev);
+
+	if (!netif_queue_stopped(dev))
+		netif_stop_queue(dev);
+
+	if(need_free)
+		nuc970_free_desc(dev);
+	nuc970_init_desc(dev);
+
+	//dev->trans_start = jiffies; /* prevent tx timeout */
+	ether->cur_tx = 0x0;
+	ether->finish_tx = 0x0;
+	ether->cur_rx = 0x0;
+
+	nuc970_set_curdest(dev);
+	nuc970_enable_cam(dev);
+	nuc970_enable_cam_command(dev);
+	nuc970_enable_mac_interrupt(dev);
+	ETH_ENABLE_TX;
+	ETH_ENABLE_RX;
+
+	ETH_TRIGGER_RX;
+
+	dev->trans_start = jiffies; /* prevent tx timeout */
+
+	if (netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+}
+
+static int nuc970_mdio_write(struct mii_bus *bus, int phy_id, int regnum,
+		u16 value)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(MII_TIMEOUT * 100);
+
+	__raw_writel(value,  REG_MIID);
+	__raw_writel((phy_id << 0x08) | regnum | PHYBUSY | MDCON | PHYWR,  REG_MIIDA);
+
+
+	/* Wait for completion */
+	while (__raw_readl( REG_MIIDA) & PHYBUSY) {
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		cpu_relax();
+	}
+
+	return 0;
+
+}
+
+static int nuc970_mdio_read(struct mii_bus *bus, int phy_id, int regnum)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(MII_TIMEOUT * 100);
+
+
+	__raw_writel((phy_id << 0x08) | regnum | PHYBUSY | MDCON,  REG_MIIDA);
+
+	/* Wait for completion */
+	while (__raw_readl( REG_MIIDA) & PHYBUSY) {
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		cpu_relax();
+	}
+
+	return __raw_readl(REG_MIID);
+}
+
+static int nuc970_mdio_reset(struct mii_bus *bus)
+{
+
+	// reser ENAC engine??
+	return 0;
+}
+
+static int nuc970_set_mac_address(struct net_device *dev, void *addr)
+{
+	struct sockaddr *address = addr;
+
+	if (!is_valid_ether_addr(address->sa_data))
+		return -EADDRNOTAVAIL;
+
+	memcpy(dev->dev_addr, address->sa_data, dev->addr_len);
+	nuc970_write_cam(dev, CAM0, dev->dev_addr);
+
+	return 0;
+}
+
+static int nuc970_ether_close(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct platform_device *pdev;
+
+	pdev = ether->pdev;
+
+	ETH_DISABLE_TX;
+	ETH_DISABLE_RX;
+	netif_stop_queue(dev);
+	napi_disable(&ether->napi);
+	free_irq(ether->txirq, dev);
+	free_irq(ether->rxirq, dev);
+
+	nuc970_return_default_idle(dev);
+	nuc970_free_desc(dev);
+
+	if (ether->phy_dev)
+		phy_stop(ether->phy_dev);
+
+	return 0;
+}
+
+static struct net_device_stats *nuc970_ether_stats(struct net_device *dev)
+{
+	struct nuc970_ether *ether;
+
+	ether = netdev_priv(dev);
+
+	return &ether->stats;
+}
+
+
+static int nuc970_ether_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct nuc970_txbd *txbd;
+
+	txbd = ether->tdesc + ether->cur_tx;
+	if(txbd->mode & TX_OWEN_DMA) {
+		netif_stop_queue(dev);
+		return NETDEV_TX_BUSY;
+	}
+
+	txbd->buffer = dma_map_single(&dev->dev, skb->data,
+					skb->len, DMA_TO_DEVICE);
+
+	tx_skb[ether->cur_tx]  = skb;
+	txbd->sl = skb->len > 1514 ? 1514 : skb->len;
+	wmb();	// This is dummy function for ARM9
+	txbd->mode |= TX_OWEN_DMA;
+	wmb();	// This is dummy function for ARM9
+
+	ETH_TRIGGER_TX;
+
+	if (++ether->cur_tx >= TX_DESC_SIZE)
+		ether->cur_tx = 0;
+	txbd = ether->tdesc + ether->cur_tx;
+	if(txbd->mode & TX_OWEN_DMA) {
+		netif_stop_queue(dev);
+		//return NETDEV_TX_BUSY;
+	}
+	return NETDEV_TX_OK;
+}
+
+static irqreturn_t nuc970_tx_interrupt(int irq, void *dev_id)
+{
+	struct nuc970_ether *ether;
+	struct platform_device *pdev;
+	struct net_device *dev;
+	unsigned int status;
+	struct sk_buff *s;
+	struct nuc970_txbd *txbd;
+
+	dev = dev_id;
+	ether = netdev_priv(dev);
+	pdev = ether->pdev;
+
+	nuc970_get_and_clear_int(dev, &status, 0xFFFF0000);
+
+	txbd = ether->tdesc + ether->finish_tx;
+	while((txbd->mode & TX_OWEN_DMA) != TX_OWEN_DMA) {
+		if((s = tx_skb[ether->finish_tx]) != NULL) {
+			dma_unmap_single(&dev->dev, txbd->buffer, s->len, DMA_TO_DEVICE);
+			dev_kfree_skb_irq(s);
+			tx_skb[ether->finish_tx] = NULL;
+			if (txbd->sl & TXDS_TXCP) {
+				ether->stats.tx_packets++;
+				ether->stats.tx_bytes += (txbd->sl & 0xFFFF);
+			} else {
+				ether->stats.tx_errors++;
+			}
+		} else
+			break;
+		ether->finish_tx = (ether->finish_tx + 1) % TX_DESC_SIZE;
+		txbd = ether->tdesc + ether->finish_tx;	
+	}
+
+	if (status & MISTA_EXDEF) {
+		dev_err(&pdev->dev, "emc defer exceed interrupt\n");
+	} else if (status & MISTA_TXBERR) {
+		dev_err(&pdev->dev, "emc bus error interrupt\n");
+		nuc970_reset_mac(dev, 1);
+	}
+
+	if (netif_queue_stopped(dev)) {
+		netif_wake_queue(dev);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int nuc970_poll(struct napi_struct *napi, int budget)
+{
+	struct nuc970_ether *ether = container_of(napi, struct nuc970_ether, napi);
+	struct nuc970_rxbd *rxbd;
+	struct net_device *dev = ether->ndev;
+	struct sk_buff *skb, *s;
+	unsigned int length, status;
+	int rx_cnt = 0;
+	int complete = 0;
+
+	rxbd = (ether->rdesc + ether->cur_rx);
+
+	while(rx_cnt < budget) {
+
+		if((rxbd->sl & RX_OWEN_DMA) == RX_OWEN_DMA) {
+			complete = 1;
+			break;
+		}
+
+		s = rx_skb[ether->cur_rx];
+		status = rxbd->sl;
+		length = status & 0xFFFF;
+
+		if (likely((status & RXDS_RXGD) && (length <= 1514))) {
+
+			skb = dev_alloc_skb(2048);
+			if (!skb) {
+				struct platform_device *pdev = ether->pdev;
+				dev_err(&pdev->dev, "get skb buffer error\n");
+				ether->stats.rx_dropped++;
+				goto rx_out;
+			}
+			dma_unmap_single(&dev->dev, (dma_addr_t)rxbd->buffer, 2048, DMA_FROM_DEVICE);
+
+			skb_put(s, length);
+			s->protocol = eth_type_trans(s, dev);
+			netif_receive_skb(s);
+			ether->stats.rx_packets++;
+			ether->stats.rx_bytes += length;
+
+			skb->dev = dev;
+
+			rxbd->buffer = dma_map_single(&dev->dev, skb->data,
+							2048, DMA_FROM_DEVICE);
+
+			rx_skb[ether->cur_rx] = skb;
+			rx_cnt++;
+
+		} else {
+			ether->stats.rx_errors++;
+
+			if (status & RXDS_RP) {
+				ether->stats.rx_length_errors++;
+			} else if (status & RXDS_CRCE) {
+				ether->stats.rx_crc_errors++;
+			} else if (status & RXDS_ALIE) {
+				ether->stats.rx_frame_errors++;
+			} else if (status & RXDS_PTLE) {
+				ether->stats.rx_over_errors++;
+			}
+		}
+
+		wmb();	// This is dummy function for ARM9
+		rxbd->sl = RX_OWEN_DMA;
+
+		if (++ether->cur_rx >= RX_DESC_SIZE)
+			ether->cur_rx = 0;
+
+		rxbd = (ether->rdesc + ether->cur_rx);
+
+	}
+
+	if(complete) {
+		napi_complete(napi); //Change from __napi_complete(napi); by tanshi li for 'ifconfig eth1 down' error"
+		__raw_writel(__raw_readl(REG_MIEN) | ENRXINTR,  REG_MIEN);
+	}
+
+rx_out:
+
+	ETH_TRIGGER_RX;
+	return(rx_cnt);
+}
+
+static irqreturn_t nuc970_rx_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct nuc970_ether *ether = netdev_priv(dev);
+	unsigned int status;
+
+	nuc970_get_and_clear_int(dev, &status, 0xFFFF);
+
+	if (unlikely(status & MISTA_RXBERR)) {
+		struct platform_device *pdev = ether->pdev;
+
+		dev_err(&pdev->dev, "emc rx bus error\n");
+		nuc970_reset_mac(dev, 1);
+
+	} else {
+		if(status & MISTA_WOL) {
+
+		}
+
+		if(status & MISTA_RXGD) {
+			__raw_writel(__raw_readl(REG_MIEN) & ~ENRXINTR,  REG_MIEN);
+			napi_schedule(&ether->napi);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+
+static int nuc970_ether_open(struct net_device *dev)
+{
+	struct nuc970_ether *ether;
+	struct platform_device *pdev;
+
+	ether = netdev_priv(dev);
+	pdev = ether->pdev;
+
+	nuc970_reset_mac(dev, 0);
+	nuc970_set_fifo_threshold(dev);
+	nuc970_set_curdest(dev);
+	nuc970_enable_cam(dev);
+	nuc970_enable_cam_command(dev);
+	nuc970_enable_mac_interrupt(dev);
+	nuc970_set_global_maccmd(dev);
+	ETH_ENABLE_RX;
+
+
+	if (request_irq(ether->txirq, nuc970_tx_interrupt,
+						0x0, pdev->name, dev)) {
+		dev_err(&pdev->dev, "register irq tx failed\n");
+		return -EAGAIN;
+	}
+
+	if (request_irq(ether->rxirq, nuc970_rx_interrupt,
+						IRQF_NO_SUSPEND, pdev->name, dev)) {
+		dev_err(&pdev->dev, "register irq rx failed\n");
+		free_irq(ether->txirq, dev);
+		return -EAGAIN;
+	}
+
+	phy_start(ether->phy_dev);
+	netif_start_queue(dev);
+	napi_enable(&ether->napi);
+
+	ETH_TRIGGER_RX;
+
+	dev_info(&pdev->dev, "%s is OPENED\n", dev->name);
+
+	return 0;
+}
+
+static void nuc970_ether_set_multicast_list(struct net_device *dev)
+{
+	struct nuc970_ether *ether;
+	unsigned int rx_mode;
+
+	ether = netdev_priv(dev);
+
+	if (dev->flags & IFF_PROMISC)
+		rx_mode = CAMCMR_AUP | CAMCMR_AMP | CAMCMR_ABP | CAMCMR_ECMP;
+	else if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev))
+		rx_mode = CAMCMR_AMP | CAMCMR_ABP | CAMCMR_ECMP;
+	else
+		rx_mode = CAMCMR_ECMP | CAMCMR_ABP;
+	__raw_writel(rx_mode,  REG_CAMCMR);
+}
+
+static int nuc970_ether_ioctl(struct net_device *dev,
+						struct ifreq *ifr, int cmd)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct phy_device *phydev = ether->phy_dev;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;;
+
+	return phy_mii_ioctl(phydev, ifr, cmd);
+}
+
+static void nuc970_get_drvinfo(struct net_device *dev,
+					struct ethtool_drvinfo *info)
+{
+	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
+	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
+	strlcpy(info->fw_version, "N/A", sizeof(info->fw_version));
+	strlcpy(info->bus_info, "N/A", sizeof(info->bus_info));
+}
+
+static int nuc970_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct phy_device *phydev = ether->phy_dev;
+
+	if (NULL == phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int nuc970_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct phy_device *phydev = ether->phy_dev;
+
+	if (NULL == phydev)
+		return -ENODEV;
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static u32 nuc970_get_msglevel(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	return ether->msg_enable;
+}
+
+static void nuc970_set_msglevel(struct net_device *dev, u32 level)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	ether->msg_enable = level;
+}
+
+static int nuc970_get_eee(struct net_device *dev, struct ethtool_eee *edata)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nuc970_set_eee(struct net_device *dev, struct ethtool_eee *edata)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nuc970_get_regs_len(struct net_device *dev)
+{
+	return 76 * sizeof(u32);
+}
+
+static void nuc970_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)
+{
+
+	regs->version = 0;
+	memcpy(p, REG_CAMCMR, 76 * sizeof(u32));
+}
+
+#ifdef CONFIG_PM
+static void nuc970_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	wol->supported = WAKE_MAGIC;
+	wol->wolopts = ether->wol ? WAKE_MAGIC : 0;
+
+}
+
+static int nuc970_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	if (wol->wolopts & ~WAKE_MAGIC)
+		return -EINVAL;
+
+	ether->wol = wol->wolopts & WAKE_MAGIC ? 1 : 0;
+
+	device_set_wakeup_capable(&dev->dev, wol->wolopts & WAKE_MAGIC);
+	device_set_wakeup_enable(&dev->dev, wol->wolopts & WAKE_MAGIC);
+
+	return 0;
+}
+#endif
+
+static int nuc970_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)
+{
+	info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
+				SOF_TIMESTAMPING_RX_HARDWARE |
+				SOF_TIMESTAMPING_RAW_HARDWARE;
+	info->phc_index = 0;
+	info->tx_types = (1 << HWTSTAMP_TX_OFF) |
+			 (1 << HWTSTAMP_TX_ON);
+	info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+			   (1 << HWTSTAMP_FILTER_ALL);
+	return 0;
+}
+
+static const struct ethtool_ops nuc970_ether_ethtool_ops = {
+	.get_settings	= nuc970_get_settings,
+	.set_settings	= nuc970_set_settings,
+	.get_drvinfo	= nuc970_get_drvinfo,
+	.get_msglevel	= nuc970_get_msglevel,
+	.set_msglevel	= nuc970_set_msglevel,
+	.get_link 	= ethtool_op_get_link,
+	.get_eee	= nuc970_get_eee,
+	.set_eee	= nuc970_set_eee,
+	.get_regs_len	= nuc970_get_regs_len,
+	.get_regs	= nuc970_get_regs,
+#ifdef CONFIG_PM
+	.get_wol 	= nuc970_get_wol,
+	.set_wol 	= nuc970_set_wol,
+#endif
+	.get_ts_info	= nuc970_get_ts_info,
+};
+
+static const struct net_device_ops nuc970_ether_netdev_ops = {
+	.ndo_open		= nuc970_ether_open,
+	.ndo_stop		= nuc970_ether_close,
+	.ndo_start_xmit		= nuc970_ether_start_xmit,
+	.ndo_get_stats		= nuc970_ether_stats,
+	.ndo_set_rx_mode	= nuc970_ether_set_multicast_list,
+	.ndo_set_mac_address	= nuc970_set_mac_address,
+	.ndo_do_ioctl		= nuc970_ether_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_change_mtu		= eth_change_mtu,
+};
+
+static void __init get_mac_address(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct platform_device *pdev;
+
+	pdev = ether->pdev;
+
+	if (is_valid_ether_addr(nuc970_mac1))
+		memcpy(dev->dev_addr, &nuc970_mac1[0], 0x06);
+	else
+		dev_err(&pdev->dev, "invalid mac address\n");
+}
+
+
+static int nuc970_mii_setup(struct net_device *dev)
+{
+	struct nuc970_ether *ether = netdev_priv(dev);
+	struct platform_device *pdev;
+	struct phy_device *phydev;
+	int i, err = 0;
+
+	pdev = ether->pdev;
+
+	ether->mii_bus = mdiobus_alloc();
+	if (!ether->mii_bus) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev, "mdiobus_alloc() failed\n");
+		goto out0;
+	}
+
+	ether->mii_bus->name = "nuc970_rmii1";
+	ether->mii_bus->read = &nuc970_mdio_read;
+	ether->mii_bus->write = &nuc970_mdio_write;
+	ether->mii_bus->reset = &nuc970_mdio_reset;
+	snprintf(ether->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
+		 ether->pdev->name, ether->pdev->id);
+	ether->mii_bus->priv = ether;
+	ether->mii_bus->parent = &ether->pdev->dev;
+
+	ether->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	if (!ether->mii_bus->irq) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev, "kmalloc() failed\n");
+		goto out1;
+
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		ether->mii_bus->irq[i] = PHY_POLL;
+	//ether->mii_bus->irq[1] = ??   write me after the irq number is known
+
+	if (mdiobus_register(ether->mii_bus)) {
+		dev_err(&pdev->dev, "mdiobus_register() failed\n");
+		goto out2;
+	}
+
+	phydev = phy_find_first(ether->mii_bus);
+	if(phydev == NULL) {
+		err = -ENODEV;
+		dev_err(&pdev->dev, "phy_find_first() failed\n");
+		goto out3;
+	}
+
+	phydev = phy_connect(dev, dev_name(&phydev->dev),
+			     &adjust_link,
+			     PHY_INTERFACE_MODE_RMII);
+
+	if(IS_ERR(phydev)) {
+		err = PTR_ERR(phydev);
+		dev_err(&pdev->dev, "phy_connect() failed\n");
+		goto out3;
+	}
+
+	phydev->supported &= PHY_BASIC_FEATURES;
+	phydev->advertising = phydev->supported;
+	ether->phy_dev = phydev;
+	ether->wol = 0;
+
+	return 0;
+
+out3:
+	mdiobus_unregister(ether->mii_bus);
+out2:
+	kfree(ether->mii_bus->irq);
+out1:
+	mdiobus_free(ether->mii_bus);
+out0:
+
+	return err;
+}
+
+static int nuc970_ether_probe(struct platform_device *pdev)
+{
+	struct nuc970_ether *ether;
+	struct net_device *dev;
+	int error;
+#ifdef CONFIG_OF
+	struct pinctrl *pinctrl;
+#endif
+
+	dev = alloc_etherdev(sizeof(struct nuc970_ether));
+	if (!dev)
+		return -ENOMEM;
+
+	ether = netdev_priv(dev);
+
+	ether->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (ether->res == NULL) {
+		dev_err(&pdev->dev, "failed to get I/O memory\n");
+		error = -ENXIO;
+		goto err0;
+	}
+
+#ifdef CONFIG_OF
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		return PTR_ERR(pinctrl);
+	}
+#endif
+
+	ether->txirq = platform_get_irq(pdev, 0);
+	if (ether->txirq < 0) {
+		dev_err(&pdev->dev, "failed to get ether tx irq\n");
+		error = -ENXIO;
+		goto err0;
+	}
+
+	ether->rxirq = platform_get_irq(pdev, 1);
+	if (ether->rxirq < 0) {
+		dev_err(&pdev->dev, "failed to get ether rx irq\n");
+		error = -ENXIO;
+		goto err0;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	platform_set_drvdata(pdev, dev);
+	ether->ndev = dev;
+
+	ether->eclk = clk_get(NULL, "emac1_eclk");
+	if (IS_ERR(ether->eclk)) {
+		dev_err(&pdev->dev, "failed to get emac1_eclk clock\n");
+		error = PTR_ERR(ether->eclk);
+		goto err1;
+	}
+
+	// Set MDC to 1M
+	clk_set_rate(ether->eclk, 1000000);
+
+	clk_prepare(ether->eclk);
+	clk_enable(ether->eclk);
+
+	ether->clk = clk_get(NULL, "emac1_hclk");
+	if (IS_ERR(ether->clk)) {
+		dev_err(&pdev->dev, "failed to get emac1_hclk clock\n");
+		error = PTR_ERR(ether->clk);
+		goto err1;
+	}
+
+	clk_prepare(ether->clk);
+	clk_enable(ether->clk);
+
+	ether->pdev = pdev;
+	ether->msg_enable = NETIF_MSG_LINK;
+
+	dev->netdev_ops = &nuc970_ether_netdev_ops;
+	dev->ethtool_ops = &nuc970_ether_ethtool_ops;
+
+	dev->tx_queue_len = 32;  //16
+	dev->dma = 0x0;
+	dev->watchdog_timeo = TX_TIMEOUT;
+
+	get_mac_address(dev);
+
+	ether->cur_tx = 0x0;
+	ether->cur_rx = 0x0;
+	ether->finish_tx = 0x0;
+	ether->link = 0;
+	ether->speed = 100;
+	ether->duplex = DUPLEX_FULL;
+	spin_lock_init(&ether->lock);
+
+	netif_napi_add(dev, &ether->napi, nuc970_poll, /*16*/32);
+
+	ether_setup(dev);
+
+	if((error = nuc970_mii_setup(dev)) < 0) {
+		dev_err(&pdev->dev, "nuc970_mii_setup err\n");
+		goto err2;
+	}
+	netif_carrier_off(dev);
+	error = register_netdev(dev);
+	if (error != 0) {
+		dev_err(&pdev->dev, "register_netdev() failed\n");
+		error = -ENODEV;
+		goto err2;
+	}
+
+	return 0;
+
+err2:
+	clk_disable(ether->clk);
+	clk_put(ether->clk);
+err1:
+	platform_set_drvdata(pdev, NULL);
+err0:
+	free_netdev(dev);
+
+	return error;
+}
+
+static int nuc970_ether_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	unregister_netdev(dev);
+
+	clk_disable(ether->clk);
+	clk_put(ether->clk);
+
+	clk_disable(ether->eclk);
+	clk_put(ether->eclk);
+
+	free_irq(ether->txirq, dev);
+	free_irq(ether->rxirq, dev);
+	phy_disconnect(ether->phy_dev);
+
+	mdiobus_unregister(ether->mii_bus);
+	kfree(ether->mii_bus->irq);
+	mdiobus_free(ether->mii_bus);
+
+	platform_set_drvdata(pdev, NULL);
+
+	free_netdev(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int nuc970_ether_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	netif_device_detach(dev);
+
+	if(netif_running(dev)) {
+		ETH_DISABLE_TX;
+		ETH_DISABLE_RX;
+
+		napi_disable(&ether->napi);
+
+		if(ether->wol) {  // enable wakeup from magic packet
+			__raw_writel(__raw_readl(REG_MCMDR) | MCMDR_MGPWAKE, REG_MCMDR);
+			__raw_writel(__raw_readl(REG_WKUPSER) | (1 << 16), REG_WKUPSER);
+		} else {
+			phy_stop(ether->phy_dev);
+		}
+
+	}
+
+	return 0;
+
+}
+
+static int nuc970_ether_resume(struct platform_device *pdev)
+{
+
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct nuc970_ether *ether = netdev_priv(dev);
+
+	if (netif_running(dev)) {
+
+		if(ether->wol) {  // enable wakeup from magic packet
+			__raw_writel(__raw_readl(REG_WKUPSER) & ~(1 << 17), REG_WKUPSER);
+			__raw_writel(__raw_readl(REG_MCMDR) & ~MCMDR_MGPWAKE, REG_MCMDR);
+		} else {
+
+			phy_start(ether->phy_dev);
+		}
+
+		napi_enable(&ether->napi);
+
+		ETH_ENABLE_TX;
+		ETH_ENABLE_RX;
+
+	}
+
+	netif_device_attach(dev);
+	return 0;
+
+}
+
+#else
+#define nuc970_ether_suspend NULL
+#define nuc970_ether_resume NULL
+#endif
+
+static const struct of_device_id nuc970_emac1_of_match[] = {
+	{ .compatible = "nuvoton,nuc970-emac1" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nuc970_emac1_of_match);
+
+static struct platform_driver nuc970_ether_driver = {
+	.probe		= nuc970_ether_probe,
+	.remove		= nuc970_ether_remove,
+	.suspend 	= nuc970_ether_suspend,
+	.resume 	= nuc970_ether_resume,
+	.driver		= {
+		.name	= "nuc970-emac1",
+	    .of_match_table = of_match_ptr(nuc970_emac1_of_match),
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init nuc970_ether_init(void)
+{
+
+	return platform_driver_register(&nuc970_ether_driver);
+}
+
+static void __exit nuc970_ether_exit(void)
+{
+	platform_driver_unregister(&nuc970_ether_driver);
+}
+
+module_init(nuc970_ether_init);
+module_exit(nuc970_ether_exit);
+
+MODULE_AUTHOR("Nuvoton Technology Corp.");
+MODULE_DESCRIPTION("NUC970 MAC1 driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nuc970-emac1");
+
Index: linux-4.4.92/drivers/pinctrl/Kconfig
===================================================================
--- linux-4.4.92.orig/drivers/pinctrl/Kconfig
+++ linux-4.4.92/drivers/pinctrl/Kconfig
@@ -53,6 +53,14 @@ config PINCTRL_BF60x
 	def_bool y if BF60x
 	select PINCTRL_ADI2
 
+config PINCTRL_NUC970
+	bool "NUC970 pinctrl driver"
+	depends on ARCH_NUC970
+	select PINMUX
+	select PINCONF
+	help
+	  Say Y here to enable NUC970 pinctrl driver
+
 config PINCTRL_AT91
 	bool "AT91 pinctrl driver"
 	depends on OF
Index: linux-4.4.92/drivers/pinctrl/Makefile
===================================================================
--- linux-4.4.92.orig/drivers/pinctrl/Makefile
+++ linux-4.4.92/drivers/pinctrl/Makefile
@@ -35,6 +35,11 @@ obj-$(CONFIG_PINCTRL_U300)	+= pinctrl-u3
 obj-$(CONFIG_PINCTRL_COH901)	+= pinctrl-coh901.o
 obj-$(CONFIG_PINCTRL_XWAY)	+= pinctrl-xway.o
 obj-$(CONFIG_PINCTRL_LANTIQ)	+= pinctrl-lantiq.o
+ifeq ($(CONFIG_OF),y)
+obj-$(CONFIG_PINCTRL_NUC970)    += pinctrl-nuc970-dt.o
+else
+obj-$(CONFIG_PINCTRL_NUC970)    += pinctrl-nuc970.o
+endif
 obj-$(CONFIG_PINCTRL_LPC18XX)	+= pinctrl-lpc18xx.o
 obj-$(CONFIG_PINCTRL_TB10X)	+= pinctrl-tb10x.o
 obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
Index: linux-4.4.92/drivers/pinctrl/pinctrl-nuc970-dt.c
===================================================================
--- /dev/null
+++ linux-4.4.92/drivers/pinctrl/pinctrl-nuc970-dt.c
@@ -0,0 +1,742 @@
+/*
+ * Copyright (c) 2017 Nuvoton Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+
+#include <mach/map.h>
+#include <mach/regs-gcr.h>
+
+#include "core.h"
+
+#define DEBUG
+
+#define MAX_NB_GPIO_PER_BANK        16
+
+// The numbering is not related to actual layout.
+const struct pinctrl_pin_desc nuc970_pins[] = {
+	PINCTRL_PIN(0x00, "PA0"),
+	PINCTRL_PIN(0x01, "PA1"),
+	PINCTRL_PIN(0x02, "PA2"),
+	PINCTRL_PIN(0x03, "PA3"),
+	PINCTRL_PIN(0x04, "PA4"),
+	PINCTRL_PIN(0x05, "PA5"),
+	PINCTRL_PIN(0x06, "PA6"),
+	PINCTRL_PIN(0x07, "PA7"),
+	PINCTRL_PIN(0x08, "PA8"),
+	PINCTRL_PIN(0x09, "PA9"),
+	PINCTRL_PIN(0x0A, "PA10"),
+	PINCTRL_PIN(0x0B, "PA11"),
+	PINCTRL_PIN(0x0C, "PA12"),
+	PINCTRL_PIN(0x0D, "PA13"),
+	PINCTRL_PIN(0x0E, "PA14"),
+	PINCTRL_PIN(0x0F, "PA15"),
+	PINCTRL_PIN(0x10, "PB0"),
+	PINCTRL_PIN(0x11, "PB1"),
+	PINCTRL_PIN(0x12, "PB2"),
+	PINCTRL_PIN(0x13, "PB3"),
+	PINCTRL_PIN(0x14, "PB4"),
+	PINCTRL_PIN(0x15, "PB5"),
+	PINCTRL_PIN(0x16, "PB6"),
+	PINCTRL_PIN(0x17, "PB7"),
+	PINCTRL_PIN(0x18, "PB8"),
+	PINCTRL_PIN(0x19, "PB9"),
+	PINCTRL_PIN(0x1A, "PB10"),
+	PINCTRL_PIN(0x1B, "PB11"),
+	PINCTRL_PIN(0x1C, "PB12"),
+	PINCTRL_PIN(0x1D, "PB13"),
+	PINCTRL_PIN(0x1E, "PB14"),
+	PINCTRL_PIN(0x1F, "PB15"),
+	PINCTRL_PIN(0x20, "PC0"),
+	PINCTRL_PIN(0x21, "PC1"),
+	PINCTRL_PIN(0x22, "PC2"),
+	PINCTRL_PIN(0x23, "PC3"),
+	PINCTRL_PIN(0x24, "PC4"),
+	PINCTRL_PIN(0x25, "PC5"),
+	PINCTRL_PIN(0x26, "PC6"),
+	PINCTRL_PIN(0x27, "PC7"),
+	PINCTRL_PIN(0x28, "PC8"),
+	PINCTRL_PIN(0x29, "PC9"),
+	PINCTRL_PIN(0x2A, "PC10"),
+	PINCTRL_PIN(0x2B, "PC11"),
+	PINCTRL_PIN(0x2C, "PC12"),
+	PINCTRL_PIN(0x2D, "PC13"),
+	PINCTRL_PIN(0x2E, "PC14"),
+	//PINCTRL_PIN(0x2F, "PC15"),
+	PINCTRL_PIN(0x30, "PD0"),
+	PINCTRL_PIN(0x31, "PD1"),
+	PINCTRL_PIN(0x32, "PD2"),
+	PINCTRL_PIN(0x33, "PD3"),
+	PINCTRL_PIN(0x34, "PD4"),
+	PINCTRL_PIN(0x35, "PD5"),
+	PINCTRL_PIN(0x36, "PD6"),
+	PINCTRL_PIN(0x37, "PD7"),
+	PINCTRL_PIN(0x38, "PD8"),
+	PINCTRL_PIN(0x39, "PD9"),
+	PINCTRL_PIN(0x3A, "PD10"),
+	PINCTRL_PIN(0x3B, "PD11"),
+	PINCTRL_PIN(0x3C, "PD12"),
+	PINCTRL_PIN(0x3D, "PD13"),
+	PINCTRL_PIN(0x3E, "PD14"),
+	PINCTRL_PIN(0x3F, "PD15"),
+	PINCTRL_PIN(0x40, "PE0"),
+	PINCTRL_PIN(0x41, "PE1"),
+	PINCTRL_PIN(0x42, "PE2"),
+	PINCTRL_PIN(0x43, "PE3"),
+	PINCTRL_PIN(0x44, "PE4"),
+	PINCTRL_PIN(0x45, "PE5"),
+	PINCTRL_PIN(0x46, "PE6"),
+	PINCTRL_PIN(0x47, "PE7"),
+	PINCTRL_PIN(0x48, "PE8"),
+	PINCTRL_PIN(0x49, "PE9"),
+	PINCTRL_PIN(0x4A, "PE10"),
+	PINCTRL_PIN(0x4B, "PE11"),
+	PINCTRL_PIN(0x4C, "PE12"),
+	PINCTRL_PIN(0x4D, "PE13"),
+	PINCTRL_PIN(0x4E, "PE14"),
+	PINCTRL_PIN(0x4F, "PE15"),
+	PINCTRL_PIN(0x50, "PF0"),
+	PINCTRL_PIN(0x51, "PF1"),
+	PINCTRL_PIN(0x52, "PF2"),
+	PINCTRL_PIN(0x53, "PF3"),
+	PINCTRL_PIN(0x54, "PF4"),
+	PINCTRL_PIN(0x55, "PF5"),
+	PINCTRL_PIN(0x56, "PF6"),
+	PINCTRL_PIN(0x57, "PF7"),
+	PINCTRL_PIN(0x58, "PF8"),
+	PINCTRL_PIN(0x59, "PF9"),
+	PINCTRL_PIN(0x5A, "PF10"),
+	PINCTRL_PIN(0x5B, "PF11"),
+	PINCTRL_PIN(0x5C, "PF12"),
+	PINCTRL_PIN(0x5D, "PF13"),
+	PINCTRL_PIN(0x5E, "PF14"),
+	PINCTRL_PIN(0x5F, "PF15"),
+	PINCTRL_PIN(0x60, "PG0"),
+	PINCTRL_PIN(0x61, "PG1"),
+	PINCTRL_PIN(0x62, "PG2"),
+	PINCTRL_PIN(0x63, "PG3"),
+	PINCTRL_PIN(0x64, "PG4"),
+	PINCTRL_PIN(0x65, "PG5"),
+	PINCTRL_PIN(0x66, "PG6"),
+	PINCTRL_PIN(0x67, "PG7"),
+	PINCTRL_PIN(0x68, "PG8"),
+	PINCTRL_PIN(0x69, "PG9"),
+	PINCTRL_PIN(0x6A, "PG10"),
+	PINCTRL_PIN(0x6B, "PG11"),
+	PINCTRL_PIN(0x6C, "PG12"),
+	PINCTRL_PIN(0x6D, "PG13"),
+	PINCTRL_PIN(0x6E, "PG14"),
+	PINCTRL_PIN(0x6F, "PG15"),
+	PINCTRL_PIN(0x70, "PH0"),
+	PINCTRL_PIN(0x71, "PH1"),
+	PINCTRL_PIN(0x72, "PH2"),
+	PINCTRL_PIN(0x73, "PH3"),
+	PINCTRL_PIN(0x74, "PH4"),
+	PINCTRL_PIN(0x75, "PH5"),
+	PINCTRL_PIN(0x76, "PH6"),
+	PINCTRL_PIN(0x77, "PH7"),
+	PINCTRL_PIN(0x78, "PH8"),
+	PINCTRL_PIN(0x79, "PH9"),
+	PINCTRL_PIN(0x7A, "PH10"),
+	PINCTRL_PIN(0x7B, "PH11"),
+	PINCTRL_PIN(0x7C, "PH12"),
+	PINCTRL_PIN(0x7D, "PH13"),
+	PINCTRL_PIN(0x7E, "PH14"),
+	PINCTRL_PIN(0x7F, "PH15"),
+	PINCTRL_PIN(0x80, "PI0"),
+	PINCTRL_PIN(0x81, "PI1"),
+	PINCTRL_PIN(0x82, "PI2"),
+	PINCTRL_PIN(0x83, "PI3"),
+	PINCTRL_PIN(0x84, "PI4"),
+	PINCTRL_PIN(0x85, "PI5"),
+	PINCTRL_PIN(0x86, "PI6"),
+	PINCTRL_PIN(0x87, "PI7"),
+	PINCTRL_PIN(0x88, "PI8"),
+	PINCTRL_PIN(0x89, "PI9"),
+	PINCTRL_PIN(0x8A, "PI10"),
+	PINCTRL_PIN(0x8B, "PI11"),
+	PINCTRL_PIN(0x8C, "PI12"),
+	PINCTRL_PIN(0x8D, "PI13"),
+	PINCTRL_PIN(0x8E, "PI14"),
+	PINCTRL_PIN(0x8F, "PI15"),
+	PINCTRL_PIN(0x90, "PJ0"),
+	PINCTRL_PIN(0x91, "PJ1"),
+	PINCTRL_PIN(0x92, "PJ2"),
+	PINCTRL_PIN(0x93, "PJ3"),
+	PINCTRL_PIN(0x94, "PJ4"),
+};
+
+/**
+ * struct nuc970_pmx_pin - describes an NUC970 pin multi-function
+ * @bank: the bank of the pin (0 for PA, 1 for PB...)
+ * @pin: pin number (0 ~ 0xf)
+ * @func: multi-function pin setting value
+ * @conf: reserved for GPIO mode
+ */
+struct nuc970_pmx_pin {
+	uint32_t	bank;
+	uint32_t	pin;
+	uint32_t    func;
+	unsigned long  conf;
+};
+
+/**
+ * struct nuc970_pmx_func - describes NUC970 pinmux functions
+ * @name: the name of this specific function
+ * @groups: corresponding pin groups
+ * @ngroups: the number of groups
+ */
+struct nuc970_pmx_func {
+	const char	*name;
+	const char	**groups;
+	unsigned	ngroups;
+};
+
+
+/**
+ * struct nuc970_pin_group - describes an NUC970 pin group
+ * @name: the name of this specific pin group
+ * @pins_conf: the mux mode for each pin in this group. The size of this
+ *	array is the same as pins.
+ * @pins: an array of discrete physical pins used in this group, taken
+ *	from the driver-local pin enumeration space
+ * @npins: the number of pins in this group array, i.e. the number of
+ *	elements in .pins so we can iterate over that array
+ */
+struct nuc970_pin_group {
+	const char		*name;
+	struct nuc970_pmx_pin	*pins_conf;
+	unsigned int	*pins;
+	unsigned		npins;
+};
+
+struct nuc970_pinctrl {
+	struct device		*dev;
+	struct pinctrl_dev	*pctl;
+	int			nbanks;
+
+	struct nuc970_pmx_func	*functions;
+	int			nfunctions;
+
+	struct nuc970_pin_group	*groups;
+	int			ngroups;
+};
+
+static const inline struct nuc970_pin_group *nuc970_pinctrl_find_group_by_name(
+				const struct nuc970_pinctrl *info,
+				const char *name)
+{
+	const struct nuc970_pin_group *grp = NULL;
+	int i;
+
+	for (i = 0; i < info->ngroups; i++) {
+		if (strcmp(info->groups[i].name, name))
+			continue;
+
+		grp = &info->groups[i];
+		dev_dbg(info->dev, "%s: %d 0:%d\n", name, grp->npins, grp->pins[0]);
+		break;
+	}
+
+	return grp;
+}
+
+static int nuc970_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct nuc970_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->ngroups;
+}
+
+static const char *nuc970_get_group_name(struct pinctrl_dev *pctldev,
+				       unsigned selector)
+{
+	struct nuc970_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->groups[selector].name;
+}
+
+static int nuc970_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,
+			       const unsigned **pins,
+			       unsigned *npins)
+{
+	struct nuc970_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	if (selector >= info->ngroups)
+		return -EINVAL;
+
+	*pins = info->groups[selector].pins;
+	*npins = info->groups[selector].npins;
+
+	return 0;
+}
+
+static int nuc970_dt_node_to_map(struct pinctrl_dev *pctldev,
+			struct device_node *np,
+			struct pinctrl_map **map, unsigned *num_maps)
+{
+	struct nuc970_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	const struct nuc970_pin_group *grp;
+	struct pinctrl_map *new_map;
+	struct device_node *parent;
+	int map_num = 1;
+	int i;
+	
+	/*
+	 * first find the group of this node and check if we need create
+	 * config maps for pins
+	 */
+	grp = nuc970_pinctrl_find_group_by_name(info, np->name);
+	if (!grp) {
+		dev_err(info->dev, "unable to find group for node %s\n",
+			np->name);
+		return -EINVAL;
+	}
+
+	map_num += grp->npins;
+	new_map = devm_kzalloc(pctldev->dev, sizeof(*new_map) * map_num, GFP_KERNEL);
+	if (!new_map)
+		return -ENOMEM;
+
+	*map = new_map;
+	*num_maps = map_num;
+
+	/* create mux map */
+	parent = of_get_parent(np);
+	if (!parent) {
+		devm_kfree(pctldev->dev, new_map);
+		return -EINVAL;
+	}
+	new_map[0].type = PIN_MAP_TYPE_MUX_GROUP;
+	new_map[0].data.mux.function = parent->name;
+	new_map[0].data.mux.group = np->name;
+	of_node_put(parent);
+
+	/* create config map */
+	new_map++;
+	for (i = 0; i < grp->npins; i++) {
+		new_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;
+		new_map[i].data.configs.group_or_pin = pin_get_name(pctldev, grp->pins[i]);
+		new_map[i].data.configs.configs = &grp->pins_conf[i].conf;
+		new_map[i].data.configs.num_configs = 1;
+	}
+
+	dev_dbg(pctldev->dev, "maps: function %s group %s num %d\n",
+		(*map)->data.mux.function, (*map)->data.mux.group, map_num);
+
+	return 0;
+}
+
+static void nuc970_dt_free_map(struct pinctrl_dev *pctldev,
+				struct pinctrl_map *map, unsigned num_maps)
+{
+}
+
+static const struct pinctrl_ops nuc970_pctrl_ops = {
+	.get_groups_count	= nuc970_get_groups_count,
+	.get_group_name		= nuc970_get_group_name,
+	.get_group_pins		= nuc970_get_group_pins,
+	.dt_node_to_map		= nuc970_dt_node_to_map,
+	.dt_free_map		= nuc970_dt_free_map,
+};
+
+static void nuc970_pin_dbg(const struct device *dev, const struct nuc970_pmx_pin *pin)
+{
+	dev_dbg(dev, "P%c.%d: func=%d\n", pin->bank+'A', pin->pin, pin->func); 
+}
+
+static int pin_check_config(struct nuc970_pinctrl *info, const char *name,
+			    int index, const struct nuc970_pmx_pin *pin)
+{
+	/* check if it's a valid config */
+	if (pin->bank >= info->nbanks) {
+		dev_err(info->dev, "%s: pin conf %d bank_id %d >= nbanks %d\n",
+			name, index, pin->bank, info->nbanks);
+		return -EINVAL;
+	}
+
+	if (pin->pin >= MAX_NB_GPIO_PER_BANK) {
+		dev_err(info->dev, "%s: pin conf %d pin_bank_id %d >= %d\n",
+			name, index, pin->pin, MAX_NB_GPIO_PER_BANK);
+		return -EINVAL;
+	}
+
+	if (pin->func > 0xf) {
+		dev_err(info->dev, "%s: invalid pin function setting %d!\n", name, pin->func);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int nuc970_pmx_enable(struct pinctrl_dev *pctldev, unsigned selector,
+			   unsigned group)
+{
+	struct nuc970_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	const struct nuc970_pmx_pin *pins_conf = info->groups[group].pins_conf;
+	const struct nuc970_pmx_pin *pin;
+	uint32_t npins = info->groups[group].npins;
+	int i, ret;
+	unsigned int reg, offset;
+
+	//printk("    Enable function %s group %s\n", info->functions[selector].name, info->groups[group].name);
+
+	dev_dbg(info->dev, "enable function %s group %s\n",
+		info->functions[selector].name, info->groups[group].name);
+
+	/* first check that all the pins of the group are valid with a valid
+	 * paramter */
+	for (i = 0; i < npins; i++) {
+		pin = &pins_conf[i];
+		ret = pin_check_config(info, info->groups[group].name, i, pin);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; i < npins; i++) {
+		pin = &pins_conf[i];
+		//nuc970_pin_dbg(info->dev, pin);
+
+		offset = (pin->bank * 8) + ((pin->pin > 7) ? 4 : 0);
+		reg = __raw_readl(REG_MFP_GPA_L + offset);
+		//printk("    Enable P%c.%d by write reg 0x%x from 0x%x to ", pin->bank+'A', pin->pin, (u32)REG_MFP_GPA_L + offset, reg);
+		reg = (reg & ~(0xF << ((pin->pin & 0x7) * 4))) | (pin->func << ((pin->pin & 0x7) * 4));
+
+		__raw_writel(reg, REG_MFP_GPA_L + offset);
+		//printk("0x%x\n", reg);
+	}
+	return 0;
+}
+#if 0
+static void nuc970_pmx_disable(struct pinctrl_dev *pctldev, unsigned selector,
+			   unsigned group)
+{
+	struct nuc970_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+	const struct nuc970_pmx_pin *pins_conf = info->groups[group].pins_conf;
+	const struct nuc970_pmx_pin *pin;
+	uint32_t npins = info->groups[group].npins;
+	int i;
+	unsigned int reg, offset;
+
+	dev_dbg(info->dev, "disable function %s group %s\n",
+		info->functions[selector].name, info->groups[group].name);
+
+	for (i = 0; i < npins; i++) {
+		pin = &pins_conf[i];
+		offset = (pin->bank * 8) + ((pin->pin > 7) ? 4 : 0);
+		reg = __raw_readl(REG_MFP_GPA_L + offset);
+		reg = (reg & ~(0xF << ((pin->pin & 0x7) * 4)));
+		__raw_writel(reg, REG_MFP_GPA_L + offset);
+	}
+}
+#endif
+
+static int nuc970_set_mux(struct pinctrl_dev *pctldev, unsigned selector,
+		unsigned group)
+{
+  return nuc970_pmx_enable(pctldev, selector, group);
+}
+
+static int nuc970_pmx_get_funcs_count(struct pinctrl_dev *pctldev)
+{
+	struct nuc970_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->nfunctions;
+}
+
+static const char *nuc970_pmx_get_func_name(struct pinctrl_dev *pctldev,
+					  unsigned selector)
+{
+	struct nuc970_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	return info->functions[selector].name;
+}
+
+static int nuc970_pmx_get_groups(struct pinctrl_dev *pctldev, unsigned selector,
+			       const char * const **groups,
+			       unsigned * const num_groups)
+{
+	struct nuc970_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
+
+	*groups = info->functions[selector].groups;
+	*num_groups = info->functions[selector].ngroups;
+
+	return 0;
+}
+
+static const struct pinmux_ops nuc970_pmx_ops = {
+	.get_functions_count  = nuc970_pmx_get_funcs_count,
+	.get_function_name    = nuc970_pmx_get_func_name,
+	.get_function_groups  = nuc970_pmx_get_groups,
+//	.enable               = nuc970_pmx_enable,
+//	.disable              = nuc970_pmx_disable,
+    .set_mux = nuc970_set_mux,
+	.strict  = true,
+};
+
+static int nuc970_pinconf_get(struct pinctrl_dev *pctldev,
+			     unsigned pin_id, unsigned long *config)
+{
+	return 0;
+}
+
+static int nuc970_pinconf_set(struct pinctrl_dev *pctldev,
+			     unsigned pin_id, unsigned long *configs,
+				 unsigned num_configs)
+{
+	return 0;
+}
+
+static const struct pinconf_ops nuc970_pinconf_ops = {
+	.pin_config_get			= nuc970_pinconf_get,
+	.pin_config_set			= nuc970_pinconf_set,
+};
+
+static struct pinctrl_desc nuc970_pinctrl_desc = {
+	.pins     = nuc970_pins,
+	.npins    = ARRAY_SIZE(nuc970_pins),
+	.pctlops  = &nuc970_pctrl_ops,
+	.pmxops   = &nuc970_pmx_ops,
+	.confops  = &nuc970_pinconf_ops,
+	.owner    = THIS_MODULE,
+};
+
+
+static void nuc970_pinctrl_child_count(struct nuc970_pinctrl *info,
+				     struct device_node *np)
+{
+	struct device_node *child;
+
+	for_each_child_of_node(np, child) {
+		info->nfunctions++;
+		info->ngroups += of_get_child_count(child);
+	}
+}
+
+static int nuc970_pinctrl_parse_groups(struct device_node *np,
+				     struct nuc970_pin_group *grp,
+				     struct nuc970_pinctrl *info, u32 index)
+{
+	struct nuc970_pmx_pin *pin;
+	int size;
+	const __be32 *list;
+	int i, j;
+
+	dev_dbg(info->dev, "group(%d): %s\n", index, np->name);
+
+	/* Initialise group */
+	grp->name = np->name;
+
+	/*
+	 * the binding format is nuvoton,pins = <bank pin pin-function>,
+	 * do sanity check and calculate pins number
+	 */
+	list = of_get_property(np, "nuvoton,pins", &size);
+	/* we do not check return since it's safe node passed down */
+	size /= sizeof(*list);
+	if (!size || size % 4) {
+		dev_err(info->dev, "wrong setting!\n");
+		return -EINVAL;
+	}
+
+	grp->npins = size / 4;
+	pin = grp->pins_conf = devm_kzalloc(info->dev, grp->npins * sizeof(struct nuc970_pmx_pin), GFP_KERNEL);
+	grp->pins = devm_kzalloc(info->dev, grp->npins * sizeof(unsigned int), GFP_KERNEL);
+	if (!grp->pins_conf || !grp->pins)
+		return -ENOMEM;
+
+	for (i = 0, j = 0; i < size; i += 4, j++) {
+		pin->bank = be32_to_cpu(*list++);
+		pin->pin = be32_to_cpu(*list++);
+		grp->pins[j] = pin->bank * MAX_NB_GPIO_PER_BANK + pin->pin;
+		pin->func = be32_to_cpu(*list++);
+		pin->conf = be32_to_cpu(*list++);
+
+		nuc970_pin_dbg(info->dev, pin);
+		pin++;
+	}
+
+	return 0;
+}
+
+static int nuc970_pinctrl_parse_functions(struct device_node *np,
+					struct nuc970_pinctrl *info, u32 index)
+{
+	struct device_node *child;
+	struct nuc970_pmx_func *func;
+	struct nuc970_pin_group *grp;
+	int ret;
+	static u32 grp_index;
+	u32 i = 0;
+
+	dev_dbg(info->dev, "parse function(%d): %s\n", index, np->name);
+
+	func = &info->functions[index];
+
+	/* Initialise function */
+	func->name = np->name;
+	func->ngroups = of_get_child_count(np);
+	if (func->ngroups <= 0) {
+		dev_err(info->dev, "no groups defined\n");
+		return -EINVAL;
+	}
+	func->groups = devm_kzalloc(info->dev,
+			func->ngroups * sizeof(char *), GFP_KERNEL);
+	if (!func->groups)
+		return -ENOMEM;
+
+	for_each_child_of_node(np, child) {
+		func->groups[i] = child->name;
+		grp = &info->groups[grp_index++];
+		ret = nuc970_pinctrl_parse_groups(child, grp, info, i++);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static struct of_device_id nuc970_pinctrl_of_match[] = {
+	{ .compatible = "nuvoton,nuc970-pinctrl", NULL },
+	{ /* sentinel */ }
+};
+
+static int nuc970_pinctrl_probe_dt(struct platform_device *pdev,
+				 struct nuc970_pinctrl *info)
+{
+	int ret = 0;
+	int i;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+
+	if (!np)
+		return -ENODEV;
+
+	info->dev = &pdev->dev;
+	info->nbanks = 10;  /* PA ~ PJ */
+	nuc970_pinctrl_child_count(info, np);
+
+	info->functions = devm_kzalloc(&pdev->dev, info->nfunctions * sizeof(struct nuc970_pmx_func),
+					GFP_KERNEL);
+	if (!info->functions)
+		return -ENOMEM;
+
+	info->groups = devm_kzalloc(&pdev->dev, info->ngroups * sizeof(struct nuc970_pin_group),
+					GFP_KERNEL);
+	if (!info->groups)
+		return -ENOMEM;
+
+	dev_dbg(&pdev->dev, "nfunctions = %d\n", info->nfunctions);
+	dev_dbg(&pdev->dev, "ngroups = %d\n", info->ngroups);
+	
+	i = 0;
+
+	for_each_child_of_node(np, child) {
+		ret = nuc970_pinctrl_parse_functions(child, info, i++);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to parse function\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int nuc970_pinctrl_probe(struct platform_device *pdev)
+{
+	struct nuc970_pinctrl *info;
+	int ret;
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	ret = nuc970_pinctrl_probe_dt(pdev, info);
+	if (ret)
+		return ret;
+
+	nuc970_pinctrl_desc.name = dev_name(&pdev->dev);
+
+//	for (i = 0 , k = 0; i < info->nbanks; i++) {
+//		for (j = 0; j < MAX_NB_GPIO_PER_BANK; j++, k++) {
+//			pdesc->number = k;
+//			pdesc->name = kasprintf(GFP_KERNEL, "pio%c%d", i + 'A', j);
+//			pdesc++;
+//		}
+//	}
+
+	platform_set_drvdata(pdev, info);
+	info->pctl = pinctrl_register(&nuc970_pinctrl_desc, &pdev->dev, info);
+
+	if (!info->pctl) {
+		dev_err(&pdev->dev, "could not register NUC970 pinctrl driver\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	dev_info(&pdev->dev, "initialized NUC970 pinctrl driver\n");
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static int nuc970_pinctrl_remove(struct platform_device *pdev)
+{
+	struct nuc970_pinctrl *info = platform_get_drvdata(pdev);
+
+	pinctrl_unregister(info->pctl);
+
+	return 0;
+}
+
+static struct platform_driver nuc970_pinctrl_driver = {
+	.driver = {
+		.name = "pinctrl-nuc970",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(nuc970_pinctrl_of_match),
+	},
+	.probe = nuc970_pinctrl_probe,
+	.remove = nuc970_pinctrl_remove,
+};
+
+static int __init nuc970_pinctrl_init(void)
+{
+	return platform_driver_register(&nuc970_pinctrl_driver);
+}
+arch_initcall(nuc970_pinctrl_init);
+
+static void __exit nuc970_pinctrl_exit(void)
+{
+	platform_driver_unregister(&nuc970_pinctrl_driver);
+}
+
+module_exit(nuc970_pinctrl_exit);
+MODULE_AUTHOR("Nuvoton Technology Corp.");
+MODULE_DESCRIPTION("Nuvoton NUC970 SOC series pinctrl driver");
+MODULE_LICENSE("GPL");
+
Index: linux-4.4.92/drivers/pinctrl/pinctrl-nuc970.c
===================================================================
--- /dev/null
+++ linux-4.4.92/drivers/pinctrl/pinctrl-nuc970.c
@@ -0,0 +1,3675 @@
+/*
+ * Copyright (c) 2014 Nuvoton Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <mach/map.h>
+#include <mach/regs-gcr.h>
+
+// The numbering is not related to actual layout.
+const struct pinctrl_pin_desc nuc970_pins[] = {
+	PINCTRL_PIN(0x00, "PA0"),
+	PINCTRL_PIN(0x01, "PA1"),
+	PINCTRL_PIN(0x02, "PA2"),
+	PINCTRL_PIN(0x03, "PA3"),
+	PINCTRL_PIN(0x04, "PA4"),
+	PINCTRL_PIN(0x05, "PA5"),
+	PINCTRL_PIN(0x06, "PA6"),
+	PINCTRL_PIN(0x07, "PA7"),
+	PINCTRL_PIN(0x08, "PA8"),
+	PINCTRL_PIN(0x09, "PA9"),
+	PINCTRL_PIN(0x0A, "PA10"),
+	PINCTRL_PIN(0x0B, "PA11"),
+	PINCTRL_PIN(0x0C, "PA12"),
+	PINCTRL_PIN(0x0D, "PA13"),
+	PINCTRL_PIN(0x0E, "PA14"),
+	PINCTRL_PIN(0x0F, "PA15"),
+	PINCTRL_PIN(0x10, "PB0"),
+	PINCTRL_PIN(0x11, "PB1"),
+	PINCTRL_PIN(0x12, "PB2"),
+	PINCTRL_PIN(0x13, "PB3"),
+	PINCTRL_PIN(0x14, "PB4"),
+	PINCTRL_PIN(0x15, "PB5"),
+	PINCTRL_PIN(0x16, "PB6"),
+	PINCTRL_PIN(0x17, "PB7"),
+	PINCTRL_PIN(0x18, "PB8"),
+	PINCTRL_PIN(0x19, "PB9"),
+	PINCTRL_PIN(0x1A, "PB10"),
+	PINCTRL_PIN(0x1B, "PB11"),
+	PINCTRL_PIN(0x1C, "PB12"),
+	PINCTRL_PIN(0x1D, "PB13"),
+	PINCTRL_PIN(0x1E, "PB14"),
+	PINCTRL_PIN(0x1F, "PB15"),
+	PINCTRL_PIN(0x20, "PC0"),
+	PINCTRL_PIN(0x21, "PC1"),
+	PINCTRL_PIN(0x22, "PC2"),
+	PINCTRL_PIN(0x23, "PC3"),
+	PINCTRL_PIN(0x24, "PC4"),
+	PINCTRL_PIN(0x25, "PC5"),
+	PINCTRL_PIN(0x26, "PC6"),
+	PINCTRL_PIN(0x27, "PC7"),
+	PINCTRL_PIN(0x28, "PC8"),
+	PINCTRL_PIN(0x29, "PC9"),
+	PINCTRL_PIN(0x2A, "PC10"),
+	PINCTRL_PIN(0x2B, "PC11"),
+	PINCTRL_PIN(0x2C, "PC12"),
+	PINCTRL_PIN(0x2D, "PC13"),
+	PINCTRL_PIN(0x2E, "PC14"),
+	//PINCTRL_PIN(0x2F, "PC15"),
+	PINCTRL_PIN(0x30, "PD0"),
+	PINCTRL_PIN(0x31, "PD1"),
+	PINCTRL_PIN(0x32, "PD2"),
+	PINCTRL_PIN(0x33, "PD3"),
+	PINCTRL_PIN(0x34, "PD4"),
+	PINCTRL_PIN(0x35, "PD5"),
+	PINCTRL_PIN(0x36, "PD6"),
+	PINCTRL_PIN(0x37, "PD7"),
+	PINCTRL_PIN(0x38, "PD8"),
+	PINCTRL_PIN(0x39, "PD9"),
+	PINCTRL_PIN(0x3A, "PD10"),
+	PINCTRL_PIN(0x3B, "PD11"),
+	PINCTRL_PIN(0x3C, "PD12"),
+	PINCTRL_PIN(0x3D, "PD13"),
+	PINCTRL_PIN(0x3E, "PD14"),
+	PINCTRL_PIN(0x3F, "PD15"),
+	PINCTRL_PIN(0x40, "PE0"),
+	PINCTRL_PIN(0x41, "PE1"),
+	PINCTRL_PIN(0x42, "PE2"),
+	PINCTRL_PIN(0x43, "PE3"),
+	PINCTRL_PIN(0x44, "PE4"),
+	PINCTRL_PIN(0x45, "PE5"),
+	PINCTRL_PIN(0x46, "PE6"),
+	PINCTRL_PIN(0x47, "PE7"),
+	PINCTRL_PIN(0x48, "PE8"),
+	PINCTRL_PIN(0x49, "PE9"),
+	PINCTRL_PIN(0x4A, "PE10"),
+	PINCTRL_PIN(0x4B, "PE11"),
+	PINCTRL_PIN(0x4C, "PE12"),
+	PINCTRL_PIN(0x4D, "PE13"),
+	PINCTRL_PIN(0x4E, "PE14"),
+	PINCTRL_PIN(0x4F, "PE15"),
+	PINCTRL_PIN(0x50, "PF0"),
+	PINCTRL_PIN(0x51, "PF1"),
+	PINCTRL_PIN(0x52, "PF2"),
+	PINCTRL_PIN(0x53, "PF3"),
+	PINCTRL_PIN(0x54, "PF4"),
+	PINCTRL_PIN(0x55, "PF5"),
+	PINCTRL_PIN(0x56, "PF6"),
+	PINCTRL_PIN(0x57, "PF7"),
+	PINCTRL_PIN(0x58, "PF8"),
+	PINCTRL_PIN(0x59, "PF9"),
+	PINCTRL_PIN(0x5A, "PF10"),
+	PINCTRL_PIN(0x5B, "PF11"),
+	PINCTRL_PIN(0x5C, "PF12"),
+	PINCTRL_PIN(0x5D, "PF13"),
+	PINCTRL_PIN(0x5E, "PF14"),
+	PINCTRL_PIN(0x5F, "PF15"),
+	PINCTRL_PIN(0x60, "PG0"),
+	PINCTRL_PIN(0x61, "PG1"),
+	PINCTRL_PIN(0x62, "PG2"),
+	PINCTRL_PIN(0x63, "PG3"),
+	PINCTRL_PIN(0x64, "PG4"),
+	PINCTRL_PIN(0x65, "PG5"),
+	PINCTRL_PIN(0x66, "PG6"),
+	PINCTRL_PIN(0x67, "PG7"),
+	PINCTRL_PIN(0x68, "PG8"),
+	PINCTRL_PIN(0x69, "PG9"),
+	PINCTRL_PIN(0x6A, "PG10"),
+	PINCTRL_PIN(0x6B, "PG11"),
+	PINCTRL_PIN(0x6C, "PG12"),
+	PINCTRL_PIN(0x6D, "PG13"),
+	PINCTRL_PIN(0x6E, "PG14"),
+	PINCTRL_PIN(0x6F, "PG15"),
+	PINCTRL_PIN(0x70, "PH0"),
+	PINCTRL_PIN(0x71, "PH1"),
+	PINCTRL_PIN(0x72, "PH2"),
+	PINCTRL_PIN(0x73, "PH3"),
+	PINCTRL_PIN(0x74, "PH4"),
+	PINCTRL_PIN(0x75, "PH5"),
+	PINCTRL_PIN(0x76, "PH6"),
+	PINCTRL_PIN(0x77, "PH7"),
+	PINCTRL_PIN(0x78, "PH8"),
+	PINCTRL_PIN(0x79, "PH9"),
+	PINCTRL_PIN(0x7A, "PH10"),
+	PINCTRL_PIN(0x7B, "PH11"),
+	PINCTRL_PIN(0x7C, "PH12"),
+	PINCTRL_PIN(0x7D, "PH13"),
+	PINCTRL_PIN(0x7E, "PH14"),
+	PINCTRL_PIN(0x7F, "PH15"),
+	PINCTRL_PIN(0x80, "PI0"),
+	PINCTRL_PIN(0x81, "PI1"),
+	PINCTRL_PIN(0x82, "PI2"),
+	PINCTRL_PIN(0x83, "PI3"),
+	PINCTRL_PIN(0x84, "PI4"),
+	PINCTRL_PIN(0x85, "PI5"),
+	PINCTRL_PIN(0x86, "PI6"),
+	PINCTRL_PIN(0x87, "PI7"),
+	PINCTRL_PIN(0x88, "PI8"),
+	PINCTRL_PIN(0x89, "PI9"),
+	PINCTRL_PIN(0x8A, "PI10"),
+	PINCTRL_PIN(0x8B, "PI11"),
+	PINCTRL_PIN(0x8C, "PI12"),
+	PINCTRL_PIN(0x8D, "PI13"),
+	PINCTRL_PIN(0x8E, "PI14"),
+	PINCTRL_PIN(0x8F, "PI15"),
+	PINCTRL_PIN(0x90, "PJ0"),
+	PINCTRL_PIN(0x91, "PJ1"),
+	PINCTRL_PIN(0x92, "PJ2"),
+	PINCTRL_PIN(0x93, "PJ3"),
+	PINCTRL_PIN(0x94, "PJ4"),
+};
+
+
+
+struct nuc970_pinctrl_group {
+	const char *name;
+	const unsigned int *pins;
+	const unsigned num_pins;
+	const unsigned func;
+};
+
+static const unsigned emac0_pins[] = {0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59}; // Port F
+static const unsigned emac1_pins[] = {0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B}; // Port E
+static const unsigned pps0_pin[] = {0x5E};
+static const unsigned pps1_pin[] = {0x4D};
+
+static const unsigned lcd_0_pins[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+								0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+								0x66, 0x67, 0x68, 0x69}; // 16 bit mode
+static const unsigned lcd_1_pins[] = {0x38, 0x39}; // 18 bit mode
+static const unsigned lcd_2_pins[] = {0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F}; // 24 bit mode
+
+static const unsigned vcap_pins[] = {0x83, 0x84, 0x85, 0x86, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F};
+
+static const unsigned kpi_0_pins[] = {0x04, 0x05, 0x06, 0x07}; // row
+static const unsigned kpi_1_pins[] = {0x08, 0x09}; // 2 col
+static const unsigned kpi_2_pins[] = {0x0A, 0x0B}; // 4 col
+static const unsigned kpi_3_pins[] = {0x0C, 0x0D, 0x0E, 0x0F}; // 8 col
+static const unsigned kpi_4_pins[] = {0x74, 0x75, 0x76, 0x77}; // row
+static const unsigned kpi_5_pins[] = {0x78, 0x79}; // 2 col
+static const unsigned kpi_6_pins[] = {0x7A, 0x7B}; // 4 col
+static const unsigned kpi_7_pins[] = {0x7C, 0x7D, 0x7E, 0x7F}; // 8 col
+static const unsigned kpi_8_pins[] = {0x04, 0x05, 0x6}; // 3 row
+
+
+#ifdef CONFIG_BOARD_TOMATO
+static const unsigned sd0_pins[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36};
+#else
+static const unsigned sd0_pins[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37};
+#endif
+static const unsigned sd1_0_pins[] = {0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8C, 0x8D}; // Port I
+static const unsigned sd1_1_pins[] = {0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49}; // Port E
+static const unsigned sd1_2_pins[] = {0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D}; // Port H
+static const unsigned sd01_0_pins[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+					0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8C, 0x8D}; // Port I
+static const unsigned sd01_1_pins[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+					0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49}; // Port E
+static const unsigned sd01_2_pins[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+					0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D}; // Port H
+
+static const unsigned nand_0_pins[] = {0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+								0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E};  // Port C
+static const unsigned nand_1_pins[] = {0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
+								0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F};  // Port I
+static const unsigned nand_2_pins[] = {0x10, 0x11};  // ncs1, rdy1
+static const unsigned nand_3_pins[] = {0x64, 0x65};  // ncs1, rdy1
+
+static const unsigned emmc_0_pins[] = {0x20, 0x21, 0x22, 0x23, 0x24, 0x25};  // Port C
+static const unsigned emmc_1_pins[] = {0x85, 0x86, 0x87, 0x88, 0x89, 0x8A};  // Port I
+
+static const unsigned usbh_pe_pins[] = {0x4E, 0x4F, 0x71}; // ppwr0 & ppwr1, over-current
+static const unsigned usbh_pf_pin[] = {0x5A, 0x71};        // ppwr, over-current
+static const unsigned usbh_oc_pin[] = {0x71};            // over-current
+static const unsigned usbd_pin[] = {0x70};  // vbvld
+
+static const unsigned i2c0_pins[] = {0x60, 0x61};
+
+static const unsigned i2c1_1_pins[] = {0x62, 0x63};
+static const unsigned i2c1_2_pins[] = {0x72, 0x73};
+static const unsigned i2c1_3_pins[] = {0x83, 0x84};
+
+static const unsigned i2s_pins[] = {0x6A, 0x6B, 0x6C, 0x6D, 0x6E};
+
+static const unsigned uart0_pins[] = {0x40, 0x41};
+static const unsigned uart1_0_pins[] = {0x42, 0x43}; // tx, rx
+static const unsigned uart1_1_pins[] = {0x44, 0x45}; // rts, cts
+static const unsigned uart1_2_pins[] = {0x46, 0x47, 0x48, 0x49}; // full func
+static const unsigned uart1_3_pins[] = {0x74, 0x75}; // tx, rx
+static const unsigned uart1_4_pins[] = {0x76, 0x77}; // rts, cts
+static const unsigned uart1_5_pins[] = {0x85, 0x86}; // tx, rx
+static const unsigned uart1_6_pins[] = {0x87, 0x88}; // rts, cts
+static const unsigned uart2_0_pins[] = {0x5B, 0x5C}; // tx, rx
+static const unsigned uart2_1_pins[] = {0x5D, 0x5E}; // rts, cts
+static const unsigned uart3_pins[] = {0x4C, 0x4D}; // tx, rx
+static const unsigned uart4_0_pins[] = {0x2A, 0x2B}; // tx, rx
+static const unsigned uart4_1_pins[] = {0x2C, 0x2D}; // rts, cts
+static const unsigned uart4_2_pins[] = {0x78, 0x79}; // tx, rx
+static const unsigned uart4_3_pins[] = {0x7A, 0x7B}; // rts, cts
+static const unsigned uart4_4_pins[] = {0x89, 0x8A}; // tx, rx
+static const unsigned uart5_pins[] = {0x10, 0x11};
+static const unsigned uart6_0_pins[] = {0x12, 0x13}; // tx, rx
+static const unsigned uart6_1_pins[] = {0x14, 0x15}; // rts, cts
+static const unsigned uart6_2_pins[] = {0x6B, 0x6C}; // tx, rx
+static const unsigned uart6_3_pins[] = {0x6D, 0x6E}; // rts, cts
+static const unsigned uart7_0_pins[] = {0x64, 0x65}; // tx, rx
+static const unsigned uart7_1_pins[] = {0x81, 0x82}; // tx, rx
+static const unsigned uart8_0_pins[] = {0x4A, 0x4B}; // tx, rx
+static const unsigned uart8_1_pins[] = {0x4C, 0x4D}; // rts, cts
+static const unsigned uart8_2_pins[] = {0x7C, 0x7D}; // tx, rx
+static const unsigned uart8_3_pins[] = {0x7E, 0x7F}; // rts, cts
+static const unsigned uart8_4_pins[] = {0x8C, 0x8D}; // tx, rx
+static const unsigned uart8_5_pins[] = {0x8E, 0x8F}; // rts, cts
+static const unsigned uart9_0_pins[] = {0x3B, 0x3C}; // tx, rx
+static const unsigned uart9_1_pins[] = {0x3E, 0x3F}; // tx, rx
+static const unsigned uart9_2_pins[] = {0x72, 0x73}; // tx, rx
+static const unsigned uart10_0_pins[] = {0x1A, 0x1B}; // tx, rx
+static const unsigned uart10_1_pins[] = {0x1C, 0x1D}; // tx, rx
+static const unsigned uart10_2_pins[] = {0x1E, 0x1F}; // rts, cts
+static const unsigned uart10_3_pins[] = {0x26, 0x27}; // tx, rx
+static const unsigned uart10_4_pins[] = {0x28, 0x29}; // rts, cts
+
+static const unsigned sc0_0_pins[] = {0x6A, 0x6B, 0x6C, 0x6D, 0x6E};
+static const unsigned sc0_1_pins[] = {0x8B, 0x8C, 0x8D, 0x8E, 0x8F};
+static const unsigned sc0_2_pins[] = {0x6B, 0x6C};  // scuart
+static const unsigned sc0_3_pins[] = {0x8C, 0x8D};  // scuart
+static const unsigned sc1_0_pins[] = {0x86, 0x87, 0x88, 0x89, 0x8A};
+static const unsigned sc1_1_pins[] = {0x87, 0x88};  // scuart
+
+static const unsigned spi0_0_pins[] = {0x16, 0x17, 0x18, 0x19};
+static const unsigned spi0_1_pins[] = {0x1A, 0x1B}; // quad
+static const unsigned spi0_2_pins[] = {0x10}; // ss1
+static const unsigned spi0_3_pins[] = {0x7C}; // ss1
+static const unsigned spi1_0_pins[] = {0x1C, 0x1D, 0x1E, 0x1F};
+static const unsigned spi1_1_pins[] = {0x11}; // ss1
+static const unsigned spi1_2_pins[] = {0x64, 0x65}; // quad
+static const unsigned spi1_3_pins[] = {0x7D}; // ss1
+static const unsigned spi1_4_pins[] = {0x85, 0x86, 0x87, 0x88};
+
+static const unsigned can0_0_pins[] = {0x1A, 0x1B}; // Port B
+static const unsigned can0_1_pins[] = {0x72, 0x73}; // Port H
+static const unsigned can0_2_pins[] = {0x83, 0x84}; // Port I
+static const unsigned can1_pins[] = {0x7E, 0x7F}; // Port H
+
+static const unsigned pwm0_0_pin[] = {0x0C};
+static const unsigned pwm0_1_pin[] = {0x12};
+static const unsigned pwm0_2_pin[] = {0x2E};
+static const unsigned pwm0_3_pin[] = {0x3C};
+static const unsigned pwm1_0_pin[] = {0x0D};
+static const unsigned pwm1_1_pin[] = {0x13};
+static const unsigned pwm1_2_pin[] = {0x3D};
+static const unsigned pwm2_0_pin[] = {0x0E};
+static const unsigned pwm2_1_pin[] = {0x72};
+static const unsigned pwm2_2_pin[] = {0x3E};
+static const unsigned pwm3_0_pin[] = {0x0F};
+static const unsigned pwm3_1_pin[] = {0x73};
+static const unsigned pwm3_2_pin[] = {0x3F};
+
+static const unsigned rtc_0_pin[] = {74};
+static const unsigned rtc_1_pin[] = {83};
+
+static const unsigned etimer0_0_pin[] = {0x26}; // tgl
+static const unsigned etimer0_1_pin[] = {0x27}; // cap
+static const unsigned etimer0_2_pin[] = {0x12}; // tgl
+static const unsigned etimer0_3_pin[] = {0x13}; // cap
+static const unsigned etimer1_0_pin[] = {0x10}; // tgl
+static const unsigned etimer1_1_pin[] = {0x11}; // cap
+static const unsigned etimer1_2_pin[] = {0x28}; // tgl
+static const unsigned etimer1_3_pin[] = {0x29}; // cap
+static const unsigned etimer2_0_pin[] = {0x2A}; // tgl
+static const unsigned etimer2_1_pin[] = {0x2B}; // cap
+static const unsigned etimer2_2_pin[] = {0x5B}; // tgl
+static const unsigned etimer2_3_pin[] = {0x5C}; // cap
+static const unsigned etimer3_0_pin[] = {0x2C}; // tgl
+static const unsigned etimer3_1_pin[] = {0x2D}; // cap
+static const unsigned etimer3_2_pin[] = {0x5D}; // tgl
+static const unsigned etimer3_3_pin[] = {0x5E}; // cap
+
+static const unsigned jtag_pins[] = {0x90, 0x91, 0x92, 0x93, 0x94};
+
+
+static const unsigned eint0_0_pin[] = {0x70};
+static const unsigned eint0_1_pin[] = {0x5B};
+static const unsigned eint1_0_pin[] = {0x71};
+static const unsigned eint1_1_pin[] = {0x5C};
+static const unsigned eint2_0_pin[] = {0x72};
+static const unsigned eint2_1_pin[] = {0x5D};
+static const unsigned eint3_0_pin[] = {0x73};
+static const unsigned eint3_1_pin[] = {0x5E};
+static const unsigned eint4_0_pin[] = {0x74};
+static const unsigned eint4_1_pin[] = {0x5F};
+static const unsigned eint5_0_pin[] = {0x75};
+static const unsigned eint5_1_pin[] = {0x6F};
+static const unsigned eint6_0_pin[] = {0x76};
+static const unsigned eint6_1_pin[] = {0x81};
+static const unsigned eint7_0_pin[] = {0x77};
+static const unsigned eint7_1_pin[] = {0x82};
+
+static const unsigned ebi8_0_pin[] = {0x38,  // nCS0
+				      0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				      0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                      0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87};  // data0~7
+static const unsigned ebi8_1_pin[] = {0x39,  // nCS1
+				      0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				      0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                      0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87};  // data0~7
+static const unsigned ebi8_2_pin[] = {0x3A,  // nCS2
+				      0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				      0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                      0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87};  // data0~7
+static const unsigned ebi8_3_pin[] = {0x3B,  // nCS3
+				      0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				      0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                      0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87};  // data0~7
+static const unsigned ebi8_4_pin[] = {0x3C,  // nCS4
+				      0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				      0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                      0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87};  // data0~7
+static const unsigned ebi16_0_pin[] = {0x38,  // nCS0
+				       0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				       0x7E, 0x7F, //nBE0,nBE1
+				       0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                       0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,  // data0~7
+                                       0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F}; //data8~15
+static const unsigned ebi16_1_pin[] = {0x39,  // nCS1
+				       0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				       0x7E, 0x7F, //nBE0,nBE1
+				       0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                       0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,  // data0~7
+                                       0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F}; //data8~15
+static const unsigned ebi16_2_pin[] = {0x3A,  // nCS2
+				       0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				       0x7E, 0x7F, //nBE0,nBE1
+				       0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                       0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,  // data0~7
+                                       0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F}; //data8~15
+static const unsigned ebi16_3_pin[] = {0x3B,  // nCS3
+				       0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				       0x7E, 0x7F, //nBE0,nBE1
+				       0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                       0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,  // data0~7
+                                       0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F}; //data8~15
+static const unsigned ebi16_4_pin[] = {0x3C,  // nCS4
+				       0x3D, 0x3E, 0x3F, //nWAIT, nOE, nWE,
+				       0x7E, 0x7F, //nBE0,nBE1
+				       0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, //address0~10
+                                       0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,  // data0~7
+                                       0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F}; //data8~15
+// TODO: CKO
+
+static const struct nuc970_pinctrl_group nuc970_pinctrl_groups[] = {
+	{
+		.name = "emac0_grp",
+		.pins = emac0_pins,
+		.num_pins = ARRAY_SIZE(emac0_pins),
+		.func = 0x1,
+	},
+	{
+		.name = "emac1_grp",
+		.pins = emac1_pins,
+		.num_pins = ARRAY_SIZE(emac1_pins),
+		.func = 0x1,
+	},
+	{
+		.name = "pps0_grp",
+		.pins = pps0_pin,
+		.num_pins = ARRAY_SIZE(pps0_pin),
+		.func = 0x1,
+	},
+	{
+		.name = "pps1_grp",
+		.pins = pps1_pin,
+		.num_pins = ARRAY_SIZE(pps1_pin),
+		.func = 0x1,
+	},
+	{
+		.name = "lcd0_grp",
+		.pins = lcd_0_pins,
+		.num_pins = ARRAY_SIZE(lcd_0_pins),
+		.func = 0x2,
+	},
+	{
+		.name = "lcd1_grp",
+		.pins = lcd_1_pins,
+		.num_pins = ARRAY_SIZE(lcd_1_pins),
+		.func = 0x2,
+	},
+	{
+		.name = "lcd2_grp",
+		.pins = lcd_2_pins,
+		.num_pins = ARRAY_SIZE(lcd_2_pins),
+		.func = 0x2,
+	},
+	{
+		.name = "vcap_grp",
+		.pins = vcap_pins,
+		.num_pins = ARRAY_SIZE(vcap_pins),
+		.func = 0x3,
+	},
+	{
+		.name = "kpi_0_grp",
+		.pins = kpi_0_pins,
+		.num_pins = ARRAY_SIZE(kpi_0_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "kpi_1_grp",
+		.pins = kpi_1_pins,
+		.num_pins = ARRAY_SIZE(kpi_1_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "kpi_2_grp",
+		.pins = kpi_2_pins,
+		.num_pins = ARRAY_SIZE(kpi_2_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "kpi_3_grp",
+		.pins = kpi_3_pins,
+		.num_pins = ARRAY_SIZE(kpi_3_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "kpi_4_grp",
+		.pins = kpi_4_pins,
+		.num_pins = ARRAY_SIZE(kpi_4_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "kpi_5_grp",
+		.pins = kpi_5_pins,
+		.num_pins = ARRAY_SIZE(kpi_5_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "kpi_6_grp",
+		.pins = kpi_6_pins,
+		.num_pins = ARRAY_SIZE(kpi_6_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "kpi_7_grp",
+		.pins = kpi_7_pins,
+		.num_pins = ARRAY_SIZE(kpi_7_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "kpi_8_grp",
+		.pins = kpi_8_pins,
+		.num_pins = ARRAY_SIZE(kpi_8_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "sd0_grp",
+		.pins = sd0_pins,
+		.num_pins = ARRAY_SIZE(sd0_pins),
+		.func = 0x6,
+	},
+	{
+		.name = "sd1_0_grp",
+		.pins = sd1_0_pins,
+		.num_pins = ARRAY_SIZE(sd1_0_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "sd1_1_grp",
+		.pins = sd1_1_pins,
+		.num_pins = ARRAY_SIZE(sd1_1_pins),
+		.func = 0x6,
+	},
+	{
+		.name = "sd1_2_grp",
+		.pins = sd1_2_pins,
+		.num_pins = ARRAY_SIZE(sd1_2_pins),
+		.func = 0x6,
+	},
+	{
+		.name = "sd01_0_grp",
+		.pins = sd01_0_pins,
+		.num_pins = ARRAY_SIZE(sd01_0_pins),
+		.func = 0x4,
+	},
+	{
+		.name = "sd01_1_grp",
+		.pins = sd01_1_pins,
+		.num_pins = ARRAY_SIZE(sd01_1_pins),
+		.func = 0x6,
+	},
+	{
+		.name = "sd01_2_grp",
+		.pins = sd01_2_pins,
+		.num_pins = ARRAY_SIZE(sd01_2_pins),
+		.func = 0x6,
+	},
+	{
+		.name = "nand_0_grp",
+		.pins = nand_0_pins,
+		.num_pins = ARRAY_SIZE(nand_0_pins),
+		.func = 0x5,
+	},
+	{
+		.name = "nand_1_grp",
+		.pins = nand_1_pins,
+		.num_pins = ARRAY_SIZE(nand_1_pins),
+		.func = 0x5,
+	},
+	{
+		.name = "nand_2_grp",
+		.pins = nand_2_pins,
+		.num_pins = ARRAY_SIZE(nand_2_pins),
+		.func = 0x5,
+	},
+	{
+		.name = "nand_3_grp",
+		.pins = nand_3_pins,
+		.num_pins = ARRAY_SIZE(nand_3_pins),
+		.func = 0x5,
+	},
+	{
+		.name = "emmc_0_grp",
+		.pins = emmc_0_pins,
+		.num_pins = ARRAY_SIZE(emmc_0_pins),
+		.func = 0x6,
+	},
+	{
+		.name = "emmc_1_grp",
+		.pins = emmc_1_pins,
+		.num_pins = ARRAY_SIZE(emmc_1_pins),
+		.func = 0x6,
+	},
+	{
+		.name = "usbh_pe_grp",
+		.pins = usbh_pe_pins,
+		.num_pins = ARRAY_SIZE(usbh_pe_pins),
+		.func = 0x7,
+	},
+	{
+		.name = "usbh_pf_grp",
+		.pins = usbh_pf_pin,
+		.num_pins = ARRAY_SIZE(usbh_pf_pin),
+		.func = 0x7,
+	},
+	{
+		.name = "usbh_oc_grp",
+		.pins = usbh_oc_pin,
+		.num_pins = ARRAY_SIZE(usbh_oc_pin),
+		.func = 0x7,
+	},
+	{
+		.name = "usbd_grp",
+		.pins = usbd_pin,
+		.num_pins = ARRAY_SIZE(usbd_pin),
+		.func = 0x7,
+	},
+	{
+		.name = "i2c0_grp",
+		.pins = i2c0_pins,
+		.num_pins = ARRAY_SIZE(i2c0_pins),
+		.func = 0x8,
+	},
+	{
+		.name = "i2c1_1_grp",
+		.pins = i2c1_1_pins,
+		.num_pins = ARRAY_SIZE(i2c1_1_pins),
+		.func = 0x8,
+	},
+	{
+		.name = "i2c1_2_grp",
+		.pins = i2c1_2_pins,
+		.num_pins = ARRAY_SIZE(i2c1_2_pins),
+		.func = 0x8,
+	},
+	{
+		.name = "i2c1_3_grp",
+		.pins = i2c1_3_pins,
+		.num_pins = ARRAY_SIZE(i2c1_3_pins),
+		.func = 0x8,
+	},
+	{
+		.name = "i2s_grp",
+		.pins = i2s_pins,
+		.num_pins = ARRAY_SIZE(i2s_pins),
+		.func = 0x8,
+	},
+	{
+		.name = "uart0_grp",
+		.pins = uart0_pins,
+		.num_pins = ARRAY_SIZE(uart0_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart1_0_grp",
+		.pins = uart1_0_pins,
+		.num_pins = ARRAY_SIZE(uart1_0_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart1_1_grp",
+		.pins = uart1_1_pins,
+		.num_pins = ARRAY_SIZE(uart1_1_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart1_2_grp",
+		.pins = uart1_2_pins,
+		.num_pins = ARRAY_SIZE(uart1_2_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart1_3_grp",
+		.pins = uart1_3_pins,
+		.num_pins = ARRAY_SIZE(uart1_3_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart1_4_grp",
+		.pins = uart1_4_pins,
+		.num_pins = ARRAY_SIZE(uart1_4_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart1_5_grp",
+		.pins = uart1_5_pins,
+		.num_pins = ARRAY_SIZE(uart1_5_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart1_6_grp",
+		.pins = uart1_6_pins,
+		.num_pins = ARRAY_SIZE(uart1_6_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart2_0_grp",
+		.pins = uart2_0_pins,
+		.num_pins = ARRAY_SIZE(uart2_0_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart2_1_grp",
+		.pins = uart2_1_pins,
+		.num_pins = ARRAY_SIZE(uart2_1_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart3_grp",
+		.pins = uart3_pins,
+		.num_pins = ARRAY_SIZE(uart3_pins),
+		.func = 0xA,
+	},
+	{
+		.name = "uart4_0_grp",
+		.pins = uart4_0_pins,
+		.num_pins = ARRAY_SIZE(uart4_0_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart4_1_grp",
+		.pins = uart4_1_pins,
+		.num_pins = ARRAY_SIZE(uart4_1_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart4_2_grp",
+		.pins = uart4_2_pins,
+		.num_pins = ARRAY_SIZE(uart4_2_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart4_3_grp",
+		.pins = uart4_3_pins,
+		.num_pins = ARRAY_SIZE(uart4_3_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart4_4_grp",
+		.pins = uart4_4_pins,
+		.num_pins = ARRAY_SIZE(uart4_4_pins),
+		.func = 0x9,
+	},
+	{
+
+
+		.name = "uart5_grp",
+		.pins = uart5_pins,
+		.num_pins = ARRAY_SIZE(uart5_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart6_0_grp",
+		.pins = uart6_0_pins,
+		.num_pins = ARRAY_SIZE(uart6_0_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart6_1_grp",
+		.pins = uart6_1_pins,
+		.num_pins = ARRAY_SIZE(uart6_1_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart6_2_grp",
+		.pins = uart6_2_pins,
+		.num_pins = ARRAY_SIZE(uart6_2_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart6_3_grp",
+		.pins = uart6_3_pins,
+		.num_pins = ARRAY_SIZE(uart6_3_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart7_0_grp",
+		.pins = uart7_0_pins,
+		.num_pins = ARRAY_SIZE(uart7_0_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart7_1_grp",
+		.pins = uart7_1_pins,
+		.num_pins = ARRAY_SIZE(uart7_1_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart8_0_grp",
+		.pins = uart8_0_pins,
+		.num_pins = ARRAY_SIZE(uart8_0_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart8_1_grp",
+		.pins = uart8_1_pins,
+		.num_pins = ARRAY_SIZE(uart8_1_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart8_2_grp",
+		.pins = uart8_2_pins,
+		.num_pins = ARRAY_SIZE(uart8_2_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart8_3_grp",
+		.pins = uart8_3_pins,
+		.num_pins = ARRAY_SIZE(uart8_3_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart8_4_grp",
+		.pins = uart8_4_pins,
+		.num_pins = ARRAY_SIZE(uart8_4_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart8_5_grp",
+		.pins = uart8_5_pins,
+		.num_pins = ARRAY_SIZE(uart8_5_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart9_0_grp",
+		.pins = uart9_0_pins,
+		.num_pins = ARRAY_SIZE(uart9_0_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart9_1_grp",
+		.pins = uart9_1_pins,
+		.num_pins = ARRAY_SIZE(uart9_1_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart9_2_grp",
+		.pins = uart9_2_pins,
+		.num_pins = ARRAY_SIZE(uart9_2_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart10_0_grp",
+		.pins = uart10_0_pins,
+		.num_pins = ARRAY_SIZE(uart10_0_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart10_1_grp",
+		.pins = uart10_1_pins,
+		.num_pins = ARRAY_SIZE(uart10_1_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart10_2_grp",
+		.pins = uart10_2_pins,
+		.num_pins = ARRAY_SIZE(uart10_2_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart10_3_grp",
+		.pins = uart10_3_pins,
+		.num_pins = ARRAY_SIZE(uart10_3_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "uart10_4_grp",
+		.pins = uart10_4_pins,
+		.num_pins = ARRAY_SIZE(uart10_4_pins),
+		.func = 0x9,
+	},
+	{
+		.name = "sc0_0_grp",
+		.pins = sc0_0_pins,
+		.num_pins = ARRAY_SIZE(sc0_0_pins),
+		.func = 0xA,
+	},
+	{
+		.name = "sc0_1_grp",
+		.pins = sc0_1_pins,
+		.num_pins = ARRAY_SIZE(sc0_1_pins),
+		.func = 0xA,
+	},
+	{
+		.name = "sc0_2_grp",
+		.pins = sc0_2_pins,
+		.num_pins = ARRAY_SIZE(sc0_2_pins),
+		.func = 0xA,
+	},
+	{
+		.name = "sc0_3_grp",
+		.pins = sc0_3_pins,
+		.num_pins = ARRAY_SIZE(sc0_3_pins),
+		.func = 0xA,
+	},
+	{
+		.name = "sc1_0_grp",
+		.pins = sc1_0_pins,
+		.num_pins = ARRAY_SIZE(sc1_0_pins),
+		.func = 0xA,
+	},
+	{
+		.name = "sc1_1_grp",
+		.pins = sc1_1_pins,
+		.num_pins = ARRAY_SIZE(sc1_1_pins),
+		.func = 0xA,
+	},
+	{
+		.name = "spi0_0_grp",
+		.pins = spi0_0_pins,
+		.num_pins = ARRAY_SIZE(spi0_0_pins),
+		.func = 0xB,
+	},
+	{
+		.name = "spi0_1_grp",
+		.pins = spi0_1_pins,
+		.num_pins = ARRAY_SIZE(spi0_1_pins),
+		.func = 0xB,
+
+	},
+	{
+		.name = "spi0_2_grp",
+		.pins = spi0_2_pins,
+		.num_pins = ARRAY_SIZE(spi0_2_pins),
+		.func = 0xB,
+	},
+	{
+		.name = "spi0_3_grp",
+		.pins = spi0_3_pins,
+		.num_pins = ARRAY_SIZE(spi0_3_pins),
+		.func = 0xB,
+	},
+	{
+		.name = "spi1_0_grp",
+		.pins = spi1_0_pins,
+		.num_pins = ARRAY_SIZE(spi1_0_pins),
+		.func = 0xB,
+	},
+	{
+		.name = "spi1_1_grp",
+		.pins = spi1_1_pins,
+		.num_pins = ARRAY_SIZE(spi1_1_pins),
+		.func = 0xB,
+	},
+	{
+		.name = "spi1_2_grp",
+		.pins = spi1_2_pins,
+		.num_pins = ARRAY_SIZE(spi1_2_pins),
+		.func = 0xB,
+	},
+	{
+		.name = "spi1_3_grp",
+		.pins = spi1_3_pins,
+		.num_pins = ARRAY_SIZE(spi1_3_pins),
+		.func = 0xB,
+	},
+	{
+		.name = "spi1_4_grp",
+		.pins = spi1_4_pins,
+		.num_pins = ARRAY_SIZE(spi1_4_pins),
+		.func = 0xB,
+	},
+	{
+		.name = "can0_0_grp",
+		.pins = can0_0_pins,
+		.num_pins = ARRAY_SIZE(can0_0_pins),
+		.func = 0xC,
+	},
+	{
+		.name = "can0_1_grp",
+		.pins = can0_1_pins,
+		.num_pins = ARRAY_SIZE(can0_1_pins),
+		.func = 0xC,
+	},
+	{
+		.name = "can0_2_grp",
+		.pins = can0_2_pins,
+		.num_pins = ARRAY_SIZE(can0_2_pins),
+		.func = 0xC,
+	},
+	{
+		.name = "can1_grp",
+		.pins = can1_pins,
+		.num_pins = ARRAY_SIZE(can1_pins),
+		.func = 0xC,
+	},
+	{
+		.name = "pwm0_0_grp",
+		.pins = pwm0_0_pin,
+		.num_pins = ARRAY_SIZE(pwm0_0_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm0_1_grp",
+		.pins = pwm0_1_pin,
+		.num_pins = ARRAY_SIZE(pwm0_1_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm0_2_grp",
+		.pins = pwm0_2_pin,
+		.num_pins = ARRAY_SIZE(pwm0_2_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm0_3_grp",
+		.pins = pwm0_3_pin,
+		.num_pins = ARRAY_SIZE(pwm0_3_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm1_0_grp",
+		.pins = pwm1_0_pin,
+		.num_pins = ARRAY_SIZE(pwm1_0_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm1_1_grp",
+		.pins = pwm1_1_pin,
+		.num_pins = ARRAY_SIZE(pwm1_1_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm1_2_grp",
+		.pins = pwm1_2_pin,
+		.num_pins = ARRAY_SIZE(pwm1_2_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm2_0_grp",
+		.pins = pwm2_0_pin,
+		.num_pins = ARRAY_SIZE(pwm2_0_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm2_1_grp",
+		.pins = pwm2_1_pin,
+		.num_pins = ARRAY_SIZE(pwm2_1_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm2_2_grp",
+		.pins = pwm2_2_pin,
+		.num_pins = ARRAY_SIZE(pwm2_2_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm3_0_grp",
+		.pins = pwm3_0_pin,
+		.num_pins = ARRAY_SIZE(pwm3_0_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm3_1_grp",
+		.pins = pwm3_1_pin,
+		.num_pins = ARRAY_SIZE(pwm3_1_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "pwm3_2_grp",
+		.pins = pwm3_2_pin,
+		.num_pins = ARRAY_SIZE(pwm3_2_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "rtc_0_grp",
+		.pins = rtc_0_pin,
+		.num_pins = ARRAY_SIZE(rtc_0_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "rtc_1_grp",
+		.pins = rtc_1_pin,
+		.num_pins = ARRAY_SIZE(rtc_1_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer0_0_grp",
+		.pins = etimer0_0_pin,
+		.num_pins = ARRAY_SIZE(etimer0_0_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer0_1_grp",
+		.pins = etimer0_1_pin,
+		.num_pins = ARRAY_SIZE(etimer0_1_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer0_2_grp",
+		.pins = etimer0_2_pin,
+		.num_pins = ARRAY_SIZE(etimer0_2_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "etimer0_3_grp",
+		.pins = etimer0_3_pin,
+		.num_pins = ARRAY_SIZE(etimer0_3_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "etimer1_0_grp",
+		.pins = etimer1_0_pin,
+		.num_pins = ARRAY_SIZE(etimer1_0_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer1_1_grp",
+		.pins = etimer1_1_pin,
+		.num_pins = ARRAY_SIZE(etimer1_1_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer1_2_grp",
+		.pins = etimer1_2_pin,
+		.num_pins = ARRAY_SIZE(etimer1_2_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer1_3_grp",
+		.pins = etimer1_3_pin,
+		.num_pins = ARRAY_SIZE(etimer1_3_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer2_0_grp",
+		.pins = etimer2_0_pin,
+		.num_pins = ARRAY_SIZE(etimer2_0_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer2_1_grp",
+		.pins = etimer2_1_pin,
+		.num_pins = ARRAY_SIZE(etimer2_1_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer2_2_grp",
+		.pins = etimer2_2_pin,
+		.num_pins = ARRAY_SIZE(etimer2_2_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer2_3_grp",
+		.pins = etimer2_3_pin,
+		.num_pins = ARRAY_SIZE(etimer2_3_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer3_0_grp",
+		.pins = etimer3_0_pin,
+		.num_pins = ARRAY_SIZE(etimer3_0_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer3_1_grp",
+		.pins = etimer3_1_pin,
+		.num_pins = ARRAY_SIZE(etimer3_1_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer3_2_grp",
+		.pins = etimer3_2_pin,
+		.num_pins = ARRAY_SIZE(etimer3_2_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "etimer3_3_grp",
+		.pins = etimer3_3_pin,
+		.num_pins = ARRAY_SIZE(etimer3_3_pin),
+		.func = 0xD,
+	},
+	{
+		.name = "jtag_grp",
+		.pins = jtag_pins,
+		.num_pins = ARRAY_SIZE(jtag_pins),
+		.func = 0xF,
+	},
+	{
+		.name = "eint0_0_grp",
+		.pins = eint0_0_pin,
+		.num_pins = ARRAY_SIZE(eint0_0_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint0_1_grp",
+		.pins = eint0_1_pin,
+		.num_pins = ARRAY_SIZE(eint0_1_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint1_0_grp",
+		.pins = eint1_0_pin,
+		.num_pins = ARRAY_SIZE(eint1_0_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint1_1_grp",
+		.pins = eint1_1_pin,
+		.num_pins = ARRAY_SIZE(eint1_1_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint2_0_grp",
+		.pins = eint2_0_pin,
+		.num_pins = ARRAY_SIZE(eint2_0_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint2_1_grp",
+		.pins = eint2_1_pin,
+		.num_pins = ARRAY_SIZE(eint2_1_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint3_0_grp",
+		.pins = eint3_0_pin,
+		.num_pins = ARRAY_SIZE(eint3_0_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint3_1_grp",
+		.pins = eint3_1_pin,
+		.num_pins = ARRAY_SIZE(eint3_1_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint4_0_grp",
+		.pins = eint4_0_pin,
+		.num_pins = ARRAY_SIZE(eint4_0_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint4_1_grp",
+		.pins = eint4_1_pin,
+		.num_pins = ARRAY_SIZE(eint4_1_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint5_0_grp",
+		.pins = eint5_0_pin,
+		.num_pins = ARRAY_SIZE(eint5_0_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint5_1_grp",
+		.pins = eint5_1_pin,
+		.num_pins = ARRAY_SIZE(eint5_1_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint6_0_grp",
+		.pins = eint6_0_pin,
+		.num_pins = ARRAY_SIZE(eint6_0_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint6_1_grp",
+		.pins = eint6_1_pin,
+		.num_pins = ARRAY_SIZE(eint6_1_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint7_0_grp",
+		.pins = eint7_0_pin,
+		.num_pins = ARRAY_SIZE(eint7_0_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "eint7_1_grp",
+		.pins = eint7_1_pin,
+		.num_pins = ARRAY_SIZE(eint7_1_pin),
+		.func = 0xF,
+	},
+	{
+		.name = "ebi8_0_grp",
+		.pins = ebi8_0_pin,
+		.num_pins = ARRAY_SIZE(ebi8_0_pin),
+		.func = 0xE,
+	},
+	{
+		.name = "ebi8_1_grp",
+		.pins = ebi8_1_pin,
+		.num_pins = ARRAY_SIZE(ebi8_1_pin),
+		.func = 0xE,
+	},
+	{
+		.name = "ebi8_2_grp",
+		.pins = ebi8_2_pin,
+		.num_pins = ARRAY_SIZE(ebi8_2_pin),
+		.func = 0xE,
+	},
+	{
+		.name = "ebi8_3_grp",
+		.pins = ebi8_3_pin,
+		.num_pins = ARRAY_SIZE(ebi8_3_pin),
+		.func = 0xE,
+	},
+	{
+		.name = "ebi8_4_grp",
+		.pins = ebi8_4_pin,
+		.num_pins = ARRAY_SIZE(ebi8_4_pin),
+		.func = 0xE,
+	},
+	{
+		.name = "ebi16_0_grp",
+		.pins = ebi16_0_pin,
+		.num_pins = ARRAY_SIZE(ebi16_0_pin),
+		.func = 0xE,
+	},
+	{
+		.name = "ebi16_1_grp",
+		.pins = ebi16_1_pin,
+		.num_pins = ARRAY_SIZE(ebi16_1_pin),
+		.func = 0xE,
+	},
+	{
+		.name = "ebi16_2_grp",
+		.pins = ebi16_2_pin,
+		.num_pins = ARRAY_SIZE(ebi16_2_pin),
+		.func = 0xE,
+	},
+	{
+		.name = "ebi16_3_grp",
+		.pins = ebi16_3_pin,
+		.num_pins = ARRAY_SIZE(ebi16_3_pin),
+		.func = 0xE,
+	},
+	{
+		.name = "ebi16_4_grp",
+		.pins = ebi16_4_pin,
+		.num_pins = ARRAY_SIZE(ebi16_4_pin),
+		.func = 0xE,
+	},
+};
+
+static int nuc970_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(nuc970_pinctrl_groups);
+}
+
+static const char *nuc970_get_group_name(struct pinctrl_dev *pctldev,
+				       unsigned selector)
+{;
+	return nuc970_pinctrl_groups[selector].name;
+}
+
+static int nuc970_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,
+			       const unsigned ** pins,
+			       unsigned * num_pins)
+{
+	*pins = (unsigned *) nuc970_pinctrl_groups[selector].pins;
+	*num_pins = nuc970_pinctrl_groups[selector].num_pins;
+	return 0;
+}
+
+static struct pinctrl_ops nuc970_pctrl_ops = {
+	.get_groups_count = nuc970_get_groups_count,
+	.get_group_name = nuc970_get_group_name,
+	.get_group_pins = nuc970_get_group_pins,
+};
+
+struct nuc970_pmx_func {
+	const char *name;
+	const char * const *groups;
+	const unsigned num_groups;
+};
+
+static const char * const emac0_groups[] = {"emac0_grp"};
+static const char * const emac1_groups[] = {"emac1_grp"};
+static const char * const pps0_groups[] = {"pps0_grp"};
+static const char * const pps1_groups[] = {"pps1_grp"};
+static const char * const lcd0_groups[] = {"lcd0_grp"};
+static const char * const lcd1_groups[] = {"lcd1_grp"};
+static const char * const lcd2_groups[] = {"lcd2_grp"};
+static const char * const vcap_groups[] = {"vcap_grp"};
+static const char * const kpi_row_groups[] = {"kpi_0_grp", "kpi_4_grp"};
+static const char * const kpi_3row_groups[] = {"kpi_8_grp"};
+static const char * const kpi_2col_groups[] = {"kpi_1_grp", "kpi_5_grp"};
+static const char * const kpi_4col_groups[] = {"kpi_2_grp", "kpi_6_grp"};
+static const char * const kpi_8col_groups[] = {"kpi_3_grp", "kpi_7_grp"};
+static const char * const sd0_groups[] = {"sd0_grp"};
+static const char * const sd1_groups[] = {"sd1_0_grp", "sd1_1_grp", "sd1_2_grp"};
+static const char * const sd01_groups[] = {"sd01_0_grp", "sd01_1_grp", "sd01_2_grp"};
+static const char * const nand_groups[] = {"nand_0_grp", "nand_1_grp"};
+static const char * const nand_ctl1_groups[] = {"nand_2_grp", "nand_3_grp"};
+static const char * const emmc_groups[] = {"emmc_0_grp", "emmc_1_grp"};
+static const char * const usbh_ppwr_groups[] = {"usbh_pe_grp", "usbh_pf_grp", "usbh_oc_grp" };
+static const char * const usbd_groups[] = {"usbd_grp"};
+static const char * const i2c0_groups[] = {"i2c0_grp"};
+static const char * const i2c1_groups[] = {"i2c1_1_grp", "i2c1_2_grp", "i2c1_3_grp"};
+static const char * const i2s_groups[] = {"i2s_grp"};
+static const char * const uart0_groups[] = {"uart0_grp"};
+static const char * const uart1_groups[] = {"uart1_0_grp", "uart1_3_grp", "uart1_5_grp"};
+static const char * const uart1_fc_groups[] = {"uart1_1_grp", "uart1_4_grp", "uart1_6_grp"};
+static const char * const uart1_ff_groups[] = {"uart1_2_grp"};
+static const char * const uart2_groups[] = {"uart2_0_grp"};
+static const char * const uart2_fc_groups[] = {"uart2_1_grp"};
+static const char * const uart3_groups[] = {"uart3_grp"};
+static const char * const uart4_groups[] = {"uart4_0_grp", "uart4_2_grp", "uart4_4_grp"};
+static const char * const uart4_fc_groups[] = {"uart4_1_grp", "uart4_3_grp"};
+static const char * const uart5_groups[] = {"uart5_grp"};
+static const char * const uart6_groups[] = {"uart6_0_grp", "uart6_2_grp"};
+static const char * const uart6_fc_groups[] = {"uart6_1_grp", "uart6_3_grp"};
+static const char * const uart7_groups[] = {"uart7_0_grp", "uart7_1_grp"};
+static const char * const uart8_groups[] = {"uart8_0_grp", "uart8_2_grp", "uart8_4_grp"};
+static const char * const uart8_fc_groups[] = {"uart8_1_grp", "uart8_3_grp", "uart8_5_grp"};
+static const char * const uart9_groups[] = {"uart9_0_grp", "uart9_1_grp", "uart9_2_grp"};
+static const char * const uart10_groups[] = {"uart10_0_grp", "uart10_1_grp", "uart10_3_grp"};
+static const char * const uart10_fc_groups[] = {"uart10_2_grp", "uart10_4_grp"};
+static const char * const sc0_groups[] = {"sc0_0_grp", "sc0_1_grp"};
+static const char * const sc1_groups[] = {"sc1_0_grp"};
+static const char * const scuart0_groups[] = {"sc0_2_grp", "sc0_3_grp"};
+static const char * const scuart1_groups[] = {"sc1_1_grp"};
+static const char * const spi0_groups[] = {"spi0_0_grp"};
+static const char * const spi0_quad_groups[] = {"spi0_1_grp"};
+static const char * const spi0_ss1_groups[] = {"spi0_2_grp", "spi0_3_grp"};
+static const char * const spi1_groups[] = {"spi1_0_grp", "spi1_4_grp"};
+static const char * const spi1_quad_groups[] = {"spi1_2_grp"};
+static const char * const spi1_ss1_groups[] = {"spi1_1_grp", "spi1_3_grp"};
+static const char * const can0_groups[] = {"can0_0_grp", "can0_1_grp", "can0_2_grp"};
+static const char * const can1_groups[] = {"can1_grp"};
+static const char * const pwm0_groups[] = {"pwm0_0_grp", "pwm0_1_grp", "pwm0_2_grp", "pwm0_3_grp"};
+static const char * const pwm1_groups[] = {"pwm1_0_grp", "pwm1_1_grp", "pwm1_2_grp"};
+static const char * const pwm2_groups[] = {"pwm2_0_grp", "pwm2_1_grp", "pwm2_2_grp"};
+static const char * const pwm3_groups[] = {"pwm3_0_grp", "pwm3_1_grp", "pwm3_2_grp"};
+static const char * const rtc_groups[] = {"rtc_0_grp", "rtc_1_grp"};
+static const char * const etimer0_tgl_groups[] = {"etimer0_0_grp", "etimer0_2_grp"};
+static const char * const etimer0_cap_groups[] = {"etimer0_1_grp", "etimer0_3_grp"};
+static const char * const etimer1_tgl_groups[] = {"etimer1_0_grp", "etimer1_2_grp"};
+static const char * const etimer1_cap_groups[] = {"etimer1_1_grp", "etimer1_3_grp"};
+static const char * const etimer2_tgl_groups[] = {"etimer2_0_grp", "etimer2_2_grp"};
+static const char * const etimer2_cap_groups[] = {"etimer2_1_grp", "etimer2_3_grp"};
+static const char * const etimer3_tgl_groups[] = {"etimer3_0_grp", "etimer3_2_grp"};
+static const char * const etimer3_cap_groups[] = {"etimer3_1_grp", "etimer3_3_grp"};
+static const char * const jtag_groups[] = {"jtag_grp"};
+static const char * const eint0_groups[] = {"eint0_0_grp", "eint0_1_grp"};
+static const char * const eint1_groups[] = {"eint1_0_grp", "eint1_1_grp"};
+static const char * const eint2_groups[] = {"eint2_0_grp", "eint2_1_grp"};
+static const char * const eint3_groups[] = {"eint3_0_grp", "eint3_1_grp"};
+static const char * const eint4_groups[] = {"eint4_0_grp", "eint4_1_grp"};
+static const char * const eint5_groups[] = {"eint5_0_grp", "eint5_1_grp"};
+static const char * const eint6_groups[] = {"eint6_0_grp", "eint6_1_grp"};
+static const char * const eint7_groups[] = {"eint7_0_grp", "eint7_1_grp"};
+
+static const char * const ebi8_0_groups[] = {"ebi8_0_grp"};
+static const char * const ebi8_1_groups[] = {"ebi8_1_grp"};
+static const char * const ebi8_2_groups[] = {"ebi8_2_grp"};
+static const char * const ebi8_3_groups[] = {"ebi8_3_grp"};
+static const char * const ebi8_4_groups[] = {"ebi8_4_grp"};;
+static const char * const ebi16_0_groups[] = {"ebi16_0_grp"};
+static const char * const ebi16_1_groups[] = {"ebi16_1_grp"};
+static const char * const ebi16_2_groups[] = {"ebi16_2_grp"};
+static const char * const ebi16_3_groups[] = {"ebi16_3_grp"};
+static const char * const ebi16_4_groups[] = {"ebi16_4_grp"};
+
+static const struct nuc970_pmx_func nuc970_functions[] = {
+	{
+		.name = "emac0",
+		.groups = emac0_groups,
+		.num_groups = ARRAY_SIZE(emac0_groups),
+	},
+	{
+		.name = "emac1",
+		.groups = emac1_groups,
+		.num_groups = ARRAY_SIZE(emac1_groups),
+	},
+	{
+		.name = "pps0",
+		.groups = pps0_groups,
+		.num_groups = ARRAY_SIZE(pps0_groups),
+	},
+	{
+		.name = "pps1",
+		.groups = pps1_groups,
+		.num_groups = ARRAY_SIZE(pps1_groups),
+	},
+	{
+		.name = "lcd0",
+		.groups = lcd0_groups,
+		.num_groups = ARRAY_SIZE(lcd0_groups),
+	},
+	{
+		.name = "lcd1",
+		.groups = lcd1_groups,
+		.num_groups = ARRAY_SIZE(lcd1_groups),
+	},
+	{
+		.name = "lcd2",
+		.groups = lcd2_groups,
+		.num_groups = ARRAY_SIZE(lcd2_groups),
+	},
+	{
+		.name = "vcap",
+		.groups = vcap_groups,
+		.num_groups = ARRAY_SIZE(vcap_groups),
+	},
+	{
+		.name = "kpi_row",
+		.groups = kpi_row_groups,
+		.num_groups = ARRAY_SIZE(kpi_row_groups),
+	},
+	{
+		.name = "kpi_3row",
+		.groups = kpi_3row_groups,
+		.num_groups = ARRAY_SIZE(kpi_3row_groups),
+	},
+	{
+		.name = "kpi_2col",
+		.groups = kpi_2col_groups,
+		.num_groups = ARRAY_SIZE(kpi_2col_groups),
+	},
+	{
+		.name = "kpi_4col",
+		.groups = kpi_4col_groups,
+		.num_groups = ARRAY_SIZE(kpi_4col_groups),
+	},
+	{
+		.name = "kpi_8col",
+		.groups = kpi_8col_groups,
+		.num_groups = ARRAY_SIZE(kpi_8col_groups),
+	},
+	{
+		.name = "sd0",
+		.groups = sd0_groups,
+		.num_groups = ARRAY_SIZE(sd0_groups),
+	},
+	{
+		.name = "sd1",
+		.groups = sd1_groups,
+		.num_groups = ARRAY_SIZE(sd1_groups),
+	},
+	{
+		.name = "sd01",
+		.groups = sd01_groups,
+		.num_groups = ARRAY_SIZE(sd01_groups),
+	},
+	{
+		.name = "nand",
+		.groups = nand_groups,
+		.num_groups = ARRAY_SIZE(nand_groups),
+	},
+	{
+		.name = "nand_ctl1",
+		.groups = nand_ctl1_groups,
+		.num_groups = ARRAY_SIZE(nand_ctl1_groups),
+	},
+	{
+		.name = "emmc",
+		.groups = emmc_groups,
+		.num_groups = ARRAY_SIZE(emmc_groups),
+	},
+	{
+		.name = "usbh_ppwr",
+		.groups = usbh_ppwr_groups,
+		.num_groups = ARRAY_SIZE(usbh_ppwr_groups),
+	},
+	{
+		.name = "usbd",
+		.groups = usbd_groups,
+		.num_groups = ARRAY_SIZE(usbd_groups),
+	},
+	{
+		.name = "i2c0",
+		.groups = i2c0_groups,
+		.num_groups = ARRAY_SIZE(i2c0_groups),
+	},
+	{
+		.name = "i2c1",
+		.groups = i2c1_groups,
+		.num_groups = ARRAY_SIZE(i2c1_groups),
+	},
+	{
+		.name = "i2s",
+		.groups = i2s_groups,
+		.num_groups = ARRAY_SIZE(i2s_groups),
+	},
+	{
+		.name = "uart0",
+		.groups = uart0_groups,
+		.num_groups = ARRAY_SIZE(uart0_groups),
+	},
+	{
+		.name = "uart1",
+		.groups = uart1_groups,
+		.num_groups = ARRAY_SIZE(uart1_groups),
+	},
+	{
+		.name = "uart1_fc",
+		.groups = uart1_fc_groups,
+		.num_groups = ARRAY_SIZE(uart1_fc_groups),
+	},
+	{
+		.name = "uart1_ff",
+		.groups = uart1_ff_groups,
+		.num_groups = ARRAY_SIZE(uart1_ff_groups),
+	},
+	{
+		.name = "uart2",
+		.groups = uart2_groups,
+		.num_groups = ARRAY_SIZE(uart2_groups),
+	},
+	{
+		.name = "uart2_fc",
+		.groups = uart2_fc_groups,
+		.num_groups = ARRAY_SIZE(uart2_fc_groups),
+	},
+	{
+		.name = "uart3",
+		.groups = uart3_groups,
+		.num_groups = ARRAY_SIZE(uart3_groups),
+	},
+	{
+		.name = "uart4",
+		.groups = uart4_groups,
+		.num_groups = ARRAY_SIZE(uart4_groups),
+	},
+	{
+		.name = "uart4_fc",
+		.groups = uart4_fc_groups,
+		.num_groups = ARRAY_SIZE(uart4_fc_groups),
+	},
+	{
+		.name = "uart5",
+		.groups = uart5_groups,
+		.num_groups = ARRAY_SIZE(uart5_groups),
+	},
+	{
+		.name = "uart6",
+		.groups = uart6_groups,
+		.num_groups = ARRAY_SIZE(uart6_groups),
+	},
+	{
+		.name = "uart6_fc",
+		.groups = uart6_fc_groups,
+		.num_groups = ARRAY_SIZE(uart6_fc_groups),
+	},
+	{
+		.name = "uart7",
+		.groups = uart7_groups,
+		.num_groups = ARRAY_SIZE(uart7_groups),
+	},
+	{
+		.name = "uart8",
+		.groups = uart8_groups,
+		.num_groups = ARRAY_SIZE(uart8_groups),
+	},
+	{
+		.name = "uart8_fc",
+		.groups = uart8_fc_groups,
+		.num_groups = ARRAY_SIZE(uart8_fc_groups),
+	},
+	{
+		.name = "uart9",
+		.groups = uart9_groups,
+		.num_groups = ARRAY_SIZE(uart9_groups),
+	},
+	{
+		.name = "uart10",
+		.groups = uart10_groups,
+		.num_groups = ARRAY_SIZE(uart10_groups),
+	},
+	{
+		.name = "uart10_fc",
+		.groups = uart10_fc_groups,
+		.num_groups = ARRAY_SIZE(uart10_fc_groups),
+	},
+	{
+		.name = "sc0",
+		.groups = sc0_groups,
+		.num_groups = ARRAY_SIZE(sc0_groups),
+	},
+	{
+		.name = "sc1",
+		.groups = sc1_groups,
+		.num_groups = ARRAY_SIZE(sc1_groups),
+	},
+	{
+		.name = "scuart0",
+		.groups = scuart0_groups,
+		.num_groups = ARRAY_SIZE(scuart0_groups),
+	},
+	{
+		.name = "scuart1",
+		.groups = scuart1_groups,
+		.num_groups = ARRAY_SIZE(scuart1_groups),
+	},
+	{
+		.name = "spi0",
+		.groups = spi0_groups,
+		.num_groups = ARRAY_SIZE(spi0_groups),
+	},
+	{
+		.name = "spi0_quad",
+		.groups = spi0_quad_groups,
+		.num_groups = ARRAY_SIZE(spi0_quad_groups),
+	},
+	{
+		.name = "spi0_ss1",
+		.groups = spi0_ss1_groups,
+		.num_groups = ARRAY_SIZE(spi0_ss1_groups),
+	},
+	{
+		.name = "spi1",
+		.groups = spi1_groups,
+		.num_groups = ARRAY_SIZE(spi1_groups),
+	},
+	{
+		.name = "spi1_quad",
+		.groups = spi1_quad_groups,
+		.num_groups = ARRAY_SIZE(spi1_quad_groups),
+	},
+	{
+		.name = "spi1_ss1",
+		.groups = spi1_ss1_groups,
+		.num_groups = ARRAY_SIZE(spi1_ss1_groups),
+	},
+	{
+		.name = "can0",
+		.groups = can0_groups,
+		.num_groups = ARRAY_SIZE(can0_groups),
+	},
+	{
+		.name = "can1",
+		.groups = can1_groups,
+		.num_groups = ARRAY_SIZE(can1_groups),
+	},
+	{
+		.name = "pwm0",
+		.groups = pwm0_groups,
+		.num_groups = ARRAY_SIZE(pwm0_groups),
+	},
+	{
+		.name = "pwm1",
+		.groups = pwm1_groups,
+		.num_groups = ARRAY_SIZE(pwm1_groups),
+	},
+	{
+		.name = "pwm2",
+		.groups = pwm2_groups,
+		.num_groups = ARRAY_SIZE(pwm2_groups),
+	},
+	{
+		.name = "pwm3",
+		.groups = pwm3_groups,
+		.num_groups = ARRAY_SIZE(pwm3_groups),
+	},
+	{
+		.name = "rtc",
+		.groups = rtc_groups,
+		.num_groups = ARRAY_SIZE(rtc_groups),
+	},
+	{
+		.name = "etimer0_tgl",
+		.groups = etimer0_tgl_groups,
+		.num_groups = ARRAY_SIZE(etimer0_tgl_groups),
+	},
+	{
+		.name = "etimer0_cap",
+
+		.groups = etimer0_cap_groups,
+		.num_groups = ARRAY_SIZE(etimer0_cap_groups),
+	},
+	{
+		.name = "etimer1_tgl",
+		.groups = etimer1_tgl_groups,
+		.num_groups = ARRAY_SIZE(etimer1_tgl_groups),
+	},
+	{
+		.name = "etimer1_cap",
+		.groups = etimer1_cap_groups,
+		.num_groups = ARRAY_SIZE(etimer1_cap_groups),
+	},
+	{
+		.name = "etimer2_tgl",
+		.groups = etimer2_tgl_groups,
+		.num_groups = ARRAY_SIZE(etimer2_tgl_groups),
+	},
+	{
+		.name = "etimer2_cap",
+		.groups = etimer2_cap_groups,
+		.num_groups = ARRAY_SIZE(etimer2_cap_groups),
+	},
+	{
+		.name = "etimer3_tgl",
+		.groups = etimer3_tgl_groups,
+		.num_groups = ARRAY_SIZE(etimer3_tgl_groups),
+	},
+	{
+		.name = "etimer3_cap",
+		.groups = etimer3_cap_groups,
+		.num_groups = ARRAY_SIZE(etimer3_cap_groups),
+	},
+	{
+		.name = "jtag",
+		.groups = jtag_groups,
+		.num_groups = ARRAY_SIZE(jtag_groups),
+	},
+	{
+		.name = "eint0",
+		.groups = eint0_groups,
+		.num_groups = ARRAY_SIZE(eint0_groups),
+	},
+	{
+		.name = "eint1",
+		.groups = eint1_groups,
+		.num_groups = ARRAY_SIZE(eint1_groups),
+	},
+	{
+		.name = "eint2",
+		.groups = eint2_groups,
+		.num_groups = ARRAY_SIZE(eint2_groups),
+	},
+	{
+		.name = "eint3",
+		.groups = eint3_groups,
+		.num_groups = ARRAY_SIZE(eint3_groups),
+	},
+	{
+		.name = "eint4",
+		.groups = eint4_groups,
+		.num_groups = ARRAY_SIZE(eint4_groups),
+	},
+	{
+		.name = "eint5",
+		.groups = eint5_groups,
+		.num_groups = ARRAY_SIZE(eint5_groups),
+	},
+	{
+		.name = "eint6",
+		.groups = eint6_groups,
+		.num_groups = ARRAY_SIZE(eint6_groups),
+	},
+	{
+		.name = "eint7",
+		.groups = eint7_groups,
+		.num_groups = ARRAY_SIZE(eint7_groups),
+	},
+	{
+		.name = "ebi_8_0",
+		.groups = ebi8_0_groups,
+		.num_groups = ARRAY_SIZE(ebi8_0_groups),
+	},
+	{
+		.name = "ebi_8_1",
+		.groups = ebi8_1_groups,
+		.num_groups = ARRAY_SIZE(ebi8_1_groups),
+	},
+	{
+		.name = "ebi_8_2",
+		.groups = ebi8_2_groups,
+		.num_groups = ARRAY_SIZE(ebi8_2_groups),
+	},
+	{
+		.name = "ebi_8_3",
+		.groups = ebi8_3_groups,
+		.num_groups = ARRAY_SIZE(ebi8_3_groups),
+	},
+	{
+		.name = "ebi_8_4",
+		.groups = ebi8_4_groups,
+		.num_groups = ARRAY_SIZE(ebi8_4_groups),
+	},
+	{
+		.name = "ebi_16_0",
+		.groups = ebi16_0_groups,
+		.num_groups = ARRAY_SIZE(ebi16_0_groups),
+	},
+	{
+		.name = "ebi_16_1",
+		.groups = ebi16_1_groups,
+		.num_groups = ARRAY_SIZE(ebi16_1_groups),
+	},
+	{
+		.name = "ebi_16_2",
+		.groups = ebi16_2_groups,
+		.num_groups = ARRAY_SIZE(ebi16_2_groups),
+	},
+	{
+		.name = "ebi_16_3",
+		.groups = ebi16_3_groups,
+		.num_groups = ARRAY_SIZE(ebi16_3_groups),
+	},	
+	{
+		.name = "ebi_16_4",
+		.groups = ebi16_4_groups,
+		.num_groups = ARRAY_SIZE(ebi16_4_groups),
+	},
+	
+};
+
+
+int nuc970_get_functions_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(nuc970_functions);
+}
+
+const char *nuc970_get_fname(struct pinctrl_dev *pctldev, unsigned selector)
+{
+	return nuc970_functions[selector].name;
+}
+
+static int nuc970_get_groups(struct pinctrl_dev *pctldev, unsigned selector,
+			  const char * const **groups,
+			  unsigned * const num_groups)
+{
+	*groups = nuc970_functions[selector].groups;
+	*num_groups = nuc970_functions[selector].num_groups;
+	return 0;
+}
+
+/*
+ * selector = data.nux.func, which is entry number in nuc970_functions,
+ * and group = data.mux.group, which is entry number in nuc970_pmx_func
+ * group is not used since some function use different setting between
+ * different ports. for example UART....
+ */
+int nuc970_enable(struct pinctrl_dev *pctldev, unsigned selector,
+		unsigned group)
+{
+	unsigned int i, j;
+	unsigned int reg, offset;
+
+	//printk("enable =>%x %x  %s\n", selector, group, nuc970_pinctrl_groups[group].name);
+	for(i = 0; i < nuc970_pinctrl_groups[group].num_pins; i++) {
+		j = nuc970_pinctrl_groups[group].pins[i];
+		offset = (j >> 4) * 8 + ((j & 0x8) ? 4 : 0);
+
+		reg = __raw_readl(REG_MFP_GPA_L + offset);
+		reg = (reg & ~(0xF << ((j & 0x7) * 4))) | (nuc970_pinctrl_groups[group].func << ((j & 0x7) * 4));
+
+		__raw_writel(reg, REG_MFP_GPA_L + offset);
+	}
+
+	/* SD0 pin value is 0x6, SD1 PI pin value is 0x4, should set the correct value */
+	if (strcmp(nuc970_pinctrl_groups[group].name, "sd01_0_grp") == 0)
+	{
+		for(i = 8; i < nuc970_pinctrl_groups[group].num_pins; i++) {
+			j = nuc970_pinctrl_groups[group].pins[i];
+			offset = (j >> 4) * 8 + ((j & 0x8) ? 4 : 0);
+
+			reg = __raw_readl(REG_MFP_GPA_L + offset);
+			reg = (reg & ~(0xF << ((j & 0x7) * 4))) | (0x4 << ((j & 0x7) * 4));
+
+			__raw_writel(reg, REG_MFP_GPA_L + offset);
+		}
+	}
+	return 0;
+}
+
+#if 0 //kernel 3.x.y
+/*
+ * By disable a function, we'll switch it back to GPIO
+ */
+void nuc970_disable(struct pinctrl_dev *pctldev, unsigned selector,
+		unsigned group)
+{
+
+	unsigned int i, j;
+	unsigned int reg, offset;
+
+	//printk("disable =>%x %x\n", selector, group);
+	for(i = 0; i < nuc970_pinctrl_groups[group].num_pins; i++) {
+		j = nuc970_pinctrl_groups[group].pins[i];
+		offset = (j >> 4) * 8 + ((j & 0x8) ? 4 : 0);
+
+		reg = __raw_readl(REG_MFP_GPA_L + offset);
+		reg &= ~(0xF << ((j & 0x7) * 4));
+		__raw_writel(reg, REG_MFP_GPA_L + offset);
+	}
+
+	return;
+}
+#endif
+
+static int nuc970_set_mux(struct pinctrl_dev *pctldev, unsigned selector,
+		unsigned group)
+{
+  return nuc970_enable(pctldev, selector, group);
+}
+
+
+struct pinmux_ops nuc970_pmxops = {
+	.get_functions_count = nuc970_get_functions_count,
+	.get_function_name = nuc970_get_fname,
+	.get_function_groups = nuc970_get_groups,
+//	.enable = nuc970_enable,
+//	.disable = nuc970_disable,
+    .set_mux = nuc970_set_mux,
+	.strict  = true,
+};
+
+static struct pinctrl_desc nuc970_pinctrl_desc = {
+	.name = "nuc970-pinctrl_desc",
+	.pins = nuc970_pins,
+	.npins = ARRAY_SIZE(nuc970_pins),
+	.pctlops = &nuc970_pctrl_ops,
+	.pmxops = &nuc970_pmxops,
+	.owner = THIS_MODULE,
+};
+
+static const struct pinctrl_map nuc970_pinmap[] = {
+	{
+		.dev_name = "nuc970-emac0",
+		.name = PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "emac0",
+		.data.mux.group = "emac0_grp",
+	},
+	{
+		.dev_name = "nuc970-emac1",
+		.name = PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "emac1",
+		.data.mux.group = "emac1_grp",
+	},
+	{
+		.dev_name = "nuc970-emac0",
+		.name = "pps0",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pps0",
+		.data.mux.group = "pps0_grp",
+	},
+	{
+		.dev_name = "nuc970-emac1",
+		.name = "pps1",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pps1",
+		.data.mux.group = "pps1_grp",
+	},
+	{
+		.dev_name = "nuc970-lcd",
+		.name = "lcd-16bit",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "lcd0",
+		.data.mux.group = "lcd0_grp",
+	},
+	{
+		.dev_name = "nuc970-lcd",
+		.name = "lcd-18bit",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "lcd0",
+		.data.mux.group = "lcd0_grp",
+	},
+	{
+		.dev_name = "nuc970-lcd",
+		.name = "lcd-18bit",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "lcd1",
+		.data.mux.group = "lcd1_grp",
+	},
+		{
+		.dev_name = "nuc970-lcd",
+		.name = "lcd-24bit",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "lcd0",
+		.data.mux.group = "lcd0_grp",
+	},
+	{
+		.dev_name = "nuc970-lcd",
+		.name = "lcd-24bit",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "lcd1",
+		.data.mux.group = "lcd1_grp",
+	},
+	{
+		.dev_name = "nuc970-lcd",
+		.name = "lcd-24bit",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "lcd2",
+		.data.mux.group = "lcd2_grp",
+	},
+	{
+		.dev_name = "nuc970-videoin",
+		.name = PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "vcap",
+		.data.mux.group = "vcap_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x2-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_row",
+		.data.mux.group = "kpi_0_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x2-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_2col",
+		.data.mux.group = "kpi_1_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_3x2-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_3row",
+		.data.mux.group = "kpi_8_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_3x2-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_2col",
+		.data.mux.group = "kpi_1_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x4-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_row",
+		.data.mux.group = "kpi_0_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x4-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_2col",
+		.data.mux.group = "kpi_1_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x4-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_4col",
+		.data.mux.group = "kpi_2_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x8-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_row",
+		.data.mux.group = "kpi_0_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x8-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_2col",
+		.data.mux.group = "kpi_1_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x8-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_4col",
+		.data.mux.group = "kpi_2_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x8-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_8col",
+		.data.mux.group = "kpi_3_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x2-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_row",
+		.data.mux.group = "kpi_4_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x2-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_2col",
+		.data.mux.group = "kpi_5_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x4-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_row",
+		.data.mux.group = "kpi_4_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x4-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_2col",
+		.data.mux.group = "kpi_5_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x4-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_4col",
+		.data.mux.group = "kpi_6_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x8-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_row",
+		.data.mux.group = "kpi_4_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x8-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_2col",
+		.data.mux.group = "kpi_5_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x8-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_4col",
+		.data.mux.group = "kpi_6_grp",
+	},
+	{
+		.dev_name = "nuc970-kpi",
+		.name = "kpi_4x8-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "kpi_8col",
+		.data.mux.group = "kpi_7_grp",
+	},
+	{
+		.dev_name = "nuc970-sdh",
+		.name = "sd0", //PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sd0",
+		.data.mux.group = "sd0_grp",
+	},
+	{
+		.dev_name = "nuc970-sdh",
+		.name = "sd1-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sd1",
+		.data.mux.group = "sd1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-sdh",
+		.name = "sd1-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sd1",
+		.data.mux.group = "sd1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-sdh",
+		.name = "sd1-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sd1",
+		.data.mux.group = "sd1_2_grp",
+	},
+	{
+		.dev_name = "nuc970-sdh",
+		.name = "sd01-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sd01",
+		.data.mux.group = "sd01_0_grp",
+	},
+	{
+		.dev_name = "nuc970-sdh",
+		.name = "sd01-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sd01",
+		.data.mux.group = "sd01_1_grp",
+	},
+	{
+		.dev_name = "nuc970-sdh",
+		.name = "sd01-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sd01",
+		.data.mux.group = "sd01_2_grp",
+	},
+	{
+		.dev_name = "nuc970-fmi",
+		.name = "nand-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "nand",
+		.data.mux.group = "nand_0_grp",
+	},
+	{
+		.dev_name = "nuc970-fmi",
+		.name = "nand-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "nand",
+		.data.mux.group = "nand_1_grp",
+	},
+	{
+		.dev_name = "nuc970-fmi",
+		.name = "emmc-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "emmc",
+		.data.mux.group = "emmc_0_grp",
+	},
+	{
+		.dev_name = "nuc970-fmi",
+		.name = "emmc-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "emmc",
+		.data.mux.group = "emmc_1_grp",
+	},
+	{
+		.dev_name = "nuc970-ehci",
+		.name = "usbh-ppwr-pe",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "usbh_ppwr",
+		.data.mux.group = "usbh_pe_grp",
+	},
+	{
+		.dev_name = "nuc970-ehci",
+		.name = "usbh-ppwr-pf",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "usbh_ppwr",
+		.data.mux.group = "usbh_pf_grp",
+	},
+	{
+		.dev_name = "nuc970-ehci",
+		.name = "usbh-ppwr-oc",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "usbh_ppwr",
+		.data.mux.group = "usbh_oc_grp",
+	},
+	{
+		.dev_name = "nuc970-ohci",
+		.name = "usbh-ppwr-pe",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "usbh_ppwr",
+		.data.mux.group = "usbh_pe_grp",
+	},
+	{
+		.dev_name = "nuc970-ohci",
+		.name = "usbh-ppwr-pf",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "usbh_ppwr",
+		.data.mux.group = "usbh_pf_grp",
+	},
+	{
+		.dev_name = "nuc970-ohci",
+		.name = "usbh-ppwr-oc",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "usbh_ppwr",
+		.data.mux.group = "usbh_oc_grp",
+	},
+	{
+		.dev_name = "nuc970-usbdev",
+		.name = "usbd-vbusvld",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "usbd",
+		.data.mux.group = "usbd_grp",
+	},
+	{
+		.dev_name = "nuc970-i2c0",
+		.name = PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "i2c0",
+		.data.mux.group = "i2c0_grp",
+	},
+	{
+		.dev_name = "nuc970-i2c1",
+		.name = "i2c1-PG",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "i2c1",
+		.data.mux.group = "i2c1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-i2c1",
+		.name = "i2c1-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "i2c1",
+		.data.mux.group = "i2c1_2_grp",
+	},
+	{
+		.dev_name = "nuc970-i2c1",
+		.name = "i2c1-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "i2c1",
+		.data.mux.group = "i2c1_3_grp",
+	},
+	{
+		.dev_name = "nuc970-audio-i2s",
+		.name = PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "i2s",
+		.data.mux.group = "i2s_grp",
+	},
+	// {
+		// .dev_name = "nuc970-uart0",
+		// .name = PINCTRL_STATE_DEFAULT,
+		// .type = PIN_MAP_TYPE_MUX_GROUP,
+		// .ctrl_dev_name = "pinctrl-nuc970",
+		// .data.mux.function = "uart0",
+		// .data.mux.group = "uart0_grp",
+	// },
+	PIN_MAP_MUX_GROUP_HOG_DEFAULT("nuc970-uart.0", "uart0_grp", "uart0"),  // hog
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1",
+		.data.mux.group = "uart1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-fc-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1",
+		.data.mux.group = "uart1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-fc-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1_fc",
+		.data.mux.group = "uart1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-ff-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1",
+		.data.mux.group = "uart1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-ff-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1_fc",
+		.data.mux.group = "uart1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-ff-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1_ff",
+		.data.mux.group = "uart1_2_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1",
+		.data.mux.group = "uart1_3_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-fc-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1",
+		.data.mux.group = "uart1_3_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-fc-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1_fc",
+		.data.mux.group = "uart1_4_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1",
+		.data.mux.group = "uart1_5_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-fc-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1",
+		.data.mux.group = "uart1_5_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.1",
+		.name = "uart1-fc-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart1_fc",
+		.data.mux.group = "uart1_6_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.2",
+		.name = "uart2",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart2",
+		.data.mux.group = "uart2_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.2",
+		.name = "uart2_fc",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart2",
+		.data.mux.group = "uart2_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.2",
+		.name = "uart2_fc",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart2_fc",
+		.data.mux.group = "uart2_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.3",
+		.name = PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart3",
+		.data.mux.group = "uart3_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.4",
+		.name = "uart4-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart4",
+		.data.mux.group = "uart4_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.4",
+		.name = "uart4-fc-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart4",
+		.data.mux.group = "uart4_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.4",
+		.name = "uart4-fc-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart4_fc",
+		.data.mux.group = "uart4_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.4",
+		.name = "uart4-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart4",
+		.data.mux.group = "uart4_2_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.4",
+		.name = "uart4-fc-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart4",
+		.data.mux.group = "uart4_2_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.4",
+		.name = "uart4-fc-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart4_fc",
+		.data.mux.group = "uart4_3_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.4",
+		.name = "uart4-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart4",
+		.data.mux.group = "uart4_4_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.5",
+		.name = PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart5",
+		.data.mux.group = "uart5_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.6",
+		.name = "uart6-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart6",
+		.data.mux.group = "uart6_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.6",
+		.name = "uart6-fc-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart6",
+		.data.mux.group = "uart6_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.6",
+		.name = "uart6-fc-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart6_fc",
+		.data.mux.group = "uart6_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.6",
+		.name = "uart6-PG",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart6",
+		.data.mux.group = "uart6_2_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.6",
+		.name = "uart6-fc-PG",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart6",
+		.data.mux.group = "uart6_2_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.6",
+		.name = "uart6-fc-PG",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart6_fc",
+		.data.mux.group = "uart6_3_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.7",
+		.name = "uart7-PG",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart7",
+		.data.mux.group = "uart7_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.7",
+		.name = "uart7-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart7",
+		.data.mux.group = "uart7_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.8",
+		.name = "uart8-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart8",
+		.data.mux.group = "uart8_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.8",
+		.name = "uart8-fc-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart8",
+		.data.mux.group = "uart8_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.8",
+		.name = "uart8-fc-PE",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart8_fc",
+		.data.mux.group = "uart8_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.8",
+		.name = "uart8-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart8",
+		.data.mux.group = "uart8_2_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.8",
+		.name = "uart8-fc-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart8",
+		.data.mux.group = "uart8_2_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.8",
+		.name = "uart8-fc-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart8_fc",
+		.data.mux.group = "uart8_3_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.8",
+		.name = "uart8-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart8",
+		.data.mux.group = "uart8_4_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.8",
+		.name = "uart8-fc-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart8",
+		.data.mux.group = "uart8_4_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.8",
+		.name = "uart8-fc-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart8_fc",
+		.data.mux.group = "uart8_5_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.9",
+		.name = "uart9-PD0",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart9",
+		.data.mux.group = "uart9_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.9",
+		.name = "uart9-PD1",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart9",
+		.data.mux.group = "uart9_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.9",
+		.name = "uart9-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart9",
+		.data.mux.group = "uart9_2_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.10",
+		.name = "uart10-PB0",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart10",
+		.data.mux.group = "uart10_0_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.10",
+		.name = "uart10-PB1",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart10",
+		.data.mux.group = "uart10_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.10",
+		.name = "uart10-fc-PB1",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart10",
+		.data.mux.group = "uart10_1_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.10",
+		.name = "uart10-fc-PB1",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart10_fc",
+		.data.mux.group = "uart10_2_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.10",
+		.name = "uart10-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart10",
+		.data.mux.group = "uart10_3_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.10",
+		.name = "uart10-fc-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart10",
+		.data.mux.group = "uart10_3_grp",
+	},
+	{
+		.dev_name = "nuc970-uart.10",
+		.name = "uart10-fc-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "uart10_fc",
+		.data.mux.group = "uart10_4_grp",
+	},
+	{
+		.dev_name = "nuc970-sc.0",
+		.name = "sc0-PG",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sc0",
+		.data.mux.group = "sc0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-sc.0",
+		.name = "sc0-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sc0",
+		.data.mux.group = "sc0_1_grp",
+	},
+	{
+		.dev_name = "nuc970-sc.0",
+		.name = "scuart0-PG",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "scuart0",
+		.data.mux.group = "sc0_2_grp",
+	},
+	{
+		.dev_name = "nuc970-sc.0",
+		.name = "scuart0-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "scuart0",
+		.data.mux.group = "sc0_3_grp",
+	},
+	{
+		.dev_name = "nuc970-sc.1",
+		.name = "sc1",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "sc1",
+		.data.mux.group = "sc1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-sc.1",
+		.name = "scuart1",//PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "scuart1",
+		.data.mux.group = "sc1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0",
+		.data.mux.group = "spi0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-quad",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0",
+		.data.mux.group = "spi0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-quad",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0_quad",
+		.data.mux.group = "spi0_1_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0",
+		.data.mux.group = "spi0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0_ss1",
+		.data.mux.group = "spi0_2_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-ss1-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0",
+		.data.mux.group = "spi0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-ss1-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0_ss1",
+		.data.mux.group = "spi0_3_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-quad-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0",
+		.data.mux.group = "spi0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-quad-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0_quad",
+		.data.mux.group = "spi0_1_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-quad-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0_ss1",
+		.data.mux.group = "spi0_2_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-quad-ss1-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0",
+		.data.mux.group = "spi0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-quad-ss1-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0_quad",
+		.data.mux.group = "spi0_1_grp",
+	},
+	{
+		.dev_name = "nuc970-spi0",
+		.name = "spi0-quad-ss1-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi0_ss1",
+		.data.mux.group = "spi0_3_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1",
+		.data.mux.group = "spi1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1",
+		.data.mux.group = "spi1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1_ss1",
+		.data.mux.group = "spi1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-quad-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1",
+		.data.mux.group = "spi1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-quad-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1_quad",
+		.data.mux.group = "spi1_2_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-quad-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1",
+		.data.mux.group = "spi1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-quad-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1_quad",
+		.data.mux.group = "spi1_2_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-quad-ss1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1_ss1",
+		.data.mux.group = "spi1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1",
+		.data.mux.group = "spi1_4_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",  // SS1 is @ PH, not PI
+		.name = "spi1-ss1-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1",
+		.data.mux.group = "spi1_4_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-ss1-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1_ss1",
+		.data.mux.group = "spi1_3_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-quad-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1",
+		.data.mux.group = "spi1_4_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-quad-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1_quad",
+		.data.mux.group = "spi1_2_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",  // SS1 is @ PH, not PI
+		.name = "spi1-quad-ss1-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1",
+		.data.mux.group = "spi1_4_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-quad-ss1-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1_quad",
+		.data.mux.group = "spi1_2_grp",
+	},
+	{
+		.dev_name = "nuc970-spi1",
+		.name = "spi1-quad-ss1-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "spi1_ss1",
+		.data.mux.group = "spi1_3_grp",
+	},
+	{
+		.dev_name = "nuc970-can0",
+		.name = "can0-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "can0",
+		.data.mux.group = "can0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-can0",
+		.name = "can0-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "can0",
+		.data.mux.group = "can0_1_grp",
+	},
+	{
+		.dev_name = "nuc970-can0",
+		.name = "can0-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "can0",
+		.data.mux.group = "can0_2_grp",
+	},
+	{
+		.dev_name = "nuc970-can1",
+		.name = PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "can1",
+		.data.mux.group = "can1_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.0",
+		.name = "pwm0-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm0",
+		.data.mux.group = "pwm0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.0",
+		.name = "pwm0-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm0",
+		.data.mux.group = "pwm0_1_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.0",
+		.name = "pwm0-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm0",
+		.data.mux.group = "pwm0_2_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.0",
+		.name = "pwm0-PD",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm0",
+		.data.mux.group = "pwm0_3_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.1",
+		.name = "pwm1-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm1",
+		.data.mux.group = "pwm1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.1",
+		.name = "pwm1-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm1",
+		.data.mux.group = "pwm1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.1",
+		.name = "pwm-PD",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm1",
+		.data.mux.group = "pwm1_2_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.2",
+		.name = "pwm2-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm2",
+		.data.mux.group = "pwm2_0_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.2",
+		.name = "pwm2-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm2",
+		.data.mux.group = "pwm2_1_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.2",
+		.name = "pwm2-PD",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm2",
+		.data.mux.group = "pwm2_2_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.3",
+		.name = "pwm3-PA",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm3",
+		.data.mux.group = "pwm3_0_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.3",
+		.name = "pwm3-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm3",
+		.data.mux.group = "pwm3_1_grp",
+	},
+	{
+		.dev_name = "nuc970-pwm.3",
+		.name = "pwm3-PD",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "pwm3",
+		.data.mux.group = "pwm3_2_grp",
+	},
+	{
+		.dev_name = "nuc970-rtc",
+		.name = "rtc-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "rtc",
+		.data.mux.group = "rtc_0_grp",
+	},
+	{
+		.dev_name = "nuc970-rtc",
+		.name = "rtc-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "rtc",
+		.data.mux.group = "rtc_1_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.0",
+		.name = "etimer0-tgl-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer0_tgl",
+		.data.mux.group = "etimer0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.0",
+		.name = "etimer0-tgl-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer0_tgl",
+		.data.mux.group = "etimer0_2_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.0",
+		.name = "etimer0-cap-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer0_cap",
+		.data.mux.group = "etimer0_1_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.0",
+		.name = "etimer0-cap-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer0_cap",
+		.data.mux.group = "etimer0_3_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.1",
+		.name = "etimer1-tgl-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer1_tgl",
+		.data.mux.group = "etimer1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.1",
+		.name = "etimer1-tgl-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer1_tgl",
+		.data.mux.group = "etimer1_2_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.1",
+		.name = "etimer1-cap-PB",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer1_cap",
+		.data.mux.group = "etimer1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.1",
+		.name = "etimer1-cap-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer1_cap",
+		.data.mux.group = "etimer1_3_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.2",
+		.name = "etimer2-tgl-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer2_tgl",
+		.data.mux.group = "etimer2_0_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.2",
+		.name = "etimer2-tgl-PF",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer2_tgl",
+		.data.mux.group = "etimer2_2_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.2",
+		.name = "etimer2-cap-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer2_cap",
+		.data.mux.group = "etimer2_1_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.2",
+		.name = "etimer2-cap-PF",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer2_cap",
+		.data.mux.group = "etimer2_3_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.3",
+		.name = "etimer3-tgl-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer3_tgl",
+		.data.mux.group = "etimer3_0_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.3",
+		.name = "etimer3-tgl-PF",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer3_tgl",
+		.data.mux.group = "etimer3_2_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.3",
+		.name = "etimer3-cap-PC",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer3_cap",
+		.data.mux.group = "etimer3_1_grp",
+	},
+	{
+		.dev_name = "nuc970-etimer.3",
+		.name = "etimer3-cap-PF",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "etimer3_cap",
+		.data.mux.group = "etimer3_3_grp",
+	},
+	{
+		.dev_name = "nuc970-jtag",
+		.name = PINCTRL_STATE_DEFAULT,
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "jtag",
+		.data.mux.group = "jtag_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.1",
+		.name = "eint0-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint0",
+		.data.mux.group = "eint0_0_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.1",
+		.name = "eint0-PF",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint0",
+		.data.mux.group = "eint0_1_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.2",
+		.name = "eint1-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint1",
+		.data.mux.group = "eint1_0_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.2",
+		.name = "eint1-PF",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint1",
+		.data.mux.group = "eint1_1_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.3",
+		.name = "eint2-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint2",
+		.data.mux.group = "eint2_0_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.3",
+		.name = "eint2-PF",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint2",
+		.data.mux.group = "eint2_1_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.4",
+		.name = "eint3-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint3",
+		.data.mux.group = "eint3_0_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.4",
+		.name = "eint3-PF",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint3",
+		.data.mux.group = "eint3_1_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.5",
+		.name = "eint4-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint4",
+		.data.mux.group = "eint4_0_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.5",
+		.name = "eint4-PF",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint4",
+		.data.mux.group = "eint4_1_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.6",
+		.name = "eint5-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint5",
+		.data.mux.group = "eint5_0_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.6",
+		.name = "eint5-PG",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint5",
+		.data.mux.group = "eint5_1_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.7",
+		.name = "eint6-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint6",
+		.data.mux.group = "eint6_0_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.7",
+		.name = "eint6-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint6",
+		.data.mux.group = "eint6_1_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.8",
+		.name = "eint7-PH",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint7",
+		.data.mux.group = "eint7_0_grp",
+	},
+	{
+		.dev_name = "nuc970-gpio.8",
+		.name = "eint7-PI",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "eint7",
+		.data.mux.group = "eint7_1_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-8bit-0",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_8_0",
+		.data.mux.group = "ebi8_0_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-8bit-1",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_8_1",
+		.data.mux.group = "ebi8_1_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-8bit-2",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_8_2",
+		.data.mux.group = "ebi8_2_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-8bit-3",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_8_3",
+		.data.mux.group = "ebi8_3_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-8bit-4",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_8_4",
+		.data.mux.group = "ebi8_4_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-16bit-0",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_16_0",
+		.data.mux.group = "ebi16_0_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-16bit-1",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_16_1",
+		.data.mux.group = "ebi16_1_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-16bit-2",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_16_2",
+		.data.mux.group = "ebi16_2_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-16bit-3",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_16_3",
+		.data.mux.group = "ebi16_3_grp",
+	},
+	{
+		.dev_name = "nuc970-ebi",
+		.name = "ebi-16bit-4",
+		.type = PIN_MAP_TYPE_MUX_GROUP,
+		.ctrl_dev_name = "pinctrl-nuc970",
+		.data.mux.function = "ebi_16_4",
+		.data.mux.group = "ebi16_4_grp",
+	},
+};
+
+
+static int nuc970_pinctrl_probe(struct platform_device *pdev)
+{
+	struct pinctrl_dev *pctl;
+
+	pctl = pinctrl_register(&nuc970_pinctrl_desc, &pdev->dev, NULL);
+	if (IS_ERR(pctl))
+		pr_err("could not register NUC970 pin driver\n");
+
+	platform_set_drvdata(pdev, pctl);
+
+	return pinctrl_register_mappings(nuc970_pinmap, ARRAY_SIZE(nuc970_pinmap));
+
+}
+
+static int nuc970_pinctrl_remove(struct platform_device *pdev)
+{
+	struct pinctrl_dev *pctl = platform_get_drvdata(pdev);
+
+	pinctrl_unregister(pctl);
+
+	return 0;
+}
+
+
+static struct platform_driver nuc970_pinctrl_driver = {
+	.driver = {
+		.name = "pinctrl-nuc970",
+		.owner = THIS_MODULE,
+	},
+	.probe = nuc970_pinctrl_probe,
+	.remove = nuc970_pinctrl_remove,
+};
+
+
+static int __init nuc970_pinctrl_init(void)
+{
+	return platform_driver_register(&nuc970_pinctrl_driver);
+}
+arch_initcall(nuc970_pinctrl_init);
+
+static void __exit nuc970_pinctrl_exit(void)
+{
+	platform_driver_unregister(&nuc970_pinctrl_driver);
+}
+
+module_exit(nuc970_pinctrl_exit);
+
+MODULE_AUTHOR("Nuvoton Technology Corp.");
+MODULE_LICENSE("GPL");
Index: linux-4.4.92/drivers/tty/serial/Kconfig
===================================================================
--- linux-4.4.92.orig/drivers/tty/serial/Kconfig
+++ linux-4.4.92/drivers/tty/serial/Kconfig
@@ -18,6 +18,310 @@ source "drivers/tty/serial/8250/Kconfig"
 
 comment "Non-8250 serial port support"
 
+config SERIAL_NUC970
+	bool "NUC970 serial support"
+	select SERIAL_CORE
+	---help---
+	  This selects NUC970 serial driver.
+
+config NUC970_UART1
+	bool "NUC970 UART1 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart1 driver
+
+config ENABLE_UART1_CTS_WAKEUP
+	bool "Enable UART1 CTS wake-up function"
+	depends on NUC970_UART1
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart1 CTS wake-up function
+
+choice
+	prompt "NUC970 UART1 pin selection"
+	default NUC970_UART1_PE
+	depends on NUC970_UART1
+	depends on !USE_OF
+	help
+	  Select UART1 multi-function pin.
+
+	config NUC970_UART1_PE
+		bool "Tx:PE2, Rx:PE3"
+	config NUC970_UART1_FC_PE
+		bool "Tx:PE2, Rx:PE3, RTS:PE4, CTS:PE5"
+	config NUC970_UART1_FF_PE
+		bool "Tx:PE2, Rx:PE3, RTS:PE4, CTS:PE5, DTR:PE6, DSR:PE7, nRI:PE8, nCD:PE9"
+	config NUC970_UART1_PH
+		bool "Tx:PH4, Rx:PH5"
+	config NUC970_UART1_FC_PH
+		bool "Tx:PH4, Rx:PH5, RTS:PH6, CTS:PH7"
+	config NUC970_UART1_PI
+		bool "Tx:PI5, Rx:PI6"
+	config NUC970_UART1_FC_PI
+		bool "Tx:PI5, Rx:PI6, RTS:PI7, CTS:PI8"
+endchoice
+
+config NUC970_UART2
+	bool "NUC970 UART2 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart2 driver
+
+config ENABLE_UART2_CTS_WAKEUP
+	bool "Enable UART2 CTS wake-up function"
+	depends on NUC970_UART2
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart2 CTS wake-up function
+
+choice
+	prompt "NUC970 UART2 pin selection"
+	default NUC970_UART2_PF
+	depends on NUC970_UART2
+	depends on !USE_OF
+	help
+	  Select UART2 multi-function pin.
+
+	config NUC970_UART2_PF
+		bool "Tx:PF11, Rx:PF12"
+	config NUC970_UART2_FC_PF
+		bool "Tx:PF11, Rx:PF12, CTS:PF14, RTS:PF13"
+endchoice
+
+config NUC970_UART3
+	bool "NUC970 UART3 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart3 driver
+
+config NUC970_UART4
+	bool "NUC970 UART4 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart4 driver
+
+config ENABLE_UART4_CTS_WAKEUP
+	bool "Enable UART4 CTS wake-up function"
+	depends on NUC970_UART4
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart4 CTS wake-up function
+
+choice
+	prompt "NUC970 UART4 pin selection"
+	default NUC970_UART4_PC
+	depends on NUC970_UART4
+	depends on !USE_OF
+	help
+	  Select UART4 multi-function pin.
+
+	config NUC970_UART4_PC
+		bool "Tx:PC10, Rx:PC11"
+	config NUC970_UART4_FC_PC
+		bool "Tx:PC10, Rx:PC11, CTS:PC12, RTS:PC13"
+	config NUC970_UART4_PH
+		bool "Tx:PH8, Rx:PH9"
+	config NUC970_UART4_FC_PH
+		bool "Tx:PH8, Rx:PH9, RTS:PH10, CTS:PH11"
+	config NUC970_UART4_PI
+		bool "Tx:PI9, Rx:PI10"
+endchoice
+
+config NUC970_UART5
+	bool "NUC970 UART5 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart5 driver
+
+config NUC970_UART6
+	bool "NUC970 UART6 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart6 driver
+
+config ENABLE_UART6_CTS_WAKEUP
+	bool "Enable UART6 CTS wake-up function"
+	depends on NUC970_UART6
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart6 CTS wake-up function
+
+choice
+	prompt "NUC970 UART6 pin selection"
+	default NUC970_UART6_PB
+	depends on NUC970_UART6
+	depends on !USE_OF
+	help
+	  Select UART6 multi-function pin.
+
+	config NUC970_UART6_PB
+		bool "Tx:PB2, Rx:PB3"
+	config NUC970_UART6_FC_PB
+		bool "Tx:PB2, Rx:PB3, RTS:PB4, CTS:PB5"
+	config NUC970_UART6_PG
+		bool "Tx:PG11, Rx:PG12"
+	config NUC970_UART6_FC_PG
+		bool "Tx:PG11, Rx:PG12, RTS:PG13, CTS:PG14"
+endchoice
+
+config NUC970_UART7
+	bool "NUC970 UART7 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart7 driver
+
+choice
+	prompt "NUC970 UART7 pin selection"
+	default NUC970_UART7_PG
+	depends on NUC970_UART7
+	depends on !USE_OF
+	help
+	  Select UART7 multi-function pin.
+
+	config NUC970_UART7_PG
+		bool "Tx:PG4, Rx:PG5"
+	config NUC970_UART7_PI
+		bool "Tx:PI1, Rx:PI2"
+endchoice
+
+config NUC970_UART8
+	bool "NUC970 UART8 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart8 driver
+
+config ENABLE_UART8_CTS_WAKEUP
+	bool "Enable UART8 CTS wake-up function"
+	depends on NUC970_UART8
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart8 CTS wake-up function
+
+choice
+	prompt "NUC970 UART8 pin selection"
+	default NUC970_UART8_PE
+	depends on NUC970_UART8
+	depends on !USE_OF
+	help
+	  Select UART8 multi-function pin.
+
+	config NUC970_UART8_PE
+		bool "Tx:PE10, Rx:PE11"
+	config NUC970_UART8_FC_PE
+		bool "Tx:PE10, Rx:PE11, RTC:PE12, CTS:PE13"
+	config NUC970_UART8_PH
+		bool "Tx:PH12, Rx:PH13"
+	config NUC970_UART8_FC_PH
+		bool "Tx:PH12, Rx:PH13, RTC:PH14, CTS:PH15"
+	config NUC970_UART8_PI
+		bool "Tx:PI12, Rx:PI13"
+	config NUC970_UART8_FC_PI
+		bool "Tx:PI12, Rx:PI13, RTC:PI14, CTS:PI15"
+endchoice
+
+config NUC970_UART9
+	bool "NUC970 UART9 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart9 driver
+
+choice
+	prompt "NUC970 UART9 pin selection"
+	default NUC970_UART9_PD0
+	depends on NUC970_UART9
+	depends on !USE_OF
+	help
+	  Select UART9 multi-function pin.
+
+	config NUC970_UART9_PD0
+		bool "Tx:PD11, Rx:PD12"
+	config NUC970_UART9_PD1
+		bool "Tx:PD14, Rx:PD15"
+	config NUC970_UART9_PH
+		bool "Tx:PH2, Rx:PH3"
+endchoice
+
+config NUC970_UART10
+	bool "NUC970 UART10 support"
+	depends on SERIAL_NUC970=y
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart10 driver
+
+config ENABLE_UART10_CTS_WAKEUP
+	bool "Enable UART10 CTS wake-up function"
+	depends on NUC970_UART10
+	depends on !USE_OF
+	help
+	  This selects NUC970 uart10 CTS wake-up function
+
+choice
+	prompt "NUC970 UART10 pin selection"
+	default NUC970_UART10_PB0
+	depends on NUC970_UART10
+	depends on !USE_OF
+	help
+	  Select UART9 multi-function pin.
+
+	config NUC970_UART10_PB0
+		bool "Tx:PB10, Rx:PB11"
+	config NUC970_UART10_PB1
+		bool "Tx:PB12, Rx:PB13"
+	config NUC970_UART10_FC_PB1
+		bool "Tx:PB12, Rx:PB13, CTS:PB14, RTS:PB15"
+	config NUC970_UART10_PC
+		bool "Tx:PC6, Rx:PC7"
+	config NUC970_UART10_FC_PC
+		bool "Tx:PC6, Rx:PC7, CTS:PC8, RTS:PC9"
+endchoice
+
+config SERIAL_NUC970_CONSOLE
+	bool "Console on NUC970 serial port"
+	depends on SERIAL_NUC970=y
+	select SERIAL_CORE_CONSOLE
+	---help---
+	  If you say Y here, it will be possible to use a serial port as the
+	  system console.
+
+
+config SCUART_NUC970
+	bool "NUC970 Smartcard UART Mode support"
+	select SERIAL_CORE
+	---help---
+	  This selects NUC970 smartcard uart mode driver.
+
+config NUC970_SCUART0
+	bool "NUC970 SCUART0 support"
+	depends on SCUART_NUC970=y && !USE_OF
+	help
+	  This selects NUC970 scuart0 driver
+choice
+	prompt "NUC970 SCUART0 pin selection"
+	default NUC970_SCUART0_PG
+	depends on NUC970_SCUART0
+	help
+	  Select SCUART0 multi-function pin.
+
+	config NUC970_SCUART0_PG
+		bool "Tx:PG11, Rx:PG12"
+	config NUC970_SCUART0_PI
+		bool "Tx:PI12, Rx:PI13"
+endchoice
+
+config NUC970_SCUART1
+	bool "NUC970 SCUART1 support"
+	depends on SCUART_NUC970=y && !USE_OF
+	help
+	  This selects NUC970 scuart1 driver
 config SERIAL_AMBA_PL010
 	tristate "ARM AMBA PL010 serial port support"
 	depends on ARM_AMBA
Index: linux-4.4.92/drivers/tty/serial/Makefile
===================================================================
--- linux-4.4.92.orig/drivers/tty/serial/Makefile
+++ linux-4.4.92/drivers/tty/serial/Makefile
@@ -88,6 +88,12 @@ obj-$(CONFIG_SERIAL_AR933X)   += ar933x_
 obj-$(CONFIG_SERIAL_EFM32_UART) += efm32-uart.o
 obj-$(CONFIG_SERIAL_ARC)	+= arc_uart.o
 obj-$(CONFIG_SERIAL_RP2)	+= rp2.o
+ifeq ($(CONFIG_OF),y)
+obj-$(CONFIG_SERIAL_NUC970)     += nuc970_serial-dt.o
+else
+obj-$(CONFIG_SERIAL_NUC970)     += nuc970_serial.o
+endif
+obj-$(CONFIG_SCUART_NUC970)     += nuc970_scuart.o
 obj-$(CONFIG_SERIAL_FSL_LPUART)	+= fsl_lpuart.o
 obj-$(CONFIG_SERIAL_CONEXANT_DIGICOLOR)	+= digicolor-usart.o
 obj-$(CONFIG_SERIAL_MEN_Z135)	+= men_z135_uart.o
Index: linux-4.4.92/drivers/tty/serial/nuc970_scuart.c
===================================================================
--- /dev/null
+++ linux-4.4.92/drivers/tty/serial/nuc970_scuart.c
@@ -0,0 +1,732 @@
+/*
+ *  linux/drivers/tty/serial/nuc970_scuart.c
+ *
+ *  NUC970 Smartcard UART mode driver
+ *
+ *
+ *  Copyright (C) 2014~2016 Nuvoton Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/clk.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/nmi.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+
+#include <mach/map.h>
+#include <mach/regs-sc.h>
+#include <mach/regs-gcr.h>
+#include <mach/mfp.h>
+
+
+#define SCUART_NR 2
+static struct uart_driver nuc970serial_reg;
+struct plat_nuc970serial_port {
+	unsigned long	iobase;		/* io base address */
+	void __iomem	*membase;	/* ioremap cookie or NULL */
+	resource_size_t	mapbase;	/* resource base */
+	unsigned int	irq;		/* interrupt number */
+	unsigned int	uartclk;	/* UART clock rate */
+	void            *private_data;
+	unsigned int	(*serial_in)(struct uart_port *, int);
+	void		(*serial_out)(struct uart_port *, int, int);
+};
+
+
+struct uart_nuc970_port {
+	struct uart_port	port;
+	/*
+	 * We provide a per-port pm hook.
+	 */
+	void			(*pm)(struct uart_port *port,
+				      unsigned int state, unsigned int old);
+};
+
+static struct uart_nuc970_port nuc970serial_ports[SCUART_NR];
+
+static inline struct uart_nuc970_port *
+to_nuc970_uart_port(struct uart_port *uart)
+{
+	return container_of(uart, struct uart_nuc970_port, port);
+}
+
+static inline unsigned int serial_in(struct uart_nuc970_port *p, int offset)
+{
+	return(__raw_readl(p->port.membase + offset));
+}
+
+static inline void serial_out(struct uart_nuc970_port *p, int offset, int value)
+{
+	__raw_writel(value, p->port.membase + offset);
+}
+
+
+static inline void __stop_tx(struct uart_nuc970_port *p)
+{
+	unsigned int ier;
+
+	if ((ier = serial_in(p, REG_SC_INTEN)) & SC_INTEN_TBEIEN) {
+		serial_out(p, REG_SC_INTEN, ier & ~SC_INTEN_TBEIEN);
+	}
+}
+
+static void nuc970serial_stop_tx(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	__stop_tx(up);
+
+}
+
+static void transmit_chars(struct uart_nuc970_port *up);
+
+static void nuc970serial_start_tx(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int ier;
+
+
+	if (!((ier = serial_in(up, REG_SC_INTEN)) & SC_INTEN_TBEIEN)) {
+		ier |= SC_INTEN_TBEIEN;
+		serial_out(up, REG_SC_INTEN, ier);
+	}
+
+}
+
+static void nuc970serial_stop_rx(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	serial_out(up, REG_SC_INTEN, serial_in(up, REG_SC_INTEN) & ~SC_INTEN_RDAIEN);
+}
+
+static void nuc970serial_enable_ms(struct uart_port *port)
+{
+
+}
+
+static void receive_chars(struct uart_nuc970_port *up)
+{
+	unsigned char ch;
+	unsigned int status;
+	int max_count = 256;
+	char flag;
+
+	do {
+		ch = (unsigned char)serial_in(up, REG_SC_DAT);
+		status = serial_in(up, REG_SC_STATUS);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(status & (SC_STATUS_BEF | SC_STATUS_FEF | SC_STATUS_PEF | SC_STATUS_RXOV))) {
+			if (status & SC_STATUS_BEF) {
+				serial_out(up, REG_SC_STATUS, SC_STATUS_BEF);
+				up->port.icount.brk++;
+				if (uart_handle_break(&up->port))
+					continue;
+			}
+
+			if (status & SC_STATUS_FEF) {
+				serial_out(up, REG_SC_STATUS, SC_STATUS_FEF);
+				up->port.icount.parity++;
+			}
+
+			if (status & SC_STATUS_PEF) {
+				serial_out(up, REG_SC_STATUS, SC_STATUS_PEF);
+				up->port.icount.frame++;
+			}
+
+			if (status & SC_STATUS_RXOV) {
+				serial_out(up, REG_SC_STATUS, SC_STATUS_RXOV);
+				up->port.icount.overrun++;
+			}
+			// FIXME: check port->read_status_mask to determin report flags
+			if (status & SC_STATUS_BEF)
+				flag = TTY_BREAK;
+			if (status & SC_STATUS_PEF)
+				flag = TTY_PARITY;
+			if (status & SC_STATUS_FEF)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(&up->port, ch))
+			continue;
+
+		uart_insert_char(&up->port, status, SC_STATUS_RXOV, ch, flag);
+
+	} while (!(status & SC_STATUS_RXEMPTY) && (max_count-- > 0));
+
+	tty_flip_buffer_push(&up->port.state->port);
+}
+
+static void transmit_chars(struct uart_nuc970_port *up)
+{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	int count = 4;	// SCUART FIFO depath is 4 bytes
+
+	if (up->port.x_char) {
+		while(serial_in(up, REG_SC_STATUS) & SC_STATUS_TXFULL);
+		serial_out(up, REG_SC_DAT, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+	if (uart_tx_stopped(&up->port)) {
+		nuc970serial_stop_tx(&up->port);
+		return;
+	}
+
+	if (uart_circ_empty(xmit)) {
+		__stop_tx(up);
+		return;
+	}
+
+	do {
+		serial_out(up, REG_SC_DAT, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (uart_circ_empty(xmit))
+		__stop_tx(up);
+}
+
+
+static irqreturn_t nuc970serial_interrupt(int irq, void *dev_id)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)dev_id;
+	unsigned int isr, ier;
+
+	isr = serial_in(up, REG_SC_INTSTS);
+	ier = serial_in(up, REG_SC_INTEN);
+
+	if (isr & (SC_INTSTS_RXTOIF | SC_INTSTS_RDAIF))
+		receive_chars(up);
+
+	if ((isr & SC_INTSTS_TBEIF) && (ier & SC_INTEN_TBEIEN))
+		transmit_chars(up);
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int nuc970serial_tx_empty(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned long flags;
+	unsigned int status;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	status = serial_in(up, REG_SC_STATUS);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return (status & SC_STATUS_TXEMPTY) ? TIOCSER_TEMT : 0;
+}
+
+static unsigned int nuc970serial_get_mctrl(struct uart_port *port)
+{
+
+	return 0;
+}
+
+static void nuc970serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+
+}
+
+static void nuc970serial_break_ctl(struct uart_port *port, int break_state)
+{
+
+}
+
+static int nuc970serial_startup(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	struct tty_struct *tty = port->state->port.tty;
+	int retval;
+
+	/* Reset FIFO */
+	serial_out(up, REG_SC_ALTCTL, SC_ALTCTL_RXRST| SC_ALTCTL_TXRST);
+
+	/* Clear pending interrupts (not every bit are write 1 clear though...) */
+	serial_out(up, REG_SC_INTSTS, 0xFFFFFFFF);
+
+	retval = request_irq(port->irq, nuc970serial_interrupt, 0,
+			tty ? tty->name : "nuc970_scuart", port);
+
+	if (retval) {
+		printk("request irq failed...\n");
+		return retval;
+	}
+
+	/*
+	 * Now, initialize the UART
+	 */
+	serial_out(up, REG_SC_CTL, 0x41);	// enable SC engine, trigger level 2 bytes
+	serial_out(up, REG_SC_UARTCTL, serial_in(up, REG_SC_UARTCTL) | 1);	// enable UART mode
+	serial_out(up, REG_SC_RXTOUT, 0x40);
+	serial_out(up, REG_SC_INTEN, SC_INTEN_RXTOIEN | SC_INTEN_RDAIEN);
+
+	return 0;
+}
+
+static void nuc970serial_shutdown(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	//unsigned long flags;
+
+	/*
+	 * Disable interrupts from this port
+	 */
+	serial_out(up, REG_SC_INTEN, 0);
+	serial_out(up, REG_SC_ALTCTL, SC_ALTCTL_RXRST| SC_ALTCTL_TXRST);
+	free_irq(port->irq, port);
+
+}
+
+static unsigned int nuc970serial_get_divisor(struct uart_port *port, unsigned int baud)
+{
+	unsigned int quot;
+
+	quot = ((port->uartclk + baud / 2) / baud) - 1;
+
+	return quot;
+}
+
+static void nuc970serial_set_termios(struct uart_port *port, struct ktermios *termios,
+		       struct ktermios *old)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int uartctl = 1, ctl;	// 1 is for enable UART mode
+	unsigned long flags;
+	unsigned int baud, quot;
+
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		uartctl |= 0x30;
+		break;
+	case CS6:
+		uartctl |= 0x20;
+		break;
+	case CS7:
+		uartctl |= 0x10;
+		break;
+	default:
+	case CS8:
+		uartctl |= 0;
+		break;
+	}
+
+	if (termios->c_cflag & PARENB)
+		uartctl &= ~0x40;
+	else
+		uartctl |= 0x40;
+	if (termios->c_cflag & PARODD)
+		uartctl |= 0x80;
+
+
+	baud = uart_get_baud_rate(port, termios, old,
+				  port->uartclk / 0xFFF,
+				  port->uartclk / 5);	// 4 < bauddate divider <= 0xFFF
+
+	quot = nuc970serial_get_divisor(port, baud);
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	up->port.read_status_mask = SC_STATUS_RXOV;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= SC_STATUS_FEF | SC_STATUS_PEF;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= SC_STATUS_BEF;
+
+	/*
+	 * Characteres to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= SC_STATUS_FEF | SC_STATUS_PEF;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= SC_STATUS_BEF;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= SC_STATUS_RXOV;
+	}
+
+	serial_out(up, REG_SC_ETUCTL, quot);
+	serial_out(up, REG_SC_UARTCTL, uartctl);
+
+	ctl = serial_in(up, REG_SC_CTL);
+
+	if (termios->c_cflag & CSTOPB)
+		ctl &= ~SC_CTL_NSB;
+	else
+		ctl |= SC_CTL_NSB;
+	serial_out(up, REG_SC_CTL, ctl);
+
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+}
+
+static void nuc970serial_set_ldisc(struct uart_port *port, int ld)
+{
+	return;
+
+}
+
+static void nuc970serial_pm(struct uart_port *port, unsigned int state,
+	      unsigned int oldstate)
+{
+	struct uart_nuc970_port *p = (struct uart_nuc970_port *)port;
+
+
+	if (p->pm)
+		p->pm(port, state, oldstate);
+}
+
+static void nuc970serial_release_port(struct uart_port *port)
+{
+	struct platform_device *pdev = to_platform_device(port->dev);
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	release_mem_region(port->mapbase, size);
+
+	iounmap(port->membase);
+	port->membase = NULL;
+
+
+}
+
+static int nuc970serial_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void nuc970serial_config_port(struct uart_port *port, int flags)
+{
+	int ret;
+
+	/*
+	 * Find the region that we can probe for.  This in turn
+	 * tells us whether we can probe for the type of port.
+	 */
+	ret = nuc970serial_request_port(port);
+	if (ret < 0)
+		return;
+	port->type = PORT_NUC970;
+
+}
+
+static int
+nuc970serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_NUC970)
+		return -EINVAL;
+	return 0;
+}
+
+static const char *
+nuc970serial_type(struct uart_port *port)
+{
+
+	return (port->type == PORT_NUC970) ? "NUC970" : NULL;
+}
+
+static struct uart_ops nuc970serial_ops = {
+	.tx_empty	= nuc970serial_tx_empty,
+	.set_mctrl	= nuc970serial_set_mctrl,
+	.get_mctrl	= nuc970serial_get_mctrl,
+	.stop_tx	= nuc970serial_stop_tx,
+	.start_tx	= nuc970serial_start_tx,
+	.stop_rx	= nuc970serial_stop_rx,
+	.enable_ms	= nuc970serial_enable_ms,
+	.break_ctl	= nuc970serial_break_ctl,
+	.startup	= nuc970serial_startup,
+	.shutdown	= nuc970serial_shutdown,
+	.set_termios	= nuc970serial_set_termios,
+	.set_ldisc	= nuc970serial_set_ldisc,
+	.pm		= nuc970serial_pm,
+	.type		= nuc970serial_type,
+	.release_port	= nuc970serial_release_port,
+	.request_port	= nuc970serial_request_port,
+	.config_port	= nuc970serial_config_port,
+	.verify_port	= nuc970serial_verify_port,
+
+};
+
+static void __init nuc970serial_init_ports(void)
+{
+	int i;
+
+	for (i = 0; i < SCUART_NR; i++) {
+		struct uart_nuc970_port *up = &nuc970serial_ports[i];
+		up->port.line = i;
+		spin_lock_init(&up->port.lock);
+
+		up->port.ops = &nuc970serial_ops;
+		up->port.iobase = (long)(NUC970_VA_SC + (i * 0x400));
+		up->port.membase = NUC970_VA_SC + (i * 0x400);
+		up->port.uartclk = 12000000;
+
+	}
+}
+
+static struct uart_driver nuc970serial_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "sc_serial",
+	.dev_name		= "ttySCU",
+	.major			= TTY_MAJOR,
+	.minor			= 80,//64,  reserve at least 11 for real UART
+	.nr			= SCUART_NR,
+};
+
+
+/**
+ *
+ *	Suspend one serial port.
+ */
+static void nuc970scuart_suspend_port(int line)
+{
+	uart_suspend_port(&nuc970serial_reg, &nuc970serial_ports[line].port);
+}
+
+/**
+ *
+ *	Resume one serial port.
+ */
+static void nuc970scuart_resume_port(int line)
+{
+	struct uart_nuc970_port *up = &nuc970serial_ports[line];
+
+	uart_resume_port(&nuc970serial_reg, &up->port);
+}
+
+static int nuc970serial_pinctrl(struct platform_device *pdev)
+{
+	struct pinctrl *p = NULL;
+	int retval = 0;
+
+#ifdef CONFIG_OF
+	p = devm_pinctrl_get_select_default(&pdev->dev);
+#else
+	if(pdev->id == 0) {
+
+#	if defined (CONFIG_NUC970_SCUART0_PG)
+		p = devm_pinctrl_get_select(&pdev->dev, "scuart0-PG");
+#	elif defined (CONFIG_NUC970_SCUART0_PI)
+		p = devm_pinctrl_get_select(&pdev->dev, "scuart0-PI");
+#	endif
+	} else { // if(pdev->id == 1)
+		p = devm_pinctrl_get_select(&pdev->dev, "scuart1");
+	}
+#endif
+	if (IS_ERR(p)) {
+		dev_err(&pdev->dev, "Unable to reserve SC%d pin", pdev->id);
+		retval = PTR_ERR(p);
+	}
+
+	return retval;
+}
+
+static void nuc970serial_set_clock(int id)
+{
+	struct clk *clk;
+
+	if(id == 0) {
+		clk = clk_get(NULL, "smc0");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "smc0_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+	} else {
+		clk = clk_get(NULL, "smc1");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "smc1_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+	}
+
+}
+
+static const struct of_device_id nuc970_sc_of_match[] = {
+	{ .compatible = "nuvoton,nuc970-scuart" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nuc970_sc_of_match);
+
+/*
+ * Register a set of serial devices attached to a platform device.  The
+ * list is terminated with a zero flags entry, which means we expect
+ * all entries to have at least UPF_BOOT_AUTOCONF set.
+ */
+static int nuc970serial_probe(struct platform_device *pdev)
+{
+#ifndef CONFIG_OF
+	struct plat_nuc970serial_port *p = pdev->dev.platform_data;
+#endif
+	struct uart_nuc970_port *up;
+	int retval, i;
+
+#ifdef CONFIG_OF
+
+	if(!of_match_device(nuc970_sc_of_match, &pdev->dev)) {
+		dev_err(&pdev->dev, "Failed to find matching device\n");
+		return -EINVAL;
+	}
+	of_property_read_u32_array(pdev->dev.of_node, "port-number", &i, 1);
+	pdev->id = i;
+#endif
+	retval = nuc970serial_pinctrl(pdev);
+	if(retval != 0)
+		return retval;
+
+	nuc970serial_set_clock(pdev->id);
+
+	up = &nuc970serial_ports[pdev->id];
+	up->port.line 		= pdev->id;
+#ifdef CONFIG_OF
+	of_property_read_u32_array(pdev->dev.of_node, "reg", &i, 1);
+	up->port.iobase 	= (long)i;
+	up->port.membase      	= (void *)i;
+	up->port.irq = platform_get_irq(pdev, 0);
+	up->port.uartclk 	= 12000000;
+	of_property_read_u32_array(pdev->dev.of_node, "map-addr", &up->port.mapbase, 1);
+#else
+	up->port.iobase       	= (long)p->membase;
+	up->port.membase      	= p->membase;
+	up->port.irq          	= p->irq;
+	up->port.uartclk      	= p->uartclk;
+	up->port.mapbase     	= p->mapbase;
+	//up->port.private_data 	= p->private_data;
+#endif
+	up->port.dev 		= &pdev->dev;
+
+	up->port.flags 		= ASYNC_BOOT_AUTOCONF;
+	up->port.ops = &nuc970serial_ops;
+
+	spin_lock_init(&up->port.lock);
+
+
+	return uart_add_one_port(&nuc970serial_reg, &up->port);
+}
+
+/*
+ * Remove serial ports registered against a platform device.
+ */
+static int nuc970serial_remove(struct platform_device *pdev)
+{
+	struct uart_nuc970_port *up = &nuc970serial_ports[pdev->id];
+
+	uart_remove_one_port(&nuc970serial_reg, &up->port);
+	return 0;
+}
+
+static int nuc970serial_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct uart_nuc970_port *up = &nuc970serial_ports[pdev->id];
+
+	uart_suspend_port(&nuc970serial_reg, &up->port);
+	return 0;
+}
+
+static int nuc970serial_resume(struct platform_device *pdev)
+{
+	struct uart_nuc970_port *up = &nuc970serial_ports[pdev->id];
+
+	uart_resume_port(&nuc970serial_reg, &up->port);
+	return 0;
+}
+
+
+static struct platform_driver nuc970serial_driver = {
+	.probe		= nuc970serial_probe,
+	.remove		= nuc970serial_remove,
+	.suspend	= nuc970serial_suspend,
+	.resume		= nuc970serial_resume,
+	.driver		= {
+#ifdef CONFIG_OF
+		.name	= "nuc970-scuart",
+#else
+		.name	= "nuc970-sc",		// share same dev structure with smartcard
+#endif
+		.of_match_table = of_match_ptr(nuc970_sc_of_match),
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init nuc970serial_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&nuc970serial_reg);
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&nuc970serial_driver);
+	if (ret)
+		uart_unregister_driver(&nuc970serial_reg);
+
+	nuc970serial_init_ports();
+
+	return ret;
+}
+
+static void __exit nuc970serial_exit(void)
+{
+	platform_driver_unregister(&nuc970serial_driver);
+	uart_unregister_driver(&nuc970serial_reg);
+}
+
+module_init(nuc970serial_init);
+module_exit(nuc970serial_exit);
+
+EXPORT_SYMBOL(nuc970scuart_suspend_port);
+EXPORT_SYMBOL(nuc970scuart_resume_port);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NUC970 scuart driver");
+
+MODULE_ALIAS_CHARDEV_MAJOR(TTY_MAJOR);
+
Index: linux-4.4.92/drivers/tty/serial/nuc970_serial-dt.c
===================================================================
--- /dev/null
+++ linux-4.4.92/drivers/tty/serial/nuc970_serial-dt.c
@@ -0,0 +1,1124 @@
+/*
+ *  linux/drivers/serial/nuc970_serial.c
+ *
+ *  NUC970 serial driver
+ *
+ *
+ *  Copyright (C) 2014 Nuvoton Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#if defined(CONFIG_SERIAL_NUC970_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/clk.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/nmi.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+
+#include <mach/map.h>
+#include <mach/regs-serial.h>
+#include <mach/regs-gcr.h>
+#include <mach/mfp.h>
+
+
+#include "nuc970_serial.h"
+
+#define ENABLE_CTS_WAKEUP
+
+#define UART_NR 11
+static struct uart_driver nuc970serial_reg;
+
+struct clk		*clk;
+
+struct uart_nuc970_port {
+	struct uart_port	port;
+
+	unsigned short		capabilities;	/* port capabilities */
+	unsigned char		ier;
+	unsigned char		lcr;
+	unsigned char		mcr;
+	unsigned char		mcr_mask;	/* mask of user bits */
+	unsigned char		mcr_force;	/* mask of forced bits */
+
+	struct serial_rs485     rs485;          /* rs485 settings */
+	/*
+	 * We provide a per-port pm hook.
+	 */
+	void			(*pm)(struct uart_port *port,
+				      unsigned int state, unsigned int old);
+};
+
+static struct uart_nuc970_port nuc970serial_ports[UART_NR];
+
+static inline struct uart_nuc970_port *
+to_nuc970_uart_port(struct uart_port *uart)
+{
+	return container_of(uart, struct uart_nuc970_port, port);
+}
+
+static inline unsigned int serial_in(struct uart_nuc970_port *p, int offset)
+{
+	return(__raw_readl(p->port.membase + offset));
+}
+
+static inline void serial_out(struct uart_nuc970_port *p, int offset, int value)
+{
+	__raw_writel(value, p->port.membase + offset);
+}
+
+static void rs485_start_rx(struct uart_nuc970_port *port)
+{
+	#if 0
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	if(port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
+	{
+		// Set logical level for RTS pin equal to high
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) & ~0x200) );
+}
+	else
+{
+		// Set logical level for RTS pin equal to low
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) | 0x200) );
+	}
+	#endif
+}
+
+static void rs485_stop_rx(struct uart_nuc970_port *port)
+{
+	#if 0
+	if(port->rs485.flags & SER_RS485_RTS_ON_SEND)
+	{
+		// Set logical level for RTS pin equal to high
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) & ~0x200) );
+	}
+	else
+	{
+		// Set logical level for RTS pin equal to low
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) | 0x200) );
+	}
+	#endif
+
+}
+
+static inline void __stop_tx(struct uart_nuc970_port *p)
+{
+	unsigned int ier;
+	struct tty_struct *tty = p->port.state->port.tty;
+
+	if ((ier = serial_in(p, UART_REG_IER)) & THRE_IEN) {
+		serial_out(p, UART_REG_IER, ier & ~THRE_IEN);
+	}
+	if (p->rs485.flags & SER_RS485_ENABLED)
+		rs485_start_rx(p);
+
+	if (tty->termios.c_line == N_IRDA)
+	{
+		while(!(serial_in(p, UART_REG_FSR) & TX_EMPTY));
+		while(!(serial_in(p, UART_REG_FSR) & TE_FLAG));
+
+		serial_out(p, UART_REG_IRCR, (serial_in(p, UART_REG_IRCR) & ~0x2) ); // Tx disable (select Rx)
+	}
+}
+
+static void nuc970serial_stop_tx(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	__stop_tx(up);
+
+}
+
+static void transmit_chars(struct uart_nuc970_port *up);
+
+static void nuc970serial_start_tx(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int ier;
+	struct tty_struct *tty = up->port.state->port.tty;
+
+	if (tty->termios.c_line == N_IRDA)
+	{
+		serial_out(up, UART_REG_IRCR, (serial_in(up, UART_REG_IRCR) | 0x2) ); // Tx enable
+	}
+
+	if (up->rs485.flags & SER_RS485_ENABLED)
+		rs485_stop_rx(up);
+
+    #if 0
+	if (!((ier = serial_in(up, UART_REG_IER)) & THRE_IEN)) {
+		ier |= THRE_IEN;
+		serial_out(up, UART_REG_IER, ier);
+	}
+	#else
+	{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	ier = serial_in(up, UART_REG_IER);
+	serial_out(up, UART_REG_IER, ier & ~THRE_IEN);
+	if( uart_circ_chars_pending(xmit)<(16-((serial_in(up, UART_REG_FSR)>>16)&0x3F)) )
+		transmit_chars(up);
+	serial_out(up, UART_REG_IER, ier | THRE_IEN);
+	}
+	#endif
+
+}
+
+static void nuc970serial_stop_rx(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	serial_out(up, UART_REG_IER, serial_in(up, UART_REG_IER) & ~RDA_IEN);
+}
+
+static void nuc970serial_enable_ms(struct uart_port *port)
+{
+
+}
+
+static void
+receive_chars(struct uart_nuc970_port *up)
+{
+	unsigned char ch;
+	unsigned int fsr;
+	int max_count = 256;
+	char flag;
+
+	do {
+                if(serial_in(up, UART_REG_FSR) & (1 << 14)) break;
+
+		fsr = serial_in(up, UART_REG_FSR);
+                ch = (unsigned char)serial_in(up, UART_REG_RBR);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(fsr & (BIF | FEF | PEF | RX_OVER_IF))) {
+			if (fsr & BIF) {
+				serial_out(up, UART_REG_FSR, BIF);
+				up->port.icount.brk++;
+				if (uart_handle_break(&up->port))
+					continue;
+			}
+
+			if (fsr & FEF) {
+				serial_out(up, UART_REG_FSR, FEF);
+				up->port.icount.frame++;
+			}
+
+			if (fsr & PEF) {
+				serial_out(up, UART_REG_FSR, PEF);
+				up->port.icount.parity++;
+			}
+
+			if (fsr & RX_OVER_IF) {
+				serial_out(up, UART_REG_FSR, RX_OVER_IF);
+				up->port.icount.overrun++;
+			}
+			// FIXME: check port->read_status_mask to determin report flags
+			if (fsr & BIF)
+				flag = TTY_BREAK;
+			if (fsr & PEF)
+				flag = TTY_PARITY;
+			if (fsr & FEF)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(&up->port, ch))
+			continue;
+
+		uart_insert_char(&up->port, fsr, RX_OVER_IF, ch, flag);
+
+	} while (!(fsr & RX_EMPTY) && (max_count-- > 0));
+
+	spin_lock(&up->port.lock);
+	tty_flip_buffer_push(&up->port.state->port);
+	spin_unlock(&up->port.lock);
+}
+
+static void transmit_chars(struct uart_nuc970_port *up)
+{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	int count = 12;
+
+	if (up->port.x_char) {
+		while(serial_in(up, UART_REG_FSR) & TX_FULL);
+		serial_out(up, UART_REG_THR, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+	if (uart_tx_stopped(&up->port)) {
+		nuc970serial_stop_tx(&up->port);
+		return;
+	}
+
+	if (uart_circ_empty(xmit)) {
+		__stop_tx(up);
+		return;
+	}
+
+	do {
+		//while(serial_in(up, UART_REG_FSR) & TX_FULL);
+		serial_out(up, UART_REG_THR, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (uart_circ_empty(xmit))
+		__stop_tx(up);
+}
+
+static unsigned int check_modem_status(struct uart_nuc970_port *up)
+{
+	unsigned int status = 0;
+
+	if (0) {
+
+		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
+	}
+
+	return status;
+}
+
+static irqreturn_t nuc970serial_interrupt(int irq, void *dev_id)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)dev_id;
+	unsigned int isr;
+
+	isr = serial_in(up, UART_REG_ISR);
+
+	if (isr & (RDA_IF | TOUT_IF))
+		receive_chars(up);
+
+	check_modem_status(up);
+
+	if (isr & THRE_IF)
+		transmit_chars(up);
+
+        if(isr & (BIF | FEF | PEF | RX_OVER_IF))
+	{
+	    serial_out(up, UART_REG_FSR, (BIF | FEF | PEF | RX_OVER_IF));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int nuc970serial_tx_empty(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	//unsigned long flags;
+	unsigned int fsr;
+
+	//spin_lock_irqsave(&up->port.lock, flags);
+	fsr = serial_in(up, UART_REG_FSR);
+	//spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return (fsr & (TE_FLAG | TX_EMPTY)) == (TE_FLAG | TX_EMPTY) ? TIOCSER_TEMT : 0;
+}
+
+static unsigned int nuc970serial_get_mctrl(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int status;
+	unsigned int ret = 0;
+
+	//status = check_modem_status(up);
+
+	status = serial_in(up, UART_REG_MSR);;
+
+	if(!(status & 0x10))
+		ret |= TIOCM_CTS;
+
+	return ret;
+}
+
+static void nuc970serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int mcr = 0;
+	unsigned int ier = 0;
+
+	if (mctrl & TIOCM_RTS)
+	{
+		// set RTS high level trigger
+		mcr = serial_in(up, UART_REG_MCR);
+		mcr |= 0x200;
+		mcr &= ~(0x2);
+	}
+
+	if (up->mcr & UART_MCR_AFE)
+	{
+		// set RTS high level trigger
+		mcr = serial_in(up, UART_REG_MCR);
+		mcr |= 0x200;
+		mcr &= ~(0x2);
+
+		// enable CTS/RTS auto-flow control
+		serial_out(up, UART_REG_IER, (serial_in(up, UART_REG_IER) | (0x3000)));
+		
+		// Set hardware flow control
+		up->port.flags |= UPF_HARD_FLOW;
+	}
+	else
+	{
+              // disable CTS/RTS auto-flow control
+              ier = serial_in(up, UART_REG_IER);
+              ier &= ~(0x3000);
+	      serial_out(up, UART_REG_IER, ier);
+	      
+	      //un-set hardware flow control
+              up->port.flags &= ~UPF_HARD_FLOW;
+	}
+
+	// set CTS high level trigger
+	serial_out(up, UART_REG_MSR, (serial_in(up, UART_REG_MSR) | (0x100)));
+	serial_out(up, UART_REG_MCR, mcr);
+}
+
+static void nuc970serial_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned long flags;
+	unsigned int lcr;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	lcr = serial_in(up, UART_REG_LCR);
+	if (break_state != 0)
+		lcr |= BCB;	// set break
+	else
+		lcr &= ~BCB;	// clr break
+	serial_out(up, UART_REG_LCR, lcr);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int nuc970serial_startup(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	struct tty_struct *tty = port->state->port.tty;
+	int retval;
+
+	//  TODO: configure pin function and enable engine clock
+	//nuc970serial_pinctrl();
+
+	/* Reset FIFO */
+	serial_out(up, UART_REG_FCR, TFR | RFR /* | RX_DIS */);
+
+	/* Clear pending interrupts (not every bit are write 1 clear though...) */
+	serial_out(up, UART_REG_ISR, 0xFFFFFFFF);
+
+	retval = request_irq(port->irq, nuc970serial_interrupt, IRQF_NO_SUSPEND,
+			tty ? tty->name : "nuc970_serial", port);
+
+	if (retval) {
+		printk("request irq failed...\n");
+		return retval;
+	}
+
+	/*
+	 * Now, initialize the UART
+	 */
+	serial_out(up, UART_REG_FCR, serial_in(up, UART_REG_FCR) | 0x10);	// Trigger level 4 byte
+	serial_out(up, UART_REG_LCR, 0x7);						// 8 bit
+	serial_out(up, UART_REG_TOR, 0x40);
+	serial_out(up, UART_REG_IER, RTO_IEN | RDA_IEN | TIME_OUT_EN);
+
+	/* 12MHz reference clock input, 115200 */
+	serial_out(up, UART_REG_BAUD, 0x30000066);
+
+	return 0;
+}
+
+static void nuc970serial_shutdown(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	//unsigned long flags;
+	free_irq(port->irq, port);
+
+	/*
+	 * Disable interrupts from this port
+	 */
+	serial_out(up, UART_REG_IER, 0);
+	//serial_out(up, UART_REG_FCR, TFR | RFR /* | RX_DIS */);
+
+}
+
+static unsigned int nuc970serial_get_divisor(struct uart_port *port, unsigned int baud)
+{
+	unsigned int quot;
+
+	quot = (port->uartclk / baud) - 2;
+
+	return quot;
+}
+
+static void
+nuc970serial_set_termios(struct uart_port *port, struct ktermios *termios,
+		       struct ktermios *old)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int lcr = 0;
+	unsigned long flags;
+	unsigned int baud, quot;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		lcr = 0;
+		break;
+	case CS6:
+		lcr |= 1;
+		break;
+	case CS7:
+		lcr |= 2;
+		break;
+	default:
+	case CS8:
+		lcr |= 3;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		lcr |= NSB;
+	if (termios->c_cflag & PARENB)
+		lcr |= PBE;
+	if (!(termios->c_cflag & PARODD))
+		lcr |= EPE;
+	if (termios->c_cflag & CMSPAR)
+		lcr |= SPE;
+
+	baud = uart_get_baud_rate(port, termios, old,
+				  port->uartclk / 0xffff,
+				  port->uartclk / 11);
+
+	quot = nuc970serial_get_divisor(port, baud);
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	up->port.read_status_mask = RX_OVER_IF /*| UART_LSR_THRE | UART_LSR_DR*/;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= FEF | PEF;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= BIF;
+
+	/*
+	 * Characteres to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= FEF | PEF;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= BIF;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= RX_OVER_IF;
+	}
+
+	if (termios->c_cflag & CRTSCTS)
+		up->mcr |= UART_MCR_AFE;
+	else
+		up->mcr &= ~UART_MCR_AFE;
+
+	nuc970serial_set_mctrl(&up->port, up->port.mctrl);
+
+	serial_out(up, UART_REG_BAUD, quot | 0x30000000);
+	serial_out(up, UART_REG_LCR, lcr);
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+}
+
+static void
+//nuc970serial_set_ldisc(struct uart_port *port, int ld)
+nuc970serial_set_ldisc(struct uart_port *port, struct ktermios *tm)
+{
+	struct uart_nuc970_port *uart = (struct uart_nuc970_port *)port;
+	unsigned int baud;
+
+	int ld = tm->c_line;
+
+	switch (ld) {
+	case N_IRDA:
+
+		baud = serial_in(uart, UART_REG_BAUD);
+		baud = baud & (0x0000ffff);
+		baud = baud + 2;
+		baud = baud / 16;
+		baud = baud - 2;
+
+		serial_out(uart, UART_REG_BAUD, baud);
+		serial_out(uart, UART_REG_IRCR, (serial_in(uart, UART_REG_IRCR) & ~0x40) );  // Rx inverse
+
+		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) & ~FUN_SEL_Msk) );
+		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) | FUN_SEL_IrDA) );
+
+		break;
+	default:
+		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) & ~FUN_SEL_Msk) );
+	}
+
+}
+
+static void
+nuc970serial_pm(struct uart_port *port, unsigned int state,
+	      unsigned int oldstate)
+{
+	struct uart_nuc970_port *p = (struct uart_nuc970_port *)port;
+
+
+	if (p->pm)
+		p->pm(port, state, oldstate);
+}
+
+static void nuc970serial_release_port(struct uart_port *port)
+{
+	iounmap(port->membase);
+	port->membase = NULL;
+}
+
+static int nuc970serial_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void nuc970serial_config_port(struct uart_port *port, int flags)
+{
+	int ret;
+
+	/*
+	 * Find the region that we can probe for.  This in turn
+	 * tells us whether we can probe for the type of port.
+	 */
+	ret = nuc970serial_request_port(port);
+	if (ret < 0)
+		return;
+	port->type = PORT_NUC970;
+
+
+}
+
+static int
+nuc970serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_NUC970)
+		return -EINVAL;
+	return 0;
+}
+
+static const char *
+nuc970serial_type(struct uart_port *port)
+{
+
+	return (port->type == PORT_NUC970) ? "NUC970" : NULL;
+}
+
+/* Enable or disable the rs485 support */
+void nuc970serial_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)
+{
+	struct uart_nuc970_port *p = to_nuc970_uart_port(port);
+
+	spin_lock(&port->lock);
+
+	p->rs485 = *rs485conf;
+
+	if (p->rs485.delay_rts_before_send >= 1000)
+		p->rs485.delay_rts_before_send = 1000;
+
+	serial_out(p, UART_FUN_SEL, (serial_in(p, UART_FUN_SEL) & ~FUN_SEL_Msk) );
+
+	if(rs485conf->flags & SER_RS485_ENABLED)
+	{
+		serial_out(p, UART_FUN_SEL, (serial_in(p, UART_FUN_SEL) | FUN_SEL_RS485) );
+
+		//rs485_start_rx(p);	// stay in Rx mode
+
+		if(rs485conf->flags & SER_RS485_RTS_ON_SEND)
+		{
+			serial_out(p, UART_REG_MCR, (serial_in(p, UART_REG_MCR) & ~0x200) );
+		}
+		else
+		{
+			serial_out(p, UART_REG_MCR, (serial_in(p, UART_REG_MCR) | 0x200) );
+		}
+
+		// set auto direction mode
+		serial_out(p,UART_REG_ALT_CSR,(serial_in(p, UART_REG_ALT_CSR) | (1 << 10)) );
+	}
+
+	spin_unlock(&port->lock);
+}
+
+static int
+nuc970serial_rs485_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+	struct serial_rs485 rs485conf;
+
+	switch (cmd) {
+	case TIOCSRS485:
+		if (copy_from_user(&rs485conf, (struct serial_rs485 *) arg,
+					sizeof(rs485conf)))
+			return -EFAULT;
+
+		nuc970serial_config_rs485(port, &rs485conf);
+		break;
+
+	case TIOCGRS485:
+		if (copy_to_user((struct serial_rs485 *) arg,
+					&(to_nuc970_uart_port(port)->rs485),
+					sizeof(rs485conf)))
+			return -EFAULT;
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+static struct uart_ops nuc970serial_ops = {
+	.tx_empty	= nuc970serial_tx_empty,
+	.set_mctrl	= nuc970serial_set_mctrl,
+	.get_mctrl	= nuc970serial_get_mctrl,
+	.stop_tx	= nuc970serial_stop_tx,
+	.start_tx	= nuc970serial_start_tx,
+	.stop_rx	= nuc970serial_stop_rx,
+	.enable_ms	= nuc970serial_enable_ms,
+	.break_ctl	= nuc970serial_break_ctl,
+	.startup	= nuc970serial_startup,
+	.shutdown	= nuc970serial_shutdown,
+	.set_termios	= nuc970serial_set_termios,
+	.set_ldisc	= nuc970serial_set_ldisc,
+	.pm		= nuc970serial_pm,
+	.type		= nuc970serial_type,
+	.release_port	= nuc970serial_release_port,
+	.request_port	= nuc970serial_request_port,
+	.config_port	= nuc970serial_config_port,
+	.verify_port	= nuc970serial_verify_port,
+	.ioctl		= nuc970serial_rs485_ioctl,
+
+};
+
+static void __init nuc970serial_init_ports(void)
+{
+	static int first = 1;
+	int i;
+
+	// enable clock
+	clk = clk_get(NULL, "uart0");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_nuc970_port *up = &nuc970serial_ports[i];
+
+		up->port.line = i;
+		spin_lock_init(&up->port.lock);
+
+		up->port.ops = &nuc970serial_ops;
+		up->port.iobase = (long)(NUC970_VA_UART + (i*0x100));
+		up->port.membase = NUC970_VA_UART + (i*0x100);
+		up->port.uartclk = 12000000;
+
+	}
+}
+
+#ifdef CONFIG_SERIAL_NUC970_CONSOLE
+static void nuc970serial_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));
+	serial_out(up, UART_REG_THR, ch);
+}
+
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void
+nuc970serial_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_nuc970_port *up = &nuc970serial_ports[co->index];
+	unsigned long flags;
+	unsigned int ier;
+
+	local_irq_save(flags);
+
+	/*
+	 *	First save the IER then disable the interrupts
+	 */
+	ier = serial_in(up, UART_REG_IER);
+	serial_out(up, UART_REG_IER, 0);
+
+	uart_console_write(&up->port, s, count, nuc970serial_console_putchar);
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IER
+	 */
+	while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));
+	serial_out(up, UART_REG_IER, ier);
+
+
+	local_irq_restore(flags);
+}
+
+static int __init nuc970serial_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= UART_NR)
+		co->index = 0;
+	port = &nuc970serial_ports[co->index].port;
+
+	if (!port->iobase && !port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+
+static struct console nuc970serial_console = {
+	.name		= "ttyS",
+	.write		= nuc970serial_console_write,
+	.device		= uart_console_device,
+	.setup		= nuc970serial_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &nuc970serial_reg,
+};
+
+static int __init nuc970serial_console_init(void)
+{
+	nuc970serial_init_ports();
+	register_console(&nuc970serial_console);
+
+	return 0;
+}
+console_initcall(nuc970serial_console_init);
+
+#define NUC970SERIAL_CONSOLE	&nuc970serial_console
+#else
+#define NUC970SERIAL_CONSOLE	NULL
+#endif
+
+static struct uart_driver nuc970serial_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "serial",
+	.dev_name		= "ttyS",
+	.major			= TTY_MAJOR,
+	.minor			= 64,
+	.cons			= NUC970SERIAL_CONSOLE,
+	.nr				= UART_NR,
+};
+
+
+/**
+ *
+ *	Suspend one serial port.
+ */
+void nuc970serial_suspend_port(int line)
+{
+	uart_suspend_port(&nuc970serial_reg, &nuc970serial_ports[line].port);
+}
+
+/**
+ *
+ *	Resume one serial port.
+ */
+void nuc970serial_resume_port(int line)
+{
+	struct uart_nuc970_port *up = &nuc970serial_ports[line];
+
+	uart_resume_port(&nuc970serial_reg, &up->port);
+}
+
+
+static int  get_uart_port_number(struct platform_device *pdev)
+{
+	u32   val32[2];
+
+	if (of_property_read_u32_array(pdev->dev.of_node, "port-number", val32, 1) != 0) 
+	{
+		printk("%s - can not get port-number!\n", __func__);
+		return -EINVAL;
+	}
+	// printk("%s - serial port %d called...\n", __func__, val32[0]);
+	return val32[0];
+}
+
+
+/*
+ * Register a set of serial devices attached to a platform device.  The
+ * list is terminated with a zero flags entry, which means we expect
+ * all entries to have at least UPF_BOOT_AUTOCONF set.
+ */
+static int nuc970serial_probe(struct platform_device *pdev)
+{
+	struct uart_nuc970_port *up;
+	u32   val32[2];
+	int   port;
+	char  ustr[16];
+	struct pinctrl *pinctrl;
+	
+	printk("%s - pdev = %s\n", __func__, pdev->name);
+	
+	port = get_uart_port_number(pdev);
+	if (port < 0) 
+		return port;
+
+	up = &nuc970serial_ports[port];
+	up->port.line = port;
+
+    /*--------------------------------------------------------------*/
+    /*  get UART register map address from DTB                      */
+    /*--------------------------------------------------------------*/
+	if (of_property_read_u32_array(pdev->dev.of_node, "map-addr", val32, 1) != 0) 
+	{
+		printk("%s - can not get map-addr!\n", __func__);
+		return -EINVAL;
+	}
+	// printk("%s - map address: 0x%x...\n", __func__, val32[0]);
+
+	up->port.membase = (unsigned char __iomem *)val32[0];
+	up->port.iobase = (unsigned long)up->port.membase;
+
+	up->port.irq = platform_get_irq(pdev, 0);
+	printk("platform_get_irq - %d\n", up->port.irq);
+
+	up->port.dev 			= &pdev->dev;
+	up->port.flags 			= ASYNC_BOOT_AUTOCONF;
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		return PTR_ERR(pinctrl);
+	}
+        
+    /*--------------------------------------------------------------*/
+    /*  enable UART clock                                           */
+    /*--------------------------------------------------------------*/
+    sprintf(ustr, "uart%d", port);
+	clk = clk_get(NULL, ustr);
+	clk_prepare(clk);
+	clk_enable(clk);
+
+    sprintf(ustr, "uart%d_eclk", port);
+	clk = clk_get(NULL, ustr);
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	return uart_add_one_port(&nuc970serial_reg, &up->port);
+}
+
+/*
+ * Remove serial ports registered against a platform device.
+ */
+static int nuc970serial_remove(struct platform_device *dev)
+{
+	int i;
+	struct uart_port *port = platform_get_drvdata(dev);
+
+	free_irq(port->irq, port);
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_nuc970_port *up = &nuc970serial_ports[i];
+
+		if (up->port.dev == &dev->dev)
+			uart_remove_one_port(&nuc970serial_reg, &up->port);
+	}
+	return 0;
+}
+
+static int nuc970serial_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int i;
+	int wakeup_flag = 0;
+
+	struct uart_nuc970_port *up;
+
+	i = get_uart_port_number(dev);
+	if (i < 0) 
+		return i;
+
+    //printk("\n uart suspend !! %d \n", i);
+
+        up = &nuc970serial_ports[i];
+
+        //if (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)
+	//		uart_suspend_port(&nuc970serial_reg, &up->port);
+
+#ifdef ENABLE_CTS_WAKEUP
+        if(i == 1)
+        {
+            __raw_writel((1<<8) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+
+        if(i == 2)
+        {
+            __raw_writel((1<<9) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+
+        if(i == 4)
+        {
+            __raw_writel((1<<10) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+
+        if(i == 6)
+        {
+            __raw_writel((1<<11) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+
+        if(i == 8)
+            __raw_writel((1<<12) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+
+        if(i == 10)
+        {
+            __raw_writel((1<<13) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+#endif
+
+        if(wakeup_flag == 1)
+        {
+	    //request_irq(up->port.irq, nuc970serial_interrupt, IRQF_NO_SUSPEND,
+	    //		"nuc970_serial", 0);
+
+            serial_out(up, UART_REG_IER, serial_in(up, UART_REG_IER) | (0x1 << 6));
+
+            enable_irq_wake(up->port.irq);
+	}
+
+	return 0;
+}
+
+static int nuc970serial_resume(struct platform_device *dev)
+{
+        #if 0
+	int  i;
+
+	for (i = 0; i < UART_NR; i++) 
+	{
+		struct uart_nuc970_port *up = &nuc970serial_ports[i];
+
+		if (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)
+			nuc970serial_resume_port(i);
+
+	}
+	#endif
+
+        //printk("\n uart resume !\n");
+
+	return 0;
+}
+
+
+static const struct of_device_id nuc970_serial_of_match[] = {
+	{ .compatible = "nuvoton,nuc970-uart" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nuc970_serial_of_match);
+
+
+static struct platform_driver nuc970serial_driver = {
+	.probe		= nuc970serial_probe,
+	.remove		= nuc970serial_remove,
+	.suspend	= nuc970serial_suspend,
+	.resume		= nuc970serial_resume,
+	.driver		= {
+		.name	= "nuc970-uart",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(nuc970_serial_of_match),
+	},
+};
+
+static int __init nuc970serial_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&nuc970serial_reg);
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&nuc970serial_driver);
+	if (ret)
+		uart_unregister_driver(&nuc970serial_reg);
+
+	return ret;
+}
+
+static void __exit nuc970serial_exit(void)
+{
+	platform_driver_unregister(&nuc970serial_driver);
+	uart_unregister_driver(&nuc970serial_reg);
+}
+
+module_init(nuc970serial_init);
+module_exit(nuc970serial_exit);
+
+EXPORT_SYMBOL(nuc970serial_suspend_port);
+EXPORT_SYMBOL(nuc970serial_resume_port);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NUC970 serial driver");
+
+MODULE_ALIAS_CHARDEV_MAJOR(TTY_MAJOR);
Index: linux-4.4.92/drivers/tty/serial/nuc970_serial.c
===================================================================
--- /dev/null
+++ linux-4.4.92/drivers/tty/serial/nuc970_serial.c
@@ -0,0 +1,1371 @@
+/*
+ *  linux/drivers/serial/nuc970_serial.c
+ *
+ *  NUC970 serial driver
+ *
+ *
+ *  Copyright (C) 2014 Nuvoton Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#if defined(CONFIG_SERIAL_NUC970_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/clk.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/nmi.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+
+#include <mach/map.h>
+#include <mach/regs-serial.h>
+#include <mach/regs-gcr.h>
+#include <mach/mfp.h>
+
+
+#include "nuc970_serial.h"
+
+#define UART_NR 11
+static struct uart_driver nuc970serial_reg;
+
+struct clk		*clk;
+
+struct uart_nuc970_port {
+	struct uart_port	port;
+
+	unsigned short		capabilities;	/* port capabilities */
+	unsigned char		ier;
+	unsigned char		lcr;
+	unsigned char		mcr;
+	unsigned char		mcr_mask;	/* mask of user bits */
+	unsigned char		mcr_force;	/* mask of forced bits */
+
+	struct serial_rs485     rs485;          /* rs485 settings */
+	/*
+	 * We provide a per-port pm hook.
+	 */
+	void			(*pm)(struct uart_port *port,
+				      unsigned int state, unsigned int old);
+};
+
+static struct uart_nuc970_port nuc970serial_ports[UART_NR];
+
+static inline struct uart_nuc970_port *
+to_nuc970_uart_port(struct uart_port *uart)
+{
+	return container_of(uart, struct uart_nuc970_port, port);
+}
+
+static inline unsigned int serial_in(struct uart_nuc970_port *p, int offset)
+{
+	return(__raw_readl(p->port.membase + offset));
+}
+
+static inline void serial_out(struct uart_nuc970_port *p, int offset, int value)
+{
+	__raw_writel(value, p->port.membase + offset);
+}
+
+static void rs485_start_rx(struct uart_nuc970_port *port)
+{
+	#if 0
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	if(port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
+	{
+		// Set logical level for RTS pin equal to high
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) & ~0x200) );
+}
+	else
+{
+		// Set logical level for RTS pin equal to low
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) | 0x200) );
+	}
+	#endif
+}
+
+static void rs485_stop_rx(struct uart_nuc970_port *port)
+{
+	#if 0
+	if(port->rs485.flags & SER_RS485_RTS_ON_SEND)
+	{
+		// Set logical level for RTS pin equal to high
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) & ~0x200) );
+	}
+	else
+	{
+		// Set logical level for RTS pin equal to low
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) | 0x200) );
+	}
+	#endif
+
+}
+
+static inline void __stop_tx(struct uart_nuc970_port *p)
+{
+	unsigned int ier;
+	struct tty_struct *tty = p->port.state->port.tty;
+
+	if ((ier = serial_in(p, UART_REG_IER)) & THRE_IEN) {
+		serial_out(p, UART_REG_IER, ier & ~THRE_IEN);
+	}
+	if (p->rs485.flags & SER_RS485_ENABLED)
+		rs485_start_rx(p);
+
+	if (tty->termios.c_line == N_IRDA)
+	{
+		while(!(serial_in(p, UART_REG_FSR) & TX_EMPTY));
+		while(!(serial_in(p, UART_REG_FSR) & TE_FLAG));
+
+		serial_out(p, UART_REG_IRCR, (serial_in(p, UART_REG_IRCR) & ~0x2) ); // Tx disable (select Rx)
+	}
+}
+
+static void nuc970serial_stop_tx(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	__stop_tx(up);
+
+}
+
+static void transmit_chars(struct uart_nuc970_port *up);
+
+static void nuc970serial_start_tx(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int ier;
+	struct tty_struct *tty = up->port.state->port.tty;
+
+	if (tty->termios.c_line == N_IRDA)
+	{
+		serial_out(up, UART_REG_IRCR, (serial_in(up, UART_REG_IRCR) | 0x2) ); // Tx enable
+	}
+
+	if (up->rs485.flags & SER_RS485_ENABLED)
+		rs485_stop_rx(up);
+
+    #if 0
+	if (!((ier = serial_in(up, UART_REG_IER)) & THRE_IEN)) {
+		ier |= THRE_IEN;
+		serial_out(up, UART_REG_IER, ier);
+	}
+	#else
+	{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	ier = serial_in(up, UART_REG_IER);
+	serial_out(up, UART_REG_IER, ier & ~THRE_IEN);
+	if( uart_circ_chars_pending(xmit)<(16-((serial_in(up, UART_REG_FSR)>>16)&0x3F)) )
+		transmit_chars(up);
+	serial_out(up, UART_REG_IER, ier | THRE_IEN);
+	}
+	#endif
+
+}
+
+static void nuc970serial_stop_rx(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	serial_out(up, UART_REG_IER, serial_in(up, UART_REG_IER) & ~RDA_IEN);
+}
+
+static void nuc970serial_enable_ms(struct uart_port *port)
+{
+
+}
+
+static void
+receive_chars(struct uart_nuc970_port *up)
+{
+	unsigned char ch;
+	unsigned int fsr;
+	int max_count = 256;
+	char flag;
+
+	do {
+                if(serial_in(up, UART_REG_FSR) & (1 << 14)) break;
+
+		fsr = serial_in(up, UART_REG_FSR);
+                ch = (unsigned char)serial_in(up, UART_REG_RBR);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(fsr & (BIF | FEF | PEF | RX_OVER_IF))) {
+			if (fsr & BIF) {
+				serial_out(up, UART_REG_FSR, BIF);
+				up->port.icount.brk++;
+				if (uart_handle_break(&up->port))
+					continue;
+			}
+
+			if (fsr & FEF) {
+				serial_out(up, UART_REG_FSR, FEF);
+                                up->port.icount.frame++;
+			}
+
+			if (fsr & PEF) {
+				serial_out(up, UART_REG_FSR, PEF);
+                                up->port.icount.parity++;
+			}
+
+			if (fsr & RX_OVER_IF) {
+				serial_out(up, UART_REG_FSR, RX_OVER_IF);
+				up->port.icount.overrun++;
+			}
+			// FIXME: check port->read_status_mask to determin report flags
+			if (fsr & BIF)
+				flag = TTY_BREAK;
+			if (fsr & PEF)
+				flag = TTY_PARITY;
+			if (fsr & FEF)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(&up->port, ch))
+			continue;
+
+		uart_insert_char(&up->port, fsr, RX_OVER_IF, ch, flag);
+
+	} while (!(fsr & RX_EMPTY) && (max_count-- > 0));
+
+	spin_lock(&up->port.lock);
+	tty_flip_buffer_push(&up->port.state->port);
+	spin_unlock(&up->port.lock);
+}
+
+static void transmit_chars(struct uart_nuc970_port *up)
+{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	int count = 12;
+
+	if (up->port.x_char) {
+		while(serial_in(up, UART_REG_FSR) & TX_FULL);
+		serial_out(up, UART_REG_THR, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+	if (uart_tx_stopped(&up->port)) {
+		nuc970serial_stop_tx(&up->port);
+		return;
+	}
+
+	if (uart_circ_empty(xmit)) {
+		__stop_tx(up);
+		return;
+	}
+
+	do {
+		//while(serial_in(up, UART_REG_FSR) & TX_FULL);
+		serial_out(up, UART_REG_THR, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (uart_circ_empty(xmit))
+		__stop_tx(up);
+}
+
+static unsigned int check_modem_status(struct uart_nuc970_port *up)
+{
+	unsigned int status = 0;
+
+	if (0) {
+
+		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
+	}
+
+	return status;
+}
+
+static irqreturn_t nuc970serial_interrupt(int irq, void *dev_id)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)dev_id;
+	unsigned int isr;
+
+	isr = serial_in(up, UART_REG_ISR);
+
+	if (isr & (RDA_IF | TOUT_IF))
+		receive_chars(up);
+
+	check_modem_status(up);
+
+	if (isr & THRE_IF)
+		transmit_chars(up);
+
+        if(isr & (BIF | FEF | PEF | RX_OVER_IF))
+	{
+	    serial_out(up, UART_REG_FSR, (BIF | FEF | PEF | RX_OVER_IF));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int nuc970serial_tx_empty(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	//unsigned long flags;
+	unsigned int fsr;
+
+	//spin_lock_irqsave(&up->port.lock, flags);
+	fsr = serial_in(up, UART_REG_FSR);
+	//spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return (fsr & (TE_FLAG | TX_EMPTY)) == (TE_FLAG | TX_EMPTY) ? TIOCSER_TEMT : 0;
+}
+
+static unsigned int nuc970serial_get_mctrl(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int status;
+	unsigned int ret = 0;
+
+	//status = check_modem_status(up);
+
+	status = serial_in(up, UART_REG_MSR);;
+
+	if(!(status & 0x10))
+		ret |= TIOCM_CTS;
+
+	return ret;
+}
+
+static void nuc970serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int mcr = 0;
+	unsigned int ier = 0;
+
+	if (mctrl & TIOCM_RTS)
+	{
+		// set RTS high level trigger
+		mcr = serial_in(up, UART_REG_MCR);
+		mcr |= 0x200;
+		mcr &= ~(0x2);
+	}
+
+	if (up->mcr & UART_MCR_AFE)
+	{
+		// set RTS high level trigger
+		mcr = serial_in(up, UART_REG_MCR);
+		mcr |= 0x200;
+		mcr &= ~(0x2);
+
+		// enable CTS/RTS auto-flow control
+		serial_out(up, UART_REG_IER, (serial_in(up, UART_REG_IER) | (0x3000)));
+		
+		// Set hardware flow control
+		up->port.flags |= UPF_HARD_FLOW;
+	}
+	else
+	{
+              // disable CTS/RTS auto-flow control
+              ier = serial_in(up, UART_REG_IER);
+              ier &= ~(0x3000);
+	      serial_out(up, UART_REG_IER, ier);
+	      
+	      //un-set hardware flow control
+              up->port.flags &= ~UPF_HARD_FLOW;
+	}
+
+	// set CTS high level trigger
+	serial_out(up, UART_REG_MSR, (serial_in(up, UART_REG_MSR) | (0x100)));
+	serial_out(up, UART_REG_MCR, mcr);
+}
+
+static void nuc970serial_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned long flags;
+	unsigned int lcr;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	lcr = serial_in(up, UART_REG_LCR);
+	if (break_state != 0)
+		lcr |= BCB;	// set break
+	else
+		lcr &= ~BCB;	// clr break
+	serial_out(up, UART_REG_LCR, lcr);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int nuc970serial_startup(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	struct tty_struct *tty = port->state->port.tty;
+	int retval;
+
+	//  TODO: configure pin function and enable engine clock
+	//nuc970serial_pinctrl();
+
+	/* Reset FIFO */
+	serial_out(up, UART_REG_FCR, TFR | RFR /* | RX_DIS */);
+
+	/* Clear pending interrupts (not every bit are write 1 clear though...) */
+	serial_out(up, UART_REG_ISR, 0xFFFFFFFF);
+
+	retval = request_irq(port->irq, nuc970serial_interrupt, IRQF_NO_SUSPEND,
+			tty ? tty->name : "nuc970_serial", port);
+
+	if (retval) {
+		printk("nuc970 serial port request irq failed..., res:%d\n", retval);
+		return retval;
+	}
+
+	/*
+	 * Now, initialize the UART
+	 */
+	serial_out(up, UART_REG_FCR, serial_in(up, UART_REG_FCR) | 0x10);	// Trigger level 4 byte
+	serial_out(up, UART_REG_LCR, 0x7);						// 8 bit
+	serial_out(up, UART_REG_TOR, 0x40);
+	serial_out(up, UART_REG_IER, RTO_IEN | RDA_IEN | TIME_OUT_EN);
+
+	/* 12MHz reference clock input, 115200 */
+	serial_out(up, UART_REG_BAUD, 0x30000066);
+
+	return 0;
+}
+
+static void nuc970serial_shutdown(struct uart_port *port)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	//unsigned long flags;
+	free_irq(port->irq, port);
+
+	/*
+	 * Disable interrupts from this port
+	 */
+	serial_out(up, UART_REG_IER, 0);
+	//serial_out(up, UART_REG_FCR, TFR | RFR /* | RX_DIS */);
+
+}
+
+static unsigned int nuc970serial_get_divisor(struct uart_port *port, unsigned int baud)
+{
+	unsigned int quot;
+
+	quot = (port->uartclk / baud) - 2;
+
+	return quot;
+}
+
+static void
+nuc970serial_set_termios(struct uart_port *port, struct ktermios *termios,
+		       struct ktermios *old)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+	unsigned int lcr = 0;
+	unsigned long flags;
+	unsigned int baud, quot;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		lcr = 0;
+		break;
+	case CS6:
+		lcr |= 1;
+		break;
+	case CS7:
+		lcr |= 2;
+		break;
+	default:
+	case CS8:
+		lcr |= 3;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		lcr |= NSB;
+	if (termios->c_cflag & PARENB)
+		lcr |= PBE;
+	if (!(termios->c_cflag & PARODD))
+		lcr |= EPE;
+	if (termios->c_cflag & CMSPAR)
+		lcr |= SPE;
+
+	baud = uart_get_baud_rate(port, termios, old,
+				  port->uartclk / 0xffff,
+				  port->uartclk / 11);
+
+	quot = nuc970serial_get_divisor(port, baud);
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	up->port.read_status_mask = RX_OVER_IF /*| UART_LSR_THRE | UART_LSR_DR*/;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= FEF | PEF;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= BIF;
+
+	/*
+	 * Characteres to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= FEF | PEF;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= BIF;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= RX_OVER_IF;
+	}
+
+	if (termios->c_cflag & CRTSCTS)
+		up->mcr |= UART_MCR_AFE;
+	else
+		up->mcr &= ~UART_MCR_AFE;
+
+	nuc970serial_set_mctrl(&up->port, up->port.mctrl);
+
+	serial_out(up, UART_REG_BAUD, quot | 0x30000000);
+	serial_out(up, UART_REG_LCR, lcr);
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+}
+
+static void
+//nuc970serial_set_ldisc(struct uart_port *port, int ld)
+nuc970serial_set_ldisc(struct uart_port *port, struct ktermios *tm)
+{
+	struct uart_nuc970_port *uart = (struct uart_nuc970_port *)port;
+	unsigned int baud;
+
+	int ld = tm->c_line;
+
+	switch (ld) {
+	case N_IRDA:
+
+		baud = serial_in(uart, UART_REG_BAUD);
+		baud = baud & (0x0000ffff);
+		baud = baud + 2;
+		baud = baud / 16;
+		baud = baud - 2;
+
+		serial_out(uart, UART_REG_BAUD, baud);
+		serial_out(uart, UART_REG_IRCR, (serial_in(uart, UART_REG_IRCR) & ~0x40) );  // Rx inverse
+
+		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) & ~FUN_SEL_Msk) );
+		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) | FUN_SEL_IrDA) );
+
+		break;
+	default:
+		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) & ~FUN_SEL_Msk) );
+	}
+
+}
+
+static void
+nuc970serial_pm(struct uart_port *port, unsigned int state,
+	      unsigned int oldstate)
+{
+	struct uart_nuc970_port *p = (struct uart_nuc970_port *)port;
+
+
+	if (p->pm)
+		p->pm(port, state, oldstate);
+}
+
+static void nuc970serial_release_port(struct uart_port *port)
+{
+	struct platform_device *pdev = to_platform_device(port->dev);
+	int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	release_mem_region(port->mapbase, size);
+
+	iounmap(port->membase);
+	port->membase = NULL;
+
+
+}
+
+static int nuc970serial_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void nuc970serial_config_port(struct uart_port *port, int flags)
+{
+	int ret;
+
+	/*
+	 * Find the region that we can probe for.  This in turn
+	 * tells us whether we can probe for the type of port.
+	 */
+	ret = nuc970serial_request_port(port);
+	if (ret < 0)
+		return;
+	port->type = PORT_NUC970;
+
+
+}
+
+static int
+nuc970serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_NUC970)
+		return -EINVAL;
+	return 0;
+}
+
+static const char *
+nuc970serial_type(struct uart_port *port)
+{
+
+	return (port->type == PORT_NUC970) ? "NUC970" : NULL;
+}
+
+/* Enable or disable the rs485 support */
+void nuc970serial_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)
+{
+	struct uart_nuc970_port *p = to_nuc970_uart_port(port);
+
+	spin_lock(&port->lock);
+
+	p->rs485 = *rs485conf;
+
+	if (p->rs485.delay_rts_before_send >= 1000)
+		p->rs485.delay_rts_before_send = 1000;
+
+	serial_out(p, UART_FUN_SEL, (serial_in(p, UART_FUN_SEL) & ~FUN_SEL_Msk) );
+
+	if(rs485conf->flags & SER_RS485_ENABLED)
+	{
+		serial_out(p, UART_FUN_SEL, (serial_in(p, UART_FUN_SEL) | FUN_SEL_RS485) );
+
+		//rs485_start_rx(p);	// stay in Rx mode
+
+		if(rs485conf->flags & SER_RS485_RTS_ON_SEND)
+		{
+			serial_out(p, UART_REG_MCR, (serial_in(p, UART_REG_MCR) & ~0x200) );
+		}
+		else
+		{
+			serial_out(p, UART_REG_MCR, (serial_in(p, UART_REG_MCR) | 0x200) );
+		}
+
+		// set auto direction mode
+		serial_out(p,UART_REG_ALT_CSR,(serial_in(p, UART_REG_ALT_CSR) | (1 << 10)) );
+	}
+
+	spin_unlock(&port->lock);
+}
+
+static int
+nuc970serial_rs485_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+	struct serial_rs485 rs485conf;
+
+	switch (cmd) {
+	case TIOCSRS485:
+		if (copy_from_user(&rs485conf, (struct serial_rs485 *) arg,
+					sizeof(rs485conf)))
+			return -EFAULT;
+
+		nuc970serial_config_rs485(port, &rs485conf);
+		break;
+
+	case TIOCGRS485:
+		if (copy_to_user((struct serial_rs485 *) arg,
+					&(to_nuc970_uart_port(port)->rs485),
+					sizeof(rs485conf)))
+			return -EFAULT;
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+static struct uart_ops nuc970serial_ops = {
+	.tx_empty	= nuc970serial_tx_empty,
+	.set_mctrl	= nuc970serial_set_mctrl,
+	.get_mctrl	= nuc970serial_get_mctrl,
+	.stop_tx	= nuc970serial_stop_tx,
+	.start_tx	= nuc970serial_start_tx,
+	.stop_rx	= nuc970serial_stop_rx,
+	.enable_ms	= nuc970serial_enable_ms,
+	.break_ctl	= nuc970serial_break_ctl,
+	.startup	= nuc970serial_startup,
+	.shutdown	= nuc970serial_shutdown,
+	.set_termios	= nuc970serial_set_termios,
+	.set_ldisc	= nuc970serial_set_ldisc,
+	.pm		= nuc970serial_pm,
+	.type		= nuc970serial_type,
+	.release_port	= nuc970serial_release_port,
+	.request_port	= nuc970serial_request_port,
+	.config_port	= nuc970serial_config_port,
+	.verify_port	= nuc970serial_verify_port,
+	.ioctl		= nuc970serial_rs485_ioctl,
+
+};
+
+static void __init nuc970serial_init_ports(void)
+{
+	static int first = 1;
+	int i;
+
+	// enable clock
+	clk = clk_get(NULL, "uart0");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_nuc970_port *up = &nuc970serial_ports[i];
+
+		up->port.line = i;
+		spin_lock_init(&up->port.lock);
+
+		up->port.ops = &nuc970serial_ops;
+		up->port.iobase = (long)(NUC970_VA_UART + (i*0x100));
+		up->port.membase = NUC970_VA_UART + (i*0x100);
+		up->port.uartclk = 12000000;
+
+	}
+}
+
+#ifdef CONFIG_SERIAL_NUC970_CONSOLE
+static void nuc970serial_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_nuc970_port *up = (struct uart_nuc970_port *)port;
+
+	while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));
+	serial_out(up, UART_REG_THR, ch);
+}
+
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void
+nuc970serial_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_nuc970_port *up = &nuc970serial_ports[co->index];
+	unsigned long flags;
+	unsigned int ier;
+
+	local_irq_save(flags);
+
+	/*
+	 *	First save the IER then disable the interrupts
+	 */
+	ier = serial_in(up, UART_REG_IER);
+	serial_out(up, UART_REG_IER, 0);
+
+	uart_console_write(&up->port, s, count, nuc970serial_console_putchar);
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IER
+	 */
+	while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));
+	serial_out(up, UART_REG_IER, ier);
+
+
+	local_irq_restore(flags);
+}
+
+static int __init nuc970serial_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= UART_NR)
+		co->index = 0;
+	port = &nuc970serial_ports[co->index].port;
+
+	if (!port->iobase && !port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+
+static struct console nuc970serial_console = {
+	.name		= "ttyS",
+	.write		= nuc970serial_console_write,
+	.device		= uart_console_device,
+	.setup		= nuc970serial_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &nuc970serial_reg,
+};
+
+static int __init nuc970serial_console_init(void)
+{
+	nuc970serial_init_ports();
+	register_console(&nuc970serial_console);
+
+	return 0;
+}
+console_initcall(nuc970serial_console_init);
+
+#define NUC970SERIAL_CONSOLE	&nuc970serial_console
+#else
+#define NUC970SERIAL_CONSOLE	NULL
+#endif
+
+static struct uart_driver nuc970serial_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "serial",
+	.dev_name		= "ttyS",
+	.major			= TTY_MAJOR,
+	.minor			= 64,
+	.cons			= NUC970SERIAL_CONSOLE,
+	.nr				= UART_NR,
+};
+
+
+/**
+ *
+ *	Suspend one serial port.
+ */
+void nuc970serial_suspend_port(int line)
+{
+	uart_suspend_port(&nuc970serial_reg, &nuc970serial_ports[line].port);
+}
+
+/**
+ *
+ *	Resume one serial port.
+ */
+void nuc970serial_resume_port(int line)
+{
+	struct uart_nuc970_port *up = &nuc970serial_ports[line];
+
+	uart_resume_port(&nuc970serial_reg, &up->port);
+}
+
+static int nuc970serial_pinctrl(struct platform_device *pdev)
+{
+	struct pinctrl *p = NULL;
+	int retval = 0;
+
+if(pdev->id == 1)
+{
+#if defined (CONFIG_NUC970_UART1_PE)
+    p = devm_pinctrl_get_select(&pdev->dev, "uart1-PE");
+#elif defined (CONFIG_NUC970_UART1_FC_PE)
+    p = devm_pinctrl_get_select(&pdev->dev, "uart1-fc-PE");
+#elif defined (CONFIG_NUC970_UART1_FF_PE)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart1-ff-PE");
+#elif defined (CONFIG_NUC970_UART1_PH)
+    p = devm_pinctrl_get_select(&pdev->dev, "uart1-PH");
+#elif defined (CONFIG_NUC970_UART1_FC_PH)
+    p = devm_pinctrl_get_select(&pdev->dev, "uart1-fc-PH");
+#elif defined (CONFIG_NUC970_UART1_PI)
+    p = devm_pinctrl_get_select(&pdev->dev, "uart1-PI");
+#elif defined (CONFIG_NUC970_UART1_FC_PI)
+    p = devm_pinctrl_get_select(&pdev->dev, "uart1-fc-PI");
+#endif
+
+	if (IS_ERR(p))
+	{
+		dev_err(&pdev->dev, "unable to reserve pin\n");
+		retval = PTR_ERR(p);
+	}
+}
+else if(pdev->id == 2)
+{
+#if defined (CONFIG_NUC970_UART2_PF)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart2");
+#elif defined (CONFIG_NUC970_UART2_FC_PF)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart2_fc");
+#endif
+
+	if (IS_ERR(p))
+	{
+		dev_err(&pdev->dev, "unable to reserve pin\n");
+		retval = PTR_ERR(p);
+	}
+}
+else if(pdev->id == 4)
+{
+#if defined (CONFIG_NUC970_UART4_PC)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart4-PC");
+#elif defined (CONFIG_NUC970_UART4_FC_PC)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart4-fc-PC");
+#elif defined (CONFIG_NUC970_UART4_PH)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart4-PH");
+#elif defined (CONFIG_NUC970_UART4_FC_PH)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart4-fc-PH");
+#elif defined (CONFIG_NUC970_UART4_PI)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart4-PI");
+#endif
+
+	if (IS_ERR(p))
+	{
+		dev_err(&pdev->dev, "unable to reserve pin\n");
+		retval = PTR_ERR(p);
+	}
+}
+else if(pdev->id == 6)
+{
+#if defined (CONFIG_NUC970_UART6_PB)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart6-PB");
+#elif defined (CONFIG_NUC970_UART6_FC_PB)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart6-fc-PB");
+#elif defined (CONFIG_NUC970_UART6_PG)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart6-PG");
+#elif defined (CONFIG_NUC970_UART6_FC_PG)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart6-fc-PG");
+#endif
+
+	if (IS_ERR(p))
+	{
+		dev_err(&pdev->dev, "unable to reserve pin\n");
+		retval = PTR_ERR(p);
+	}
+}
+else if(pdev->id == 7)
+{
+#if defined (CONFIG_NUC970_UART7_PG)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart7-PG");
+#elif defined (CONFIG_NUC970_UART7_PI)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart7-PI");
+#endif
+
+	if (IS_ERR(p))
+	{
+		dev_err(&pdev->dev, "unable to reserve pin\n");
+		retval = PTR_ERR(p);
+	}
+}
+else if(pdev->id == 8)
+{
+#if defined (CONFIG_NUC970_UART8_PE)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart8-PE");
+#elif defined (CONFIG_NUC970_UART8_FC_PE)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart8-fc-PE");
+#elif defined (CONFIG_NUC970_UART8_PH)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart8-PH");
+#elif defined (CONFIG_NUC970_UART8_FC_PH)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart8-fc-PH");
+#elif defined (CONFIG_NUC970_UART8_PI)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart8-PI");
+#elif defined (CONFIG_NUC970_UART8_FC_PI)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart8-fc-PI");
+#endif
+
+	if (IS_ERR(p))
+	{
+		dev_err(&pdev->dev, "unable to reserve pin\n");
+		retval = PTR_ERR(p);
+	}
+}
+else if(pdev->id == 9)
+{
+#if defined (CONFIG_NUC970_UART9_PD0)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart9-PD0");
+#elif defined (CONFIG_NUC970_UART9_PD1)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart9-PD1");
+#elif defined (CONFIG_NUC970_UART9_PH)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart9-PH");
+#endif
+
+	if (IS_ERR(p))
+	{
+		dev_err(&pdev->dev, "unable to reserve pin\n");
+		retval = PTR_ERR(p);
+	}
+}
+else if(pdev->id == 10)
+{
+#if defined (CONFIG_NUC970_UART10_PB0)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart10-PB0");
+#elif defined (CONFIG_NUC970_UART10_PB1)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart10-PB1");
+#elif defined (CONFIG_NUC970_UART10_FC_PB1)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart10-fc-PB1");
+#elif defined (CONFIG_NUC970_UART10_PC)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart10-PC");
+#elif defined (CONFIG_NUC970_UART10_FC_PC)
+	p = devm_pinctrl_get_select(&pdev->dev, "uart10-fc-PC");
+#endif
+
+    if (IS_ERR(p))
+    {
+        dev_err(&pdev->dev, "unable to reserve pin\n");
+        retval = PTR_ERR(p);
+    }
+}
+	return retval;
+}
+
+void nuc970serial_set_clock(void)
+{
+	clk = clk_get(NULL, "uart0");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart0_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+
+	#ifdef CONFIG_NUC970_UART1
+	clk = clk_get(NULL, "uart1");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart1_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+	#ifdef CONFIG_NUC970_UART2
+	clk = clk_get(NULL, "uart2");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart2_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+	#ifdef CONFIG_NUC970_UART3
+	clk = clk_get(NULL, "uart3");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart3_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+	#ifdef CONFIG_NUC970_UART4
+	clk = clk_get(NULL, "uart4");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart4_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+	#ifdef CONFIG_NUC970_UART5
+	clk = clk_get(NULL, "uart5");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart5_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+	#ifdef CONFIG_NUC970_UART6
+	clk = clk_get(NULL, "uart6");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart6_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+	#ifdef CONFIG_NUC970_UART7
+	clk = clk_get(NULL, "uart7");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart7_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+	#ifdef CONFIG_NUC970_UART8
+	clk = clk_get(NULL, "uart8");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart8_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+	#ifdef CONFIG_NUC970_UART9
+	clk = clk_get(NULL, "uart9");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart9_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+	#ifdef CONFIG_NUC970_UART10
+	clk = clk_get(NULL, "uart10");
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	clk = clk_get(NULL, "uart10_eclk");
+	clk_prepare(clk);
+	clk_enable(clk);
+	#endif
+
+}
+
+/*
+ * Register a set of serial devices attached to a platform device.  The
+ * list is terminated with a zero flags entry, which means we expect
+ * all entries to have at least UPF_BOOT_AUTOCONF set.
+ */
+static int nuc970serial_probe(struct platform_device *pdev)
+{
+	struct plat_nuc970serial_port *p = pdev->dev.platform_data;
+	struct uart_nuc970_port *up;
+
+	int ret, i, retval;
+
+//	memset(&port, 0, sizeof(struct uart_port));
+
+	retval = nuc970serial_pinctrl(pdev);
+	if(retval != 0)
+		return retval;
+
+	nuc970serial_set_clock();
+
+	i = pdev->id;
+
+	//for (i = 0; i < UART_NR && p; p++, i++) {
+		up = &nuc970serial_ports[i];
+
+		up->port.line 			= i;
+		up->port.iobase       	= p->iobase;
+		up->port.membase      	= p->membase;
+		up->port.irq          	= p->irq;
+		up->port.uartclk      	= p->uartclk;
+		up->port.mapbase     	= p->mapbase;
+		up->port.private_data 	= p->private_data;
+		up->port.dev 			= &pdev->dev;
+		up->port.flags 			= ASYNC_BOOT_AUTOCONF;
+
+		/* Possibly override default I/O functions.  */
+		if (p->serial_in)
+			up->port.serial_in = p->serial_in;
+		if (p->serial_out)
+			up->port.serial_out = p->serial_out;
+
+		ret = uart_add_one_port(&nuc970serial_reg, &up->port);
+
+
+	//}
+
+
+
+
+	return 0;
+}
+
+/*
+ * Remove serial ports registered against a platform device.
+ */
+static int nuc970serial_remove(struct platform_device *dev)
+{
+	int i;
+	struct uart_port *port = platform_get_drvdata(dev);
+
+	free_irq(port->irq, port);
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_nuc970_port *up = &nuc970serial_ports[i];
+
+		if (up->port.dev == &dev->dev)
+			uart_remove_one_port(&nuc970serial_reg, &up->port);
+	}
+	return 0;
+}
+
+static int nuc970serial_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int i;
+	int wakeup_flag = 0;
+
+	struct uart_nuc970_port *up;
+
+	i = dev->id;
+
+        //printk("\n uart suspend !! %d \n", i);
+
+        up = &nuc970serial_ports[i];
+
+        //if (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)
+	//		uart_suspend_port(&nuc970serial_reg, &up->port);
+
+        #ifdef CONFIG_ENABLE_UART1_CTS_WAKEUP
+        if(i == 1)
+        {
+            __raw_writel((1<<8) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+        #endif
+
+        #ifdef CONFIG_ENABLE_UART2_CTS_WAKEUP
+        if(i == 2)
+        {
+            __raw_writel((1<<9) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+        #endif
+
+        #ifdef CONFIG_ENABLE_UART4_CTS_WAKEUP
+        if(i == 4)
+        {
+            __raw_writel((1<<10) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+        #endif
+
+        #ifdef CONFIG_ENABLE_UART6_CTS_WAKEUP
+        if(i == 6)
+        {
+            __raw_writel((1<<11) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+        #endif
+
+        #ifdef CONFIG_ENABLE_UART8_CTS_WAKEUP
+        if(i == 8)
+            __raw_writel((1<<12) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        #endif
+
+        #ifdef CONFIG_ENABLE_UART10_CTS_WAKEUP
+        if(i == 10)
+        {
+            __raw_writel((1<<13) | __raw_readl(REG_WKUPSER),REG_WKUPSER);
+            wakeup_flag = 1;
+        }
+        #endif
+
+        if(wakeup_flag == 1)
+        {
+	    //request_irq(up->port.irq, nuc970serial_interrupt, IRQF_NO_SUSPEND,
+	    //		"nuc970_serial", 0);
+
+            serial_out(up, UART_REG_IER, serial_in(up, UART_REG_IER) | (0x1 << 6));
+
+            enable_irq_wake(up->port.irq);
+	}
+
+	return 0;
+}
+
+static int nuc970serial_resume(struct platform_device *dev)
+{
+        #if 0
+	int i;
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_nuc970_port *up = &nuc970serial_ports[i];
+
+		if (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)
+			nuc970serial_resume_port(i);
+
+	}
+	#endif
+
+        //printk("\n uart resume !\n");
+
+	return 0;
+}
+
+static struct platform_driver nuc970serial_driver = {
+	.probe		= nuc970serial_probe,
+	.remove		= nuc970serial_remove,
+	.suspend	= nuc970serial_suspend,
+	.resume		= nuc970serial_resume,
+	.driver		= {
+		.name	= "nuc970-uart",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init nuc970serial_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&nuc970serial_reg);
+	if (ret)
+		return ret;
+#ifndef CONFIG_SERIAL_NUC970_CONSOLE
+	nuc970serial_init_ports();
+#endif
+	ret = platform_driver_register(&nuc970serial_driver);
+	if (ret)
+		uart_unregister_driver(&nuc970serial_reg);
+
+	return ret;
+}
+
+static void __exit nuc970serial_exit(void)
+{
+	platform_driver_unregister(&nuc970serial_driver);
+	uart_unregister_driver(&nuc970serial_reg);
+}
+
+module_init(nuc970serial_init);
+module_exit(nuc970serial_exit);
+
+EXPORT_SYMBOL(nuc970serial_suspend_port);
+EXPORT_SYMBOL(nuc970serial_resume_port);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NUC970 serial driver");
+
+MODULE_ALIAS_CHARDEV_MAJOR(TTY_MAJOR);
Index: linux-4.4.92/drivers/tty/serial/nuc970_serial.h
===================================================================
--- /dev/null
+++ linux-4.4.92/drivers/tty/serial/nuc970_serial.h
@@ -0,0 +1,72 @@
+/*
+ *  linux/drivers/serial/nuc970_serial.h
+ *
+ *  NUC970 serial driver header file
+ *
+ *
+ *  Copyright (C) 2012 Nuvoton Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __NUC970_SERIAL_H__
+#define __NUC970_SERIAL_H__
+
+#define UART_REG_RBR	0x00
+#define UART_REG_THR	0x00
+
+#define UART_REG_IER	0x04
+#define RDA_IEN			0x00000001
+#define THRE_IEN		0x00000002
+#define RTO_IEN			0x00000010
+#define TIME_OUT_EN		0x00000800
+
+#define UART_REG_FCR	0x08
+#define RFR			0x00000002
+#define TFR			0x00000004
+
+#define UART_REG_LCR	0x0C
+#define	NSB			0x00000004
+#define PBE			0x00000008
+#define EPE			0x00000010
+#define SPE			0x00000020
+#define BCB			0x00000040
+
+#define UART_REG_MCR	0x10
+#define UART_REG_MSR	0x14
+
+#define UART_REG_FSR	0x18
+#define RX_OVER_IF		0x00000001
+#define PEF			0x00000010
+#define FEF			0x00000020
+#define BIF			0x00000040
+#define RX_EMPTY		0x00004000
+#define TX_EMPTY		0x00400000
+#define TX_FULL			0x00800000
+#define RX_FULL			0x00008000
+#define TE_FLAG			0x10000000
+
+#define UART_REG_ISR	0x1C
+#define RDA_IF			0x00000001
+#define THRE_IF			0x00000002
+#define TOUT_IF			0x00000010
+
+#define UART_REG_TOR	0x20
+#define UART_REG_BAUD	0x24
+
+#define UART_REG_IRCR	0x28
+
+#define UART_REG_ALT_CSR 0x2C
+
+#define UART_FUN_SEL    0x30
+#define FUN_SEL_UART    0x00000000
+#define FUN_SEL_LIN     0x00000001
+#define FUN_SEL_IrDA    0x00000002
+#define FUN_SEL_RS485	0x00000003
+#define FUN_SEL_Msk		0x00000007
+
+#endif // __NUC970_SERIAL_H__
Index: linux-4.4.92/include/linux/platform_data/dma-nuc970.h
===================================================================
--- /dev/null
+++ linux-4.4.92/include/linux/platform_data/dma-nuc970.h
@@ -0,0 +1,79 @@
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#include <linux/types.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+
+/* M2M channels */
+#define NUC970_DMA_MEM		10
+
+/**
+ * struct nuc970_dma_data - configuration data for the NUC970 dmaengine
+ * @port: peripheral which is requesting the channel
+ * @direction: TX/RX channel
+ * @name: optional name for the channel, this is displayed in /proc/interrupts
+ *
+ * This information is passed as private channel parameter in a filter
+ * function. Note that this is only needed for slave/cyclic channels.  For
+ * memcpy channels %NULL data should be passed.
+ */
+struct nuc970_dma_data {
+	int				port;
+	enum dma_transfer_direction	direction;
+	const char			*name;
+};
+
+/**
+ * struct nuc970_dma_chan_data - platform specific data for a DMA channel
+ * @name: name of the channel, used for getting the right clock for the channel
+ * @base: mapped registers
+ * @irq: interrupt number used by this channel
+ */
+struct nuc970_dma_chan_data {
+	const char			*name;
+	void __iomem			*base;
+	int				irq;
+};
+
+/**
+ * struct nuc970_dma_platform_data - platform data for the dmaengine driver
+ * @channels: array of channels which are passed to the driver
+ * @num_channels: number of channels in the array
+ *
+ * This structure is passed to the DMA engine driver via platform data. For
+ * M2P channels, contract is that even channels are for TX and odd for RX.
+ * There is no requirement for the M2M channels.
+ */
+struct nuc970_dma_platform_data {
+	struct nuc970_dma_chan_data	*channels;
+	size_t				num_channels;
+};
+
+#if 0
+static inline bool nuc970_dma_chan_is_m2p(struct dma_chan *chan)
+{
+	return !strcmp(dev_name(chan->device->dev), "nuc970-dma-m2p");
+}
+#endif
+
+#if 0
+/**
+ * nuc970_dma_chan_direction - returns direction the channel can be used
+ * @chan: channel
+ *
+ * This function can be used in filter functions to find out whether the
+ * channel supports given DMA direction. Only M2P channels have such
+ * limitation, for M2M channels the direction is configurable.
+ */
+static inline enum dma_transfer_direction
+nuc970_dma_chan_direction(struct dma_chan *chan)
+{
+	if (!nuc970_dma_chan_is_m2p(chan))
+		return DMA_NONE;
+
+	/* even channels are for TX, odd for RX */
+	return (chan->chan_id % 2 == 0) ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
+}
+#endif
+#endif /* __ASM_ARCH_DMA_H */
Index: linux-4.4.92/include/linux/platform_data/i2c-nuc970.h
===================================================================
--- /dev/null
+++ linux-4.4.92/include/linux/platform_data/i2c-nuc970.h
@@ -0,0 +1,11 @@
+#ifndef __ASM_ARCH_NUC970_I2C_H
+#define __ASM_ARCH_NUC970_I2C_H
+
+extern void nuc970_mfp_set_port_g(u32 pin, u32 func);
+
+struct nuc970_platform_i2c {
+	int		bus_num;
+	unsigned long   bus_freq;
+};
+
+#endif /* __ASM_ARCH_NUC970_I2C_H */
Index: linux-4.4.92/include/linux/platform_data/keypad-nuc970.h
===================================================================
--- /dev/null
+++ linux-4.4.92/include/linux/platform_data/keypad-nuc970.h
@@ -0,0 +1,25 @@
+/*
+ * /linux/platform_data/keypad-nuc970.h
+ *
+ * Copyright (c) 2014 Nuvoton technology corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+
+#ifndef __ASM_ARCH_NUC970_KEYPAD_H
+#define __ASM_ARCH_NUC970_KEYPAD_H
+
+#include <linux/input/matrix_keypad.h>
+
+struct nuc970_keypad_platform_data {
+	const struct matrix_keymap_data *keymap_data;
+
+	unsigned int	prescale;
+	unsigned int	debounce;
+};
+
+#endif /* __ASM_ARCH_W90P910_KEYPAD_H */
Index: linux-4.4.92/include/linux/platform_data/spi-nuc970.h
===================================================================
--- /dev/null
+++ linux-4.4.92/include/linux/platform_data/spi-nuc970.h
@@ -0,0 +1,31 @@
+/*
+ * arch/arm/mach-w90x900/include/mach/nuc970_spi.h
+ *
+ * Copyright (c) 2009 Nuvoton technology corporation.
+ *
+ * Wan ZongShun <mcuos.com@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#ifndef __ASM_ARCH_SPI_H
+#define __ASM_ARCH_SPI_H
+
+struct nuc970_spi_info {
+	unsigned int num_cs;
+	unsigned int lsb;
+	unsigned int txneg;
+	unsigned int rxneg;
+	unsigned int divider;
+	unsigned int sleep;
+	unsigned int txnum;
+	unsigned int txbitlen;
+    unsigned int clkpol;
+	int bus_num;
+    unsigned int hz;
+};
+
+#endif 
Index: linux-4.4.92/include/linux/platform_data/video-nuc970fb.h
===================================================================
--- /dev/null
+++ linux-4.4.92/include/linux/platform_data/video-nuc970fb.h
@@ -0,0 +1,81 @@
+/* linux/include/asm/arch-nuc970/fb.h
+ *
+ * Copyright (c) 2008 Nuvoton technology corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Changelog:
+ *
+ *   2008/08/26     vincen.zswan modify this file for LCD.
+ */
+
+#ifndef __ASM_ARM_FB_H
+#define __ASM_ARM_FB_H
+
+
+
+/* LCD Controller Hardware Desc */
+struct nuc970fb_hw {
+	unsigned int lcd_dccs;
+	unsigned int lcd_device_ctrl;
+	unsigned int lcd_mpulcd_cmd;
+	unsigned int lcd_int_cs;
+	unsigned int lcd_crtc_size;
+	unsigned int lcd_crtc_dend;
+	unsigned int lcd_crtc_hr;
+	unsigned int lcd_crtc_hsync;
+	unsigned int lcd_crtc_vr;
+	unsigned int lcd_va_baddr0;
+	unsigned int lcd_va_baddr1;
+	unsigned int lcd_va_fbctrl;
+	unsigned int lcd_va_scale;
+	unsigned int lcd_va_test;
+	unsigned int lcd_va_win;
+	unsigned int lcd_va_stuff;
+};
+
+/* LCD Display Description */
+struct nuc970fb_display {
+	/* LCD Image type */
+	unsigned type;
+
+	/* LCD Screen Size */
+	unsigned short width;
+	unsigned short height;
+
+	/* LCD Screen Info */
+	unsigned short xres;
+	unsigned short yres;
+	unsigned short bpp;
+
+	unsigned long pixclock;
+	unsigned short left_margin;
+	unsigned short right_margin;
+	unsigned short hsync_len;
+	unsigned short upper_margin;
+	unsigned short lower_margin;
+	unsigned short vsync_len;
+
+	/* hardware special register value */
+	unsigned int dccs;
+	unsigned int devctl;
+	unsigned int fbctrl;
+	unsigned int scale;
+};
+
+struct nuc970fb_mach_info {
+	struct nuc970fb_display *displays;
+	unsigned int num_displays;
+	unsigned int default_display;
+	/* GPIO Setting  Info */
+    unsigned int gpio_blen;
+    unsigned int gpio_lcs;
+};
+
+extern void __init nuc970_fb_set_platdata(struct nuc970fb_mach_info *);
+
+#endif /* __ASM_ARM_FB_H */
Index: linux-4.4.92/include/uapi/linux/serial_core.h
===================================================================
--- linux-4.4.92.orig/include/uapi/linux/serial_core.h
+++ linux-4.4.92/include/uapi/linux/serial_core.h
@@ -261,4 +261,7 @@
 /* STM32 USART */
 #define PORT_STM32	113
 
+/* NUC970 UART */
+#define PORT_NUC970 114
+
 #endif /* _UAPILINUX_SERIAL_CORE_H */
Index: linux-4.4.92/arch/arm/tools/mach-types
===================================================================
--- linux-4.4.92.orig/arch/arm/tools/mach-types
+++ linux-4.4.92/arch/arm/tools/mach-types
@@ -1006,6 +1006,7 @@ eco5_bx2		MACH_ECO5_BX2		ECO5_BX2		4572
 eukrea_cpuimx28sd	MACH_EUKREA_CPUIMX28SD	EUKREA_CPUIMX28SD	4573
 domotab			MACH_DOMOTAB		DOMOTAB			4574
 pfla03			MACH_PFLA03		PFLA03			4575
+nuc970                  MACH_NUC970             NUC970                  4576
 #
 # Additional mach-types supported by OpenWrt
 #
